{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/PluggableMap\n */\n\n\nimport BaseObject from './Object.js';\nimport Collection from './Collection.js';\nimport CollectionEventType from './CollectionEventType.js';\nimport EventType from './events/EventType.js';\nimport LayerGroup from './layer/Group.js';\nimport MapBrowserEvent from './MapBrowserEvent.js';\nimport MapBrowserEventHandler from './MapBrowserEventHandler.js';\nimport MapBrowserEventType from './MapBrowserEventType.js';\nimport MapEvent from './MapEvent.js';\nimport MapEventType from './MapEventType.js';\nimport MapProperty from './MapProperty.js';\nimport ObjectEventType from './ObjectEventType.js';\nimport PointerEventType from './pointer/EventType.js';\nimport RenderEventType from './render/EventType.js';\nimport TileQueue, { getTilePriority } from './TileQueue.js';\nimport View from './View.js';\nimport ViewHint from './ViewHint.js';\nimport { DEVICE_PIXEL_RATIO, PASSIVE_EVENT_LISTENERS } from './has.js';\nimport { TRUE } from './functions.js';\nimport { apply as applyTransform, create as createTransform } from './transform.js';\nimport { assert } from './asserts.js';\nimport { clone, createOrUpdateEmpty, equals, getForViewAndSize, isEmpty } from './extent.js';\nimport { fromUserCoordinate, toUserCoordinate } from './proj.js';\nimport { hasArea } from './size.js';\nimport { listen, unlistenByKey } from './events.js';\nimport { removeNode } from './dom.js';\n/**\n * State of the current frame. Only `pixelRatio`, `time` and `viewState` should\n * be used in applications.\n * @typedef {Object} FrameState\n * @property {number} pixelRatio The pixel ratio of the frame.\n * @property {number} time The time when rendering of the frame was requested.\n * @property {import(\"./View.js\").State} viewState The state of the current view.\n * @property {boolean} animate Animate.\n * @property {import(\"./transform.js\").Transform} coordinateToPixelTransform CoordinateToPixelTransform.\n * @property {import(\"rbush\").default} declutterTree DeclutterTree.\n * @property {null|import(\"./extent.js\").Extent} extent Extent.\n * @property {number} index Index.\n * @property {Array<import(\"./layer/Layer.js\").State>} layerStatesArray LayerStatesArray.\n * @property {number} layerIndex LayerIndex.\n * @property {import(\"./transform.js\").Transform} pixelToCoordinateTransform PixelToCoordinateTransform.\n * @property {Array<PostRenderFunction>} postRenderFunctions PostRenderFunctions.\n * @property {import(\"./size.js\").Size} size Size.\n * @property {TileQueue} tileQueue TileQueue.\n * @property {!Object<string, Object<string, boolean>>} usedTiles UsedTiles.\n * @property {Array<number>} viewHints ViewHints.\n * @property {!Object<string, Object<string, boolean>>} wantedTiles WantedTiles.\n */\n\n/**\n * @typedef {function(PluggableMap, ?FrameState): any} PostRenderFunction\n */\n\n/**\n * @typedef {Object} AtPixelOptions\n * @property {undefined|function(import(\"./layer/Layer.js\").default): boolean} [layerFilter] Layer filter\n * function. The filter function will receive one argument, the\n * {@link module:ol/layer/Layer layer-candidate} and it should return a boolean value.\n * Only layers which are visible and for which this function returns `true`\n * will be tested for features. By default, all visible layers will be tested.\n * @property {number} [hitTolerance=0] Hit-detection tolerance in css pixels. Pixels\n * inside the radius around the given position will be checked for features.\n * @property {boolean} [checkWrapped=true] Check-Wrapped Will check for for wrapped geometries inside the range of\n *   +/- 1 world width. Works only if a projection is used that can be wrapped.\n */\n\n/**\n * @typedef {Object} MapOptionsInternal\n * @property {Collection<import(\"./control/Control.js\").default>} [controls] Controls.\n * @property {Collection<import(\"./interaction/Interaction.js\").default>} [interactions] Interactions.\n * @property {HTMLElement|Document} keyboardEventTarget KeyboardEventTarget.\n * @property {Collection<import(\"./Overlay.js\").default>} overlays Overlays.\n * @property {Object<string, *>} values Values.\n */\n\n/**\n * @typedef {import(\"./ObjectEventType\").Types|'change:layergroup'|'change:size'|'change:target'|'change:view'} MapObjectEventTypes\n */\n\n/***\n * @template Return\n * @typedef {import(\"./Observable\").OnSignature<import(\"./Observable\").EventTypes, import(\"./events/Event.js\").default, Return> &\n *    import(\"./Observable\").OnSignature<MapObjectEventTypes, import(\"./Object\").ObjectEvent, Return> &\n *    import(\"./Observable\").OnSignature<import(\"./MapBrowserEventType\").Types, import(\"./MapBrowserEvent\").default, Return> &\n *    import(\"./Observable\").OnSignature<import(\"./MapEventType\").Types, import(\"./MapEvent\").default, Return> &\n *    import(\"./Observable\").OnSignature<import(\"./render/EventType\").MapRenderEventTypes, import(\"./render/Event\").default, Return> &\n *    import(\"./Observable\").CombinedOnSignature<import(\"./Observable\").EventTypes|MapObjectEventTypes|\n *      import(\"./MapBrowserEventType\").Types|import(\"./MapEventType\").Types|\n *      import(\"./render/EventType\").MapRenderEventTypes, Return>} PluggableMapOnSignature\n */\n\n/**\n * Object literal with config options for the map.\n * @typedef {Object} MapOptions\n * @property {Collection<import(\"./control/Control.js\").default>|Array<import(\"./control/Control.js\").default>} [controls]\n * Controls initially added to the map. If not specified,\n * {@link module:ol/control.defaults} is used.\n * @property {number} [pixelRatio=window.devicePixelRatio] The ratio between\n * physical pixels and device-independent pixels (dips) on the device.\n * @property {Collection<import(\"./interaction/Interaction.js\").default>|Array<import(\"./interaction/Interaction.js\").default>} [interactions]\n * Interactions that are initially added to the map. If not specified,\n * {@link module:ol/interaction.defaults} is used.\n * @property {HTMLElement|Document|string} [keyboardEventTarget] The element to\n * listen to keyboard events on. This determines when the `KeyboardPan` and\n * `KeyboardZoom` interactions trigger. For example, if this option is set to\n * `document` the keyboard interactions will always trigger. If this option is\n * not specified, the element the library listens to keyboard events on is the\n * map target (i.e. the user-provided div for the map). If this is not\n * `document`, the target element needs to be focused for key events to be\n * emitted, requiring that the target element has a `tabindex` attribute.\n * @property {Array<import(\"./layer/Base.js\").default>|Collection<import(\"./layer/Base.js\").default>|LayerGroup} [layers]\n * Layers. If this is not defined, a map with no layers will be rendered. Note\n * that layers are rendered in the order supplied, so if you want, for example,\n * a vector layer to appear on top of a tile layer, it must come after the tile\n * layer.\n * @property {number} [maxTilesLoading=16] Maximum number tiles to load\n * simultaneously.\n * @property {number} [moveTolerance=1] The minimum distance in pixels the\n * cursor must move to be detected as a map move event instead of a click.\n * Increasing this value can make it easier to click on the map.\n * @property {Collection<import(\"./Overlay.js\").default>|Array<import(\"./Overlay.js\").default>} [overlays]\n * Overlays initially added to the map. By default, no overlays are added.\n * @property {HTMLElement|string} [target] The container for the map, either the\n * element itself or the `id` of the element. If not specified at construction\n * time, {@link module:ol/Map~Map#setTarget} must be called for the map to be\n * rendered. If passed by element, the container can be in a secondary document.\n * @property {View} [view] The map's view.  No layer sources will be\n * fetched unless this is specified at construction time or through\n * {@link module:ol/Map~Map#setView}.\n */\n\n/**\n * @api\n */\n\nvar PluggableMap = function (_super) {\n  __extends(PluggableMap, _super);\n  /**\n   * @param {MapOptions} options Map options.\n   */\n\n\n  function PluggableMap(options) {\n    var _this = _super.call(this) || this;\n    /***\n     * @type {PluggableMapOnSignature<import(\"./Observable.js\").OnReturn>}\n     */\n\n\n    _this.on;\n    /***\n     * @type {PluggableMapOnSignature<import(\"./Observable.js\").OnReturn>}\n     */\n\n    _this.once;\n    /***\n     * @type {PluggableMapOnSignature<void>}\n     */\n\n    _this.un;\n    var optionsInternal = createOptionsInternal(options);\n    /** @private */\n\n    _this.boundHandleBrowserEvent_ = _this.handleBrowserEvent.bind(_this);\n    /**\n     * @type {number}\n     * @private\n     */\n\n    _this.maxTilesLoading_ = options.maxTilesLoading !== undefined ? options.maxTilesLoading : 16;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    _this.pixelRatio_ = options.pixelRatio !== undefined ? options.pixelRatio : DEVICE_PIXEL_RATIO;\n    /**\n     * @private\n     * @type {*}\n     */\n\n    _this.postRenderTimeoutHandle_;\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n\n    _this.animationDelayKey_;\n    /**\n     * @private\n     */\n\n    _this.animationDelay_ =\n    /** @this {PluggableMap} */\n    function () {\n      this.animationDelayKey_ = undefined;\n      this.renderFrame_(Date.now());\n    }.bind(_this);\n    /**\n     * @private\n     * @type {import(\"./transform.js\").Transform}\n     */\n\n\n    _this.coordinateToPixelTransform_ = createTransform();\n    /**\n     * @private\n     * @type {import(\"./transform.js\").Transform}\n     */\n\n    _this.pixelToCoordinateTransform_ = createTransform();\n    /**\n     * @private\n     * @type {number}\n     */\n\n    _this.frameIndex_ = 0;\n    /**\n     * @private\n     * @type {?FrameState}\n     */\n\n    _this.frameState_ = null;\n    /**\n     * The extent at the previous 'moveend' event.\n     * @private\n     * @type {import(\"./extent.js\").Extent}\n     */\n\n    _this.previousExtent_ = null;\n    /**\n     * @private\n     * @type {?import(\"./events.js\").EventsKey}\n     */\n\n    _this.viewPropertyListenerKey_ = null;\n    /**\n     * @private\n     * @type {?import(\"./events.js\").EventsKey}\n     */\n\n    _this.viewChangeListenerKey_ = null;\n    /**\n     * @private\n     * @type {?Array<import(\"./events.js\").EventsKey>}\n     */\n\n    _this.layerGroupPropertyListenerKeys_ = null;\n    /**\n     * @private\n     * @type {!HTMLElement}\n     */\n\n    _this.viewport_ = document.createElement('div');\n    _this.viewport_.className = 'ol-viewport' + ('ontouchstart' in window ? ' ol-touch' : '');\n    _this.viewport_.style.position = 'relative';\n    _this.viewport_.style.overflow = 'hidden';\n    _this.viewport_.style.width = '100%';\n    _this.viewport_.style.height = '100%';\n    /**\n     * @private\n     * @type {!HTMLElement}\n     */\n\n    _this.overlayContainer_ = document.createElement('div');\n    _this.overlayContainer_.style.position = 'absolute';\n    _this.overlayContainer_.style.zIndex = '0';\n    _this.overlayContainer_.style.width = '100%';\n    _this.overlayContainer_.style.height = '100%';\n    _this.overlayContainer_.style.pointerEvents = 'none';\n    _this.overlayContainer_.className = 'ol-overlaycontainer';\n\n    _this.viewport_.appendChild(_this.overlayContainer_);\n    /**\n     * @private\n     * @type {!HTMLElement}\n     */\n\n\n    _this.overlayContainerStopEvent_ = document.createElement('div');\n    _this.overlayContainerStopEvent_.style.position = 'absolute';\n    _this.overlayContainerStopEvent_.style.zIndex = '0';\n    _this.overlayContainerStopEvent_.style.width = '100%';\n    _this.overlayContainerStopEvent_.style.height = '100%';\n    _this.overlayContainerStopEvent_.style.pointerEvents = 'none';\n    _this.overlayContainerStopEvent_.className = 'ol-overlaycontainer-stopevent';\n\n    _this.viewport_.appendChild(_this.overlayContainerStopEvent_);\n    /**\n     * @private\n     * @type {MapBrowserEventHandler}\n     */\n\n\n    _this.mapBrowserEventHandler_ = null;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    _this.moveTolerance_ = options.moveTolerance;\n    /**\n     * @private\n     * @type {HTMLElement|Document}\n     */\n\n    _this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;\n    /**\n     * @private\n     * @type {?Array<import(\"./events.js\").EventsKey>}\n     */\n\n    _this.keyHandlerKeys_ = null;\n    /**\n     * @type {Collection<import(\"./control/Control.js\").default>}\n     * @protected\n     */\n\n    _this.controls = optionsInternal.controls || new Collection();\n    /**\n     * @type {Collection<import(\"./interaction/Interaction.js\").default>}\n     * @protected\n     */\n\n    _this.interactions = optionsInternal.interactions || new Collection();\n    /**\n     * @type {Collection<import(\"./Overlay.js\").default>}\n     * @private\n     */\n\n    _this.overlays_ = optionsInternal.overlays;\n    /**\n     * A lookup of overlays by id.\n     * @private\n     * @type {Object<string, import(\"./Overlay.js\").default>}\n     */\n\n    _this.overlayIdIndex_ = {};\n    /**\n     * @type {import(\"./renderer/Map.js\").default}\n     * @private\n     */\n\n    _this.renderer_ = null;\n    /**\n     * @type {undefined|function(Event): void}\n     * @private\n     */\n\n    _this.handleResize_;\n    /**\n     * @private\n     * @type {!Array<PostRenderFunction>}\n     */\n\n    _this.postRenderFunctions_ = [];\n    /**\n     * @private\n     * @type {TileQueue}\n     */\n\n    _this.tileQueue_ = new TileQueue(_this.getTilePriority.bind(_this), _this.handleTileChange_.bind(_this));\n\n    _this.addChangeListener(MapProperty.LAYERGROUP, _this.handleLayerGroupChanged_);\n\n    _this.addChangeListener(MapProperty.VIEW, _this.handleViewChanged_);\n\n    _this.addChangeListener(MapProperty.SIZE, _this.handleSizeChanged_);\n\n    _this.addChangeListener(MapProperty.TARGET, _this.handleTargetChanged_); // setProperties will trigger the rendering of the map if the map\n    // is \"defined\" already.\n\n\n    _this.setProperties(optionsInternal.values);\n\n    _this.controls.forEach(\n    /**\n     * @param {import(\"./control/Control.js\").default} control Control.\n     * @this {PluggableMap}\n     */\n    function (control) {\n      control.setMap(this);\n    }.bind(_this));\n\n    _this.controls.addEventListener(CollectionEventType.ADD,\n    /**\n     * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\n     */\n    function (event) {\n      event.element.setMap(this);\n    }.bind(_this));\n\n    _this.controls.addEventListener(CollectionEventType.REMOVE,\n    /**\n     * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\n     */\n    function (event) {\n      event.element.setMap(null);\n    }.bind(_this));\n\n    _this.interactions.forEach(\n    /**\n     * @param {import(\"./interaction/Interaction.js\").default} interaction Interaction.\n     * @this {PluggableMap}\n     */\n    function (interaction) {\n      interaction.setMap(this);\n    }.bind(_this));\n\n    _this.interactions.addEventListener(CollectionEventType.ADD,\n    /**\n     * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\n     */\n    function (event) {\n      event.element.setMap(this);\n    }.bind(_this));\n\n    _this.interactions.addEventListener(CollectionEventType.REMOVE,\n    /**\n     * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\n     */\n    function (event) {\n      event.element.setMap(null);\n    }.bind(_this));\n\n    _this.overlays_.forEach(_this.addOverlayInternal_.bind(_this));\n\n    _this.overlays_.addEventListener(CollectionEventType.ADD,\n    /**\n     * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\n     */\n    function (event) {\n      this.addOverlayInternal_(event.element);\n    }.bind(_this));\n\n    _this.overlays_.addEventListener(CollectionEventType.REMOVE,\n    /**\n     * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\n     */\n    function (event) {\n      var overlay = event.element;\n      var id = overlay.getId();\n\n      if (id !== undefined) {\n        delete this.overlayIdIndex_[id.toString()];\n      }\n\n      event.element.setMap(null);\n    }.bind(_this));\n\n    return _this;\n  }\n  /**\n   * @abstract\n   * @return {import(\"./renderer/Map.js\").default} The map renderer\n   */\n\n\n  PluggableMap.prototype.createRenderer = function () {\n    throw new Error('Use a map type that has a createRenderer method');\n  };\n  /**\n   * Add the given control to the map.\n   * @param {import(\"./control/Control.js\").default} control Control.\n   * @api\n   */\n\n\n  PluggableMap.prototype.addControl = function (control) {\n    this.getControls().push(control);\n  };\n  /**\n   * Add the given interaction to the map. If you want to add an interaction\n   * at another point of the collection use `getInteraction()` and the methods\n   * available on {@link module:ol/Collection~Collection}. This can be used to\n   * stop the event propagation from the handleEvent function. The interactions\n   * get to handle the events in the reverse order of this collection.\n   * @param {import(\"./interaction/Interaction.js\").default} interaction Interaction to add.\n   * @api\n   */\n\n\n  PluggableMap.prototype.addInteraction = function (interaction) {\n    this.getInteractions().push(interaction);\n  };\n  /**\n   * Adds the given layer to the top of this map. If you want to add a layer\n   * elsewhere in the stack, use `getLayers()` and the methods available on\n   * {@link module:ol/Collection~Collection}.\n   * @param {import(\"./layer/Base.js\").default} layer Layer.\n   * @api\n   */\n\n\n  PluggableMap.prototype.addLayer = function (layer) {\n    var layers = this.getLayerGroup().getLayers();\n    layers.push(layer);\n  };\n  /**\n   * Add the given overlay to the map.\n   * @param {import(\"./Overlay.js\").default} overlay Overlay.\n   * @api\n   */\n\n\n  PluggableMap.prototype.addOverlay = function (overlay) {\n    this.getOverlays().push(overlay);\n  };\n  /**\n   * This deals with map's overlay collection changes.\n   * @param {import(\"./Overlay.js\").default} overlay Overlay.\n   * @private\n   */\n\n\n  PluggableMap.prototype.addOverlayInternal_ = function (overlay) {\n    var id = overlay.getId();\n\n    if (id !== undefined) {\n      this.overlayIdIndex_[id.toString()] = overlay;\n    }\n\n    overlay.setMap(this);\n  };\n  /**\n   *\n   * Clean up.\n   */\n\n\n  PluggableMap.prototype.disposeInternal = function () {\n    this.setTarget(null);\n\n    _super.prototype.disposeInternal.call(this);\n  };\n  /**\n   * Detect features that intersect a pixel on the viewport, and execute a\n   * callback with each intersecting feature. Layers included in the detection can\n   * be configured through the `layerFilter` option in `opt_options`.\n   * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\n   * @param {function(import(\"./Feature.js\").FeatureLike, import(\"./layer/Layer.js\").default, import(\"./geom/SimpleGeometry.js\").default): T} callback Feature callback. The callback will be\n   *     called with two arguments. The first argument is one\n   *     {@link module:ol/Feature feature} or\n   *     {@link module:ol/render/Feature render feature} at the pixel, the second is\n   *     the {@link module:ol/layer/Layer layer} of the feature and will be null for\n   *     unmanaged layers. To stop detection, callback functions can return a\n   *     truthy value.\n   * @param {AtPixelOptions} [opt_options] Optional options.\n   * @return {T|undefined} Callback result, i.e. the return value of last\n   * callback execution, or the first truthy callback return value.\n   * @template S,T\n   * @api\n   */\n\n\n  PluggableMap.prototype.forEachFeatureAtPixel = function (pixel, callback, opt_options) {\n    if (!this.frameState_) {\n      return;\n    }\n\n    var coordinate = this.getCoordinateFromPixelInternal(pixel);\n    opt_options = opt_options !== undefined ? opt_options : {};\n    var hitTolerance = opt_options.hitTolerance !== undefined ? opt_options.hitTolerance : 0;\n    var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : TRUE;\n    var checkWrapped = opt_options.checkWrapped !== false;\n    return this.renderer_.forEachFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, callback, null, layerFilter, null);\n  };\n  /**\n   * Get all features that intersect a pixel on the viewport.\n   * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\n   * @param {AtPixelOptions} [opt_options] Optional options.\n   * @return {Array<import(\"./Feature.js\").FeatureLike>} The detected features or\n   * an empty array if none were found.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getFeaturesAtPixel = function (pixel, opt_options) {\n    var features = [];\n    this.forEachFeatureAtPixel(pixel, function (feature) {\n      features.push(feature);\n    }, opt_options);\n    return features;\n  };\n  /**\n   * Detect layers that have a color value at a pixel on the viewport, and\n   * execute a callback with each matching layer. Layers included in the\n   * detection can be configured through `opt_layerFilter`.\n   *\n   * Note: this may give false positives unless the map layers have had different `className`\n   * properties assigned to them.\n   *\n   * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\n   * @param {function(this: S, import(\"./layer/Layer.js\").default, (Uint8ClampedArray|Uint8Array)): T} callback\n   *     Layer callback. This callback will receive two arguments: first is the\n   *     {@link module:ol/layer/Layer layer}, second argument is an array representing\n   *     [R, G, B, A] pixel values (0 - 255) and will be `null` for layer types\n   *     that do not currently support this argument. To stop detection, callback\n   *     functions can return a truthy value.\n   * @param {AtPixelOptions} [opt_options] Configuration options.\n   * @return {T|undefined} Callback result, i.e. the return value of last\n   * callback execution, or the first truthy callback return value.\n   * @template S,T\n   * @api\n   */\n\n\n  PluggableMap.prototype.forEachLayerAtPixel = function (pixel, callback, opt_options) {\n    if (!this.frameState_) {\n      return;\n    }\n\n    var options = opt_options || {};\n    var hitTolerance = options.hitTolerance !== undefined ? options.hitTolerance : 0;\n    var layerFilter = options.layerFilter || TRUE;\n    return this.renderer_.forEachLayerAtPixel(pixel, this.frameState_, hitTolerance, callback, layerFilter);\n  };\n  /**\n   * Detect if features intersect a pixel on the viewport. Layers included in the\n   * detection can be configured through `opt_layerFilter`.\n   * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\n   * @param {AtPixelOptions} [opt_options] Optional options.\n   * @return {boolean} Is there a feature at the given pixel?\n   * @api\n   */\n\n\n  PluggableMap.prototype.hasFeatureAtPixel = function (pixel, opt_options) {\n    if (!this.frameState_) {\n      return false;\n    }\n\n    var coordinate = this.getCoordinateFromPixelInternal(pixel);\n    opt_options = opt_options !== undefined ? opt_options : {};\n    var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : TRUE;\n    var hitTolerance = opt_options.hitTolerance !== undefined ? opt_options.hitTolerance : 0;\n    var checkWrapped = opt_options.checkWrapped !== false;\n    return this.renderer_.hasFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, layerFilter, null);\n  };\n  /**\n   * Returns the coordinate in user projection for a browser event.\n   * @param {MouseEvent} event Event.\n   * @return {import(\"./coordinate.js\").Coordinate} Coordinate.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getEventCoordinate = function (event) {\n    return this.getCoordinateFromPixel(this.getEventPixel(event));\n  };\n  /**\n   * Returns the coordinate in view projection for a browser event.\n   * @param {MouseEvent} event Event.\n   * @return {import(\"./coordinate.js\").Coordinate} Coordinate.\n   */\n\n\n  PluggableMap.prototype.getEventCoordinateInternal = function (event) {\n    return this.getCoordinateFromPixelInternal(this.getEventPixel(event));\n  };\n  /**\n   * Returns the map pixel position for a browser event relative to the viewport.\n   * @param {UIEvent} event Event.\n   * @return {import(\"./pixel.js\").Pixel} Pixel.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getEventPixel = function (event) {\n    var viewportPosition = this.viewport_.getBoundingClientRect();\n    var eventPosition = //FIXME Are we really calling this with a TouchEvent anywhere?\n    'changedTouches' in event ?\n    /** @type {TouchEvent} */\n    event.changedTouches[0] : event;\n    return [eventPosition.clientX - viewportPosition.left, eventPosition.clientY - viewportPosition.top];\n  };\n  /**\n   * Get the target in which this map is rendered.\n   * Note that this returns what is entered as an option or in setTarget:\n   * if that was an element, it returns an element; if a string, it returns that.\n   * @return {HTMLElement|string|undefined} The Element or id of the Element that the\n   *     map is rendered in.\n   * @observable\n   * @api\n   */\n\n\n  PluggableMap.prototype.getTarget = function () {\n    return this.get(MapProperty.TARGET);\n  };\n  /**\n   * Get the DOM element into which this map is rendered. In contrast to\n   * `getTarget` this method always return an `Element`, or `null` if the\n   * map has no target.\n   * @return {HTMLElement} The element that the map is rendered in.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getTargetElement = function () {\n    var target = this.getTarget();\n\n    if (target !== undefined) {\n      return typeof target === 'string' ? document.getElementById(target) : target;\n    } else {\n      return null;\n    }\n  };\n  /**\n   * Get the coordinate for a given pixel.  This returns a coordinate in the\n   * user projection.\n   * @param {import(\"./pixel.js\").Pixel} pixel Pixel position in the map viewport.\n   * @return {import(\"./coordinate.js\").Coordinate} The coordinate for the pixel position.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getCoordinateFromPixel = function (pixel) {\n    return toUserCoordinate(this.getCoordinateFromPixelInternal(pixel), this.getView().getProjection());\n  };\n  /**\n   * Get the coordinate for a given pixel.  This returns a coordinate in the\n   * map view projection.\n   * @param {import(\"./pixel.js\").Pixel} pixel Pixel position in the map viewport.\n   * @return {import(\"./coordinate.js\").Coordinate} The coordinate for the pixel position.\n   */\n\n\n  PluggableMap.prototype.getCoordinateFromPixelInternal = function (pixel) {\n    var frameState = this.frameState_;\n\n    if (!frameState) {\n      return null;\n    } else {\n      return applyTransform(frameState.pixelToCoordinateTransform, pixel.slice());\n    }\n  };\n  /**\n   * Get the map controls. Modifying this collection changes the controls\n   * associated with the map.\n   * @return {Collection<import(\"./control/Control.js\").default>} Controls.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getControls = function () {\n    return this.controls;\n  };\n  /**\n   * Get the map overlays. Modifying this collection changes the overlays\n   * associated with the map.\n   * @return {Collection<import(\"./Overlay.js\").default>} Overlays.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getOverlays = function () {\n    return this.overlays_;\n  };\n  /**\n   * Get an overlay by its identifier (the value returned by overlay.getId()).\n   * Note that the index treats string and numeric identifiers as the same. So\n   * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.\n   * @param {string|number} id Overlay identifier.\n   * @return {import(\"./Overlay.js\").default} Overlay.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getOverlayById = function (id) {\n    var overlay = this.overlayIdIndex_[id.toString()];\n    return overlay !== undefined ? overlay : null;\n  };\n  /**\n   * Get the map interactions. Modifying this collection changes the interactions\n   * associated with the map.\n   *\n   * Interactions are used for e.g. pan, zoom and rotate.\n   * @return {Collection<import(\"./interaction/Interaction.js\").default>} Interactions.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getInteractions = function () {\n    return this.interactions;\n  };\n  /**\n   * Get the layergroup associated with this map.\n   * @return {LayerGroup} A layer group containing the layers in this map.\n   * @observable\n   * @api\n   */\n\n\n  PluggableMap.prototype.getLayerGroup = function () {\n    return this.get(MapProperty.LAYERGROUP);\n  };\n  /**\n   * Get the collection of layers associated with this map.\n   * @return {!Collection<import(\"./layer/Base.js\").default>} Layers.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getLayers = function () {\n    var layers = this.getLayerGroup().getLayers();\n    return layers;\n  };\n  /**\n   * @return {boolean} Layers have sources that are still loading.\n   */\n\n\n  PluggableMap.prototype.getLoading = function () {\n    var layerStatesArray = this.getLayerGroup().getLayerStatesArray();\n\n    for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {\n      var layer = layerStatesArray[i].layer;\n      var source =\n      /** @type {import(\"./layer/Layer.js\").default} */\n      layer.getSource();\n\n      if (source && source.loading) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Get the pixel for a coordinate.  This takes a coordinate in the user\n   * projection and returns the corresponding pixel.\n   * @param {import(\"./coordinate.js\").Coordinate} coordinate A map coordinate.\n   * @return {import(\"./pixel.js\").Pixel} A pixel position in the map viewport.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getPixelFromCoordinate = function (coordinate) {\n    var viewCoordinate = fromUserCoordinate(coordinate, this.getView().getProjection());\n    return this.getPixelFromCoordinateInternal(viewCoordinate);\n  };\n  /**\n   * Get the pixel for a coordinate.  This takes a coordinate in the map view\n   * projection and returns the corresponding pixel.\n   * @param {import(\"./coordinate.js\").Coordinate} coordinate A map coordinate.\n   * @return {import(\"./pixel.js\").Pixel} A pixel position in the map viewport.\n   */\n\n\n  PluggableMap.prototype.getPixelFromCoordinateInternal = function (coordinate) {\n    var frameState = this.frameState_;\n\n    if (!frameState) {\n      return null;\n    } else {\n      return applyTransform(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));\n    }\n  };\n  /**\n   * Get the map renderer.\n   * @return {import(\"./renderer/Map.js\").default} Renderer\n   */\n\n\n  PluggableMap.prototype.getRenderer = function () {\n    return this.renderer_;\n  };\n  /**\n   * Get the size of this map.\n   * @return {import(\"./size.js\").Size|undefined} The size in pixels of the map in the DOM.\n   * @observable\n   * @api\n   */\n\n\n  PluggableMap.prototype.getSize = function () {\n    return this.get(MapProperty.SIZE);\n  };\n  /**\n   * Get the view associated with this map. A view manages properties such as\n   * center and resolution.\n   * @return {View} The view that controls this map.\n   * @observable\n   * @api\n   */\n\n\n  PluggableMap.prototype.getView = function () {\n    return this.get(MapProperty.VIEW);\n  };\n  /**\n   * Get the element that serves as the map viewport.\n   * @return {HTMLElement} Viewport.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getViewport = function () {\n    return this.viewport_;\n  };\n  /**\n   * Get the element that serves as the container for overlays.  Elements added to\n   * this container will let mousedown and touchstart events through to the map,\n   * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}\n   * events.\n   * @return {!HTMLElement} The map's overlay container.\n   */\n\n\n  PluggableMap.prototype.getOverlayContainer = function () {\n    return this.overlayContainer_;\n  };\n  /**\n   * Get the element that serves as a container for overlays that don't allow\n   * event propagation. Elements added to this container won't let mousedown and\n   * touchstart events through to the map, so clicks and gestures on an overlay\n   * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n   * @return {!HTMLElement} The map's overlay container that stops events.\n   */\n\n\n  PluggableMap.prototype.getOverlayContainerStopEvent = function () {\n    return this.overlayContainerStopEvent_;\n  };\n  /**\n   * @return {!Document} The document where the map is displayed.\n   */\n\n\n  PluggableMap.prototype.getOwnerDocument = function () {\n    var targetElement = this.getTargetElement();\n    return targetElement ? targetElement.ownerDocument : document;\n  };\n  /**\n   * @param {import(\"./Tile.js\").default} tile Tile.\n   * @param {string} tileSourceKey Tile source key.\n   * @param {import(\"./coordinate.js\").Coordinate} tileCenter Tile center.\n   * @param {number} tileResolution Tile resolution.\n   * @return {number} Tile priority.\n   */\n\n\n  PluggableMap.prototype.getTilePriority = function (tile, tileSourceKey, tileCenter, tileResolution) {\n    return getTilePriority(this.frameState_, tile, tileSourceKey, tileCenter, tileResolution);\n  };\n  /**\n   * @param {UIEvent} browserEvent Browser event.\n   * @param {string} [opt_type] Type.\n   */\n\n\n  PluggableMap.prototype.handleBrowserEvent = function (browserEvent, opt_type) {\n    var type = opt_type || browserEvent.type;\n    var mapBrowserEvent = new MapBrowserEvent(type, this, browserEvent);\n    this.handleMapBrowserEvent(mapBrowserEvent);\n  };\n  /**\n   * @param {MapBrowserEvent} mapBrowserEvent The event to handle.\n   */\n\n\n  PluggableMap.prototype.handleMapBrowserEvent = function (mapBrowserEvent) {\n    if (!this.frameState_) {\n      // With no view defined, we cannot translate pixels into geographical\n      // coordinates so interactions cannot be used.\n      return;\n    }\n\n    var originalEvent = mapBrowserEvent.originalEvent;\n    var eventType = originalEvent.type;\n\n    if (eventType === PointerEventType.POINTERDOWN || eventType === EventType.WHEEL || eventType === EventType.KEYDOWN) {\n      var doc = this.getOwnerDocument();\n      var rootNode = this.viewport_.getRootNode ? this.viewport_.getRootNode() : doc;\n      var target = originalEvent.target;\n\n      if ( // Abort if the target is a child of the container for elements whose events are not meant\n      // to be handled by map interactions.\n      this.overlayContainerStopEvent_.contains(target) || // Abort if the event target is a child of the container that is no longer in the page.\n      // It's possible for the target to no longer be in the page if it has been removed in an\n      // event listener, this might happen in a Control that recreates it's content based on\n      // user interaction either manually or via a render in something like https://reactjs.org/\n      !(rootNode === doc ? doc.documentElement : rootNode).contains(target)) {\n        return;\n      }\n    }\n\n    mapBrowserEvent.frameState = this.frameState_;\n\n    if (this.dispatchEvent(mapBrowserEvent) !== false) {\n      var interactionsArray = this.getInteractions().getArray().slice();\n\n      for (var i = interactionsArray.length - 1; i >= 0; i--) {\n        var interaction = interactionsArray[i];\n\n        if (interaction.getMap() !== this || !interaction.getActive() || !this.getTargetElement()) {\n          continue;\n        }\n\n        var cont = interaction.handleEvent(mapBrowserEvent);\n\n        if (!cont || mapBrowserEvent.propagationStopped) {\n          break;\n        }\n      }\n    }\n  };\n  /**\n   * @protected\n   */\n\n\n  PluggableMap.prototype.handlePostRender = function () {\n    var frameState = this.frameState_; // Manage the tile queue\n    // Image loads are expensive and a limited resource, so try to use them\n    // efficiently:\n    // * When the view is static we allow a large number of parallel tile loads\n    //   to complete the frame as quickly as possible.\n    // * When animating or interacting, image loads can cause janks, so we reduce\n    //   the maximum number of loads per frame and limit the number of parallel\n    //   tile loads to remain reactive to view changes and to reduce the chance of\n    //   loading tiles that will quickly disappear from view.\n\n    var tileQueue = this.tileQueue_;\n\n    if (!tileQueue.isEmpty()) {\n      var maxTotalLoading = this.maxTilesLoading_;\n      var maxNewLoads = maxTotalLoading;\n\n      if (frameState) {\n        var hints = frameState.viewHints;\n\n        if (hints[ViewHint.ANIMATING] || hints[ViewHint.INTERACTING]) {\n          var lowOnFrameBudget = Date.now() - frameState.time > 8;\n          maxTotalLoading = lowOnFrameBudget ? 0 : 8;\n          maxNewLoads = lowOnFrameBudget ? 0 : 2;\n        }\n      }\n\n      if (tileQueue.getTilesLoading() < maxTotalLoading) {\n        tileQueue.reprioritize(); // FIXME only call if view has changed\n\n        tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);\n      }\n    }\n\n    if (frameState && this.hasListener(RenderEventType.RENDERCOMPLETE) && !frameState.animate && !this.tileQueue_.getTilesLoading() && !this.getLoading()) {\n      this.renderer_.dispatchRenderEvent(RenderEventType.RENDERCOMPLETE, frameState);\n    }\n\n    var postRenderFunctions = this.postRenderFunctions_;\n\n    for (var i = 0, ii = postRenderFunctions.length; i < ii; ++i) {\n      postRenderFunctions[i](this, frameState);\n    }\n\n    postRenderFunctions.length = 0;\n  };\n  /**\n   * @private\n   */\n\n\n  PluggableMap.prototype.handleSizeChanged_ = function () {\n    if (this.getView() && !this.getView().getAnimating()) {\n      this.getView().resolveConstraints(0);\n    }\n\n    this.render();\n  };\n  /**\n   * @private\n   */\n\n\n  PluggableMap.prototype.handleTargetChanged_ = function () {\n    // target may be undefined, null, a string or an Element.\n    // If it's a string we convert it to an Element before proceeding.\n    // If it's not now an Element we remove the viewport from the DOM.\n    // If it's an Element we append the viewport element to it.\n    var targetElement;\n\n    if (this.getTarget()) {\n      targetElement = this.getTargetElement();\n    }\n\n    if (this.mapBrowserEventHandler_) {\n      for (var i = 0, ii = this.keyHandlerKeys_.length; i < ii; ++i) {\n        unlistenByKey(this.keyHandlerKeys_[i]);\n      }\n\n      this.keyHandlerKeys_ = null;\n      this.viewport_.removeEventListener(EventType.CONTEXTMENU, this.boundHandleBrowserEvent_);\n      this.viewport_.removeEventListener(EventType.WHEEL, this.boundHandleBrowserEvent_);\n\n      if (this.handleResize_ !== undefined) {\n        removeEventListener(EventType.RESIZE, this.handleResize_, false);\n        this.handleResize_ = undefined;\n      }\n\n      this.mapBrowserEventHandler_.dispose();\n      this.mapBrowserEventHandler_ = null;\n      removeNode(this.viewport_);\n    }\n\n    if (!targetElement) {\n      if (this.renderer_) {\n        clearTimeout(this.postRenderTimeoutHandle_);\n        this.postRenderTimeoutHandle_ = undefined;\n        this.postRenderFunctions_.length = 0;\n        this.renderer_.dispose();\n        this.renderer_ = null;\n      }\n\n      if (this.animationDelayKey_) {\n        cancelAnimationFrame(this.animationDelayKey_);\n        this.animationDelayKey_ = undefined;\n      }\n    } else {\n      targetElement.appendChild(this.viewport_);\n\n      if (!this.renderer_) {\n        this.renderer_ = this.createRenderer();\n      }\n\n      this.mapBrowserEventHandler_ = new MapBrowserEventHandler(this, this.moveTolerance_);\n\n      for (var key in MapBrowserEventType) {\n        this.mapBrowserEventHandler_.addEventListener(MapBrowserEventType[key], this.handleMapBrowserEvent.bind(this));\n      }\n\n      this.viewport_.addEventListener(EventType.CONTEXTMENU, this.boundHandleBrowserEvent_, false);\n      this.viewport_.addEventListener(EventType.WHEEL, this.boundHandleBrowserEvent_, PASSIVE_EVENT_LISTENERS ? {\n        passive: false\n      } : false);\n      var keyboardEventTarget = !this.keyboardEventTarget_ ? targetElement : this.keyboardEventTarget_;\n      this.keyHandlerKeys_ = [listen(keyboardEventTarget, EventType.KEYDOWN, this.handleBrowserEvent, this), listen(keyboardEventTarget, EventType.KEYPRESS, this.handleBrowserEvent, this)];\n\n      if (!this.handleResize_) {\n        this.handleResize_ = this.updateSize.bind(this);\n        window.addEventListener(EventType.RESIZE, this.handleResize_, false);\n      }\n    }\n\n    this.updateSize(); // updateSize calls setSize, so no need to call this.render\n    // ourselves here.\n  };\n  /**\n   * @private\n   */\n\n\n  PluggableMap.prototype.handleTileChange_ = function () {\n    this.render();\n  };\n  /**\n   * @private\n   */\n\n\n  PluggableMap.prototype.handleViewPropertyChanged_ = function () {\n    this.render();\n  };\n  /**\n   * @private\n   */\n\n\n  PluggableMap.prototype.handleViewChanged_ = function () {\n    if (this.viewPropertyListenerKey_) {\n      unlistenByKey(this.viewPropertyListenerKey_);\n      this.viewPropertyListenerKey_ = null;\n    }\n\n    if (this.viewChangeListenerKey_) {\n      unlistenByKey(this.viewChangeListenerKey_);\n      this.viewChangeListenerKey_ = null;\n    }\n\n    var view = this.getView();\n\n    if (view) {\n      this.updateViewportSize_();\n      this.viewPropertyListenerKey_ = listen(view, ObjectEventType.PROPERTYCHANGE, this.handleViewPropertyChanged_, this);\n      this.viewChangeListenerKey_ = listen(view, EventType.CHANGE, this.handleViewPropertyChanged_, this);\n      view.resolveConstraints(0);\n    }\n\n    this.render();\n  };\n  /**\n   * @private\n   */\n\n\n  PluggableMap.prototype.handleLayerGroupChanged_ = function () {\n    if (this.layerGroupPropertyListenerKeys_) {\n      this.layerGroupPropertyListenerKeys_.forEach(unlistenByKey);\n      this.layerGroupPropertyListenerKeys_ = null;\n    }\n\n    var layerGroup = this.getLayerGroup();\n\n    if (layerGroup) {\n      this.layerGroupPropertyListenerKeys_ = [listen(layerGroup, ObjectEventType.PROPERTYCHANGE, this.render, this), listen(layerGroup, EventType.CHANGE, this.render, this)];\n    }\n\n    this.render();\n  };\n  /**\n   * @return {boolean} Is rendered.\n   */\n\n\n  PluggableMap.prototype.isRendered = function () {\n    return !!this.frameState_;\n  };\n  /**\n   * Requests an immediate render in a synchronous manner.\n   * @api\n   */\n\n\n  PluggableMap.prototype.renderSync = function () {\n    if (this.animationDelayKey_) {\n      cancelAnimationFrame(this.animationDelayKey_);\n    }\n\n    this.animationDelay_();\n  };\n  /**\n   * Redraws all text after new fonts have loaded\n   */\n\n\n  PluggableMap.prototype.redrawText = function () {\n    var layerStates = this.getLayerGroup().getLayerStatesArray();\n\n    for (var i = 0, ii = layerStates.length; i < ii; ++i) {\n      var layer = layerStates[i].layer;\n\n      if (layer.hasRenderer()) {\n        layer.getRenderer().handleFontsChanged();\n      }\n    }\n  };\n  /**\n   * Request a map rendering (at the next animation frame).\n   * @api\n   */\n\n\n  PluggableMap.prototype.render = function () {\n    if (this.renderer_ && this.animationDelayKey_ === undefined) {\n      this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);\n    }\n  };\n  /**\n   * Remove the given control from the map.\n   * @param {import(\"./control/Control.js\").default} control Control.\n   * @return {import(\"./control/Control.js\").default|undefined} The removed control (or undefined\n   *     if the control was not found).\n   * @api\n   */\n\n\n  PluggableMap.prototype.removeControl = function (control) {\n    return this.getControls().remove(control);\n  };\n  /**\n   * Remove the given interaction from the map.\n   * @param {import(\"./interaction/Interaction.js\").default} interaction Interaction to remove.\n   * @return {import(\"./interaction/Interaction.js\").default|undefined} The removed interaction (or\n   *     undefined if the interaction was not found).\n   * @api\n   */\n\n\n  PluggableMap.prototype.removeInteraction = function (interaction) {\n    return this.getInteractions().remove(interaction);\n  };\n  /**\n   * Removes the given layer from the map.\n   * @param {import(\"./layer/Base.js\").default} layer Layer.\n   * @return {import(\"./layer/Base.js\").default|undefined} The removed layer (or undefined if the\n   *     layer was not found).\n   * @api\n   */\n\n\n  PluggableMap.prototype.removeLayer = function (layer) {\n    var layers = this.getLayerGroup().getLayers();\n    return layers.remove(layer);\n  };\n  /**\n   * Remove the given overlay from the map.\n   * @param {import(\"./Overlay.js\").default} overlay Overlay.\n   * @return {import(\"./Overlay.js\").default|undefined} The removed overlay (or undefined\n   *     if the overlay was not found).\n   * @api\n   */\n\n\n  PluggableMap.prototype.removeOverlay = function (overlay) {\n    return this.getOverlays().remove(overlay);\n  };\n  /**\n   * @param {number} time Time.\n   * @private\n   */\n\n\n  PluggableMap.prototype.renderFrame_ = function (time) {\n    var _this = this;\n\n    var size = this.getSize();\n    var view = this.getView();\n    var previousFrameState = this.frameState_;\n    /** @type {?FrameState} */\n\n    var frameState = null;\n\n    if (size !== undefined && hasArea(size) && view && view.isDef()) {\n      var viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : undefined);\n      var viewState = view.getState();\n      frameState = {\n        animate: false,\n        coordinateToPixelTransform: this.coordinateToPixelTransform_,\n        declutterTree: null,\n        extent: getForViewAndSize(viewState.center, viewState.resolution, viewState.rotation, size),\n        index: this.frameIndex_++,\n        layerIndex: 0,\n        layerStatesArray: this.getLayerGroup().getLayerStatesArray(),\n        pixelRatio: this.pixelRatio_,\n        pixelToCoordinateTransform: this.pixelToCoordinateTransform_,\n        postRenderFunctions: [],\n        size: size,\n        tileQueue: this.tileQueue_,\n        time: time,\n        usedTiles: {},\n        viewState: viewState,\n        viewHints: viewHints,\n        wantedTiles: {}\n      };\n    }\n\n    this.frameState_ = frameState;\n    this.renderer_.renderFrame(frameState);\n\n    if (frameState) {\n      if (frameState.animate) {\n        this.render();\n      }\n\n      Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);\n\n      if (previousFrameState) {\n        var moveStart = !this.previousExtent_ || !isEmpty(this.previousExtent_) && !equals(frameState.extent, this.previousExtent_);\n\n        if (moveStart) {\n          this.dispatchEvent(new MapEvent(MapEventType.MOVESTART, this, previousFrameState));\n          this.previousExtent_ = createOrUpdateEmpty(this.previousExtent_);\n        }\n      }\n\n      var idle = this.previousExtent_ && !frameState.viewHints[ViewHint.ANIMATING] && !frameState.viewHints[ViewHint.INTERACTING] && !equals(frameState.extent, this.previousExtent_);\n\n      if (idle) {\n        this.dispatchEvent(new MapEvent(MapEventType.MOVEEND, this, frameState));\n        clone(frameState.extent, this.previousExtent_);\n      }\n    }\n\n    this.dispatchEvent(new MapEvent(MapEventType.POSTRENDER, this, frameState));\n\n    if (!this.postRenderTimeoutHandle_) {\n      this.postRenderTimeoutHandle_ = setTimeout(function () {\n        _this.postRenderTimeoutHandle_ = undefined;\n\n        _this.handlePostRender();\n      }, 0);\n    }\n  };\n  /**\n   * Sets the layergroup of this map.\n   * @param {LayerGroup} layerGroup A layer group containing the layers in this map.\n   * @observable\n   * @api\n   */\n\n\n  PluggableMap.prototype.setLayerGroup = function (layerGroup) {\n    this.set(MapProperty.LAYERGROUP, layerGroup);\n  };\n  /**\n   * Set the size of this map.\n   * @param {import(\"./size.js\").Size|undefined} size The size in pixels of the map in the DOM.\n   * @observable\n   * @api\n   */\n\n\n  PluggableMap.prototype.setSize = function (size) {\n    this.set(MapProperty.SIZE, size);\n  };\n  /**\n   * Set the target element to render this map into.\n   * @param {HTMLElement|string} [target] The Element or id of the Element\n   *     that the map is rendered in.\n   * @observable\n   * @api\n   */\n\n\n  PluggableMap.prototype.setTarget = function (target) {\n    this.set(MapProperty.TARGET, target);\n  };\n  /**\n   * Set the view for this map.\n   * @param {View} view The view that controls this map.\n   * @observable\n   * @api\n   */\n\n\n  PluggableMap.prototype.setView = function (view) {\n    this.set(MapProperty.VIEW, view);\n  };\n  /**\n   * Force a recalculation of the map viewport size.  This should be called when\n   * third-party code changes the size of the map viewport.\n   * @api\n   */\n\n\n  PluggableMap.prototype.updateSize = function () {\n    var targetElement = this.getTargetElement();\n    var size = undefined;\n\n    if (targetElement) {\n      var computedStyle = getComputedStyle(targetElement);\n      var width = targetElement.offsetWidth - parseFloat(computedStyle['borderLeftWidth']) - parseFloat(computedStyle['paddingLeft']) - parseFloat(computedStyle['paddingRight']) - parseFloat(computedStyle['borderRightWidth']);\n      var height = targetElement.offsetHeight - parseFloat(computedStyle['borderTopWidth']) - parseFloat(computedStyle['paddingTop']) - parseFloat(computedStyle['paddingBottom']) - parseFloat(computedStyle['borderBottomWidth']);\n\n      if (!isNaN(width) && !isNaN(height)) {\n        size = [width, height];\n\n        if (!hasArea(size)) {\n          // eslint-disable-next-line\n          console.warn(\"No map visible because the map container's width or height are 0.\");\n        }\n      }\n    }\n\n    this.setSize(size);\n    this.updateViewportSize_();\n  };\n  /**\n   * Recomputes the viewport size and save it on the view object (if any)\n   * @private\n   */\n\n\n  PluggableMap.prototype.updateViewportSize_ = function () {\n    var view = this.getView();\n\n    if (view) {\n      var size = undefined;\n      var computedStyle = getComputedStyle(this.viewport_);\n\n      if (computedStyle.width && computedStyle.height) {\n        size = [parseInt(computedStyle.width, 10), parseInt(computedStyle.height, 10)];\n      }\n\n      view.setViewportSize(size);\n    }\n  };\n\n  return PluggableMap;\n}(BaseObject);\n/**\n * @param {MapOptions} options Map options.\n * @return {MapOptionsInternal} Internal map options.\n */\n\n\nfunction createOptionsInternal(options) {\n  /**\n   * @type {HTMLElement|Document}\n   */\n  var keyboardEventTarget = null;\n\n  if (options.keyboardEventTarget !== undefined) {\n    keyboardEventTarget = typeof options.keyboardEventTarget === 'string' ? document.getElementById(options.keyboardEventTarget) : options.keyboardEventTarget;\n  }\n  /**\n   * @type {Object<string, *>}\n   */\n\n\n  var values = {};\n  var layerGroup = options.layers && typeof\n  /** @type {?} */\n  options.layers.getLayers === 'function' ? options.layers : new LayerGroup({\n    layers: options.layers\n  });\n  values[MapProperty.LAYERGROUP] = layerGroup;\n  values[MapProperty.TARGET] = options.target;\n  values[MapProperty.VIEW] = options.view !== undefined ? options.view : new View();\n  var controls;\n\n  if (options.controls !== undefined) {\n    if (Array.isArray(options.controls)) {\n      controls = new Collection(options.controls.slice());\n    } else {\n      assert(typeof\n      /** @type {?} */\n      options.controls.getArray === 'function', 47); // Expected `controls` to be an array or an `import(\"./Collection.js\").Collection`\n\n      controls = options.controls;\n    }\n  }\n\n  var interactions;\n\n  if (options.interactions !== undefined) {\n    if (Array.isArray(options.interactions)) {\n      interactions = new Collection(options.interactions.slice());\n    } else {\n      assert(typeof\n      /** @type {?} */\n      options.interactions.getArray === 'function', 48); // Expected `interactions` to be an array or an `import(\"./Collection.js\").Collection`\n\n      interactions = options.interactions;\n    }\n  }\n\n  var overlays;\n\n  if (options.overlays !== undefined) {\n    if (Array.isArray(options.overlays)) {\n      overlays = new Collection(options.overlays.slice());\n    } else {\n      assert(typeof\n      /** @type {?} */\n      options.overlays.getArray === 'function', 49); // Expected `overlays` to be an array or an `import(\"./Collection.js\").Collection`\n\n      overlays = options.overlays;\n    }\n  } else {\n    overlays = new Collection();\n  }\n\n  return {\n    controls: controls,\n    interactions: interactions,\n    keyboardEventTarget: keyboardEventTarget,\n    overlays: overlays,\n    values: values\n  };\n}\n\nexport default PluggableMap;","map":{"version":3,"sources":["src/PluggableMap.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/PluggableMap\n */\nimport BaseObject from './Object.js';\nimport Collection from './Collection.js';\nimport CollectionEventType from './CollectionEventType.js';\nimport EventType from './events/EventType.js';\nimport LayerGroup from './layer/Group.js';\nimport MapBrowserEvent from './MapBrowserEvent.js';\nimport MapBrowserEventHandler from './MapBrowserEventHandler.js';\nimport MapBrowserEventType from './MapBrowserEventType.js';\nimport MapEvent from './MapEvent.js';\nimport MapEventType from './MapEventType.js';\nimport MapProperty from './MapProperty.js';\nimport ObjectEventType from './ObjectEventType.js';\nimport PointerEventType from './pointer/EventType.js';\nimport RenderEventType from './render/EventType.js';\nimport TileQueue, { getTilePriority } from './TileQueue.js';\nimport View from './View.js';\nimport ViewHint from './ViewHint.js';\nimport { DEVICE_PIXEL_RATIO, PASSIVE_EVENT_LISTENERS } from './has.js';\nimport { TRUE } from './functions.js';\nimport { apply as applyTransform, create as createTransform, } from './transform.js';\nimport { assert } from './asserts.js';\nimport { clone, createOrUpdateEmpty, equals, getForViewAndSize, isEmpty, } from './extent.js';\nimport { fromUserCoordinate, toUserCoordinate } from './proj.js';\nimport { hasArea } from './size.js';\nimport { listen, unlistenByKey } from './events.js';\nimport { removeNode } from './dom.js';\n/**\n * State of the current frame. Only `pixelRatio`, `time` and `viewState` should\n * be used in applications.\n * @typedef {Object} FrameState\n * @property {number} pixelRatio The pixel ratio of the frame.\n * @property {number} time The time when rendering of the frame was requested.\n * @property {import(\"./View.js\").State} viewState The state of the current view.\n * @property {boolean} animate Animate.\n * @property {import(\"./transform.js\").Transform} coordinateToPixelTransform CoordinateToPixelTransform.\n * @property {import(\"rbush\").default} declutterTree DeclutterTree.\n * @property {null|import(\"./extent.js\").Extent} extent Extent.\n * @property {number} index Index.\n * @property {Array<import(\"./layer/Layer.js\").State>} layerStatesArray LayerStatesArray.\n * @property {number} layerIndex LayerIndex.\n * @property {import(\"./transform.js\").Transform} pixelToCoordinateTransform PixelToCoordinateTransform.\n * @property {Array<PostRenderFunction>} postRenderFunctions PostRenderFunctions.\n * @property {import(\"./size.js\").Size} size Size.\n * @property {TileQueue} tileQueue TileQueue.\n * @property {!Object<string, Object<string, boolean>>} usedTiles UsedTiles.\n * @property {Array<number>} viewHints ViewHints.\n * @property {!Object<string, Object<string, boolean>>} wantedTiles WantedTiles.\n */\n/**\n * @typedef {function(PluggableMap, ?FrameState): any} PostRenderFunction\n */\n/**\n * @typedef {Object} AtPixelOptions\n * @property {undefined|function(import(\"./layer/Layer.js\").default): boolean} [layerFilter] Layer filter\n * function. The filter function will receive one argument, the\n * {@link module:ol/layer/Layer layer-candidate} and it should return a boolean value.\n * Only layers which are visible and for which this function returns `true`\n * will be tested for features. By default, all visible layers will be tested.\n * @property {number} [hitTolerance=0] Hit-detection tolerance in css pixels. Pixels\n * inside the radius around the given position will be checked for features.\n * @property {boolean} [checkWrapped=true] Check-Wrapped Will check for for wrapped geometries inside the range of\n *   +/- 1 world width. Works only if a projection is used that can be wrapped.\n */\n/**\n * @typedef {Object} MapOptionsInternal\n * @property {Collection<import(\"./control/Control.js\").default>} [controls] Controls.\n * @property {Collection<import(\"./interaction/Interaction.js\").default>} [interactions] Interactions.\n * @property {HTMLElement|Document} keyboardEventTarget KeyboardEventTarget.\n * @property {Collection<import(\"./Overlay.js\").default>} overlays Overlays.\n * @property {Object<string, *>} values Values.\n */\n/**\n * @typedef {import(\"./ObjectEventType\").Types|'change:layergroup'|'change:size'|'change:target'|'change:view'} MapObjectEventTypes\n */\n/***\n * @template Return\n * @typedef {import(\"./Observable\").OnSignature<import(\"./Observable\").EventTypes, import(\"./events/Event.js\").default, Return> &\n *    import(\"./Observable\").OnSignature<MapObjectEventTypes, import(\"./Object\").ObjectEvent, Return> &\n *    import(\"./Observable\").OnSignature<import(\"./MapBrowserEventType\").Types, import(\"./MapBrowserEvent\").default, Return> &\n *    import(\"./Observable\").OnSignature<import(\"./MapEventType\").Types, import(\"./MapEvent\").default, Return> &\n *    import(\"./Observable\").OnSignature<import(\"./render/EventType\").MapRenderEventTypes, import(\"./render/Event\").default, Return> &\n *    import(\"./Observable\").CombinedOnSignature<import(\"./Observable\").EventTypes|MapObjectEventTypes|\n *      import(\"./MapBrowserEventType\").Types|import(\"./MapEventType\").Types|\n *      import(\"./render/EventType\").MapRenderEventTypes, Return>} PluggableMapOnSignature\n */\n/**\n * Object literal with config options for the map.\n * @typedef {Object} MapOptions\n * @property {Collection<import(\"./control/Control.js\").default>|Array<import(\"./control/Control.js\").default>} [controls]\n * Controls initially added to the map. If not specified,\n * {@link module:ol/control.defaults} is used.\n * @property {number} [pixelRatio=window.devicePixelRatio] The ratio between\n * physical pixels and device-independent pixels (dips) on the device.\n * @property {Collection<import(\"./interaction/Interaction.js\").default>|Array<import(\"./interaction/Interaction.js\").default>} [interactions]\n * Interactions that are initially added to the map. If not specified,\n * {@link module:ol/interaction.defaults} is used.\n * @property {HTMLElement|Document|string} [keyboardEventTarget] The element to\n * listen to keyboard events on. This determines when the `KeyboardPan` and\n * `KeyboardZoom` interactions trigger. For example, if this option is set to\n * `document` the keyboard interactions will always trigger. If this option is\n * not specified, the element the library listens to keyboard events on is the\n * map target (i.e. the user-provided div for the map). If this is not\n * `document`, the target element needs to be focused for key events to be\n * emitted, requiring that the target element has a `tabindex` attribute.\n * @property {Array<import(\"./layer/Base.js\").default>|Collection<import(\"./layer/Base.js\").default>|LayerGroup} [layers]\n * Layers. If this is not defined, a map with no layers will be rendered. Note\n * that layers are rendered in the order supplied, so if you want, for example,\n * a vector layer to appear on top of a tile layer, it must come after the tile\n * layer.\n * @property {number} [maxTilesLoading=16] Maximum number tiles to load\n * simultaneously.\n * @property {number} [moveTolerance=1] The minimum distance in pixels the\n * cursor must move to be detected as a map move event instead of a click.\n * Increasing this value can make it easier to click on the map.\n * @property {Collection<import(\"./Overlay.js\").default>|Array<import(\"./Overlay.js\").default>} [overlays]\n * Overlays initially added to the map. By default, no overlays are added.\n * @property {HTMLElement|string} [target] The container for the map, either the\n * element itself or the `id` of the element. If not specified at construction\n * time, {@link module:ol/Map~Map#setTarget} must be called for the map to be\n * rendered. If passed by element, the container can be in a secondary document.\n * @property {View} [view] The map's view.  No layer sources will be\n * fetched unless this is specified at construction time or through\n * {@link module:ol/Map~Map#setView}.\n */\n/**\n * @api\n */\nvar PluggableMap = /** @class */ (function (_super) {\n    __extends(PluggableMap, _super);\n    /**\n     * @param {MapOptions} options Map options.\n     */\n    function PluggableMap(options) {\n        var _this = _super.call(this) || this;\n        /***\n         * @type {PluggableMapOnSignature<import(\"./Observable.js\").OnReturn>}\n         */\n        _this.on;\n        /***\n         * @type {PluggableMapOnSignature<import(\"./Observable.js\").OnReturn>}\n         */\n        _this.once;\n        /***\n         * @type {PluggableMapOnSignature<void>}\n         */\n        _this.un;\n        var optionsInternal = createOptionsInternal(options);\n        /** @private */\n        _this.boundHandleBrowserEvent_ = _this.handleBrowserEvent.bind(_this);\n        /**\n         * @type {number}\n         * @private\n         */\n        _this.maxTilesLoading_ =\n            options.maxTilesLoading !== undefined ? options.maxTilesLoading : 16;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.pixelRatio_ =\n            options.pixelRatio !== undefined\n                ? options.pixelRatio\n                : DEVICE_PIXEL_RATIO;\n        /**\n         * @private\n         * @type {*}\n         */\n        _this.postRenderTimeoutHandle_;\n        /**\n         * @private\n         * @type {number|undefined}\n         */\n        _this.animationDelayKey_;\n        /**\n         * @private\n         */\n        _this.animationDelay_ = /** @this {PluggableMap} */ function () {\n            this.animationDelayKey_ = undefined;\n            this.renderFrame_(Date.now());\n        }.bind(_this);\n        /**\n         * @private\n         * @type {import(\"./transform.js\").Transform}\n         */\n        _this.coordinateToPixelTransform_ = createTransform();\n        /**\n         * @private\n         * @type {import(\"./transform.js\").Transform}\n         */\n        _this.pixelToCoordinateTransform_ = createTransform();\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.frameIndex_ = 0;\n        /**\n         * @private\n         * @type {?FrameState}\n         */\n        _this.frameState_ = null;\n        /**\n         * The extent at the previous 'moveend' event.\n         * @private\n         * @type {import(\"./extent.js\").Extent}\n         */\n        _this.previousExtent_ = null;\n        /**\n         * @private\n         * @type {?import(\"./events.js\").EventsKey}\n         */\n        _this.viewPropertyListenerKey_ = null;\n        /**\n         * @private\n         * @type {?import(\"./events.js\").EventsKey}\n         */\n        _this.viewChangeListenerKey_ = null;\n        /**\n         * @private\n         * @type {?Array<import(\"./events.js\").EventsKey>}\n         */\n        _this.layerGroupPropertyListenerKeys_ = null;\n        /**\n         * @private\n         * @type {!HTMLElement}\n         */\n        _this.viewport_ = document.createElement('div');\n        _this.viewport_.className =\n            'ol-viewport' + ('ontouchstart' in window ? ' ol-touch' : '');\n        _this.viewport_.style.position = 'relative';\n        _this.viewport_.style.overflow = 'hidden';\n        _this.viewport_.style.width = '100%';\n        _this.viewport_.style.height = '100%';\n        /**\n         * @private\n         * @type {!HTMLElement}\n         */\n        _this.overlayContainer_ = document.createElement('div');\n        _this.overlayContainer_.style.position = 'absolute';\n        _this.overlayContainer_.style.zIndex = '0';\n        _this.overlayContainer_.style.width = '100%';\n        _this.overlayContainer_.style.height = '100%';\n        _this.overlayContainer_.style.pointerEvents = 'none';\n        _this.overlayContainer_.className = 'ol-overlaycontainer';\n        _this.viewport_.appendChild(_this.overlayContainer_);\n        /**\n         * @private\n         * @type {!HTMLElement}\n         */\n        _this.overlayContainerStopEvent_ = document.createElement('div');\n        _this.overlayContainerStopEvent_.style.position = 'absolute';\n        _this.overlayContainerStopEvent_.style.zIndex = '0';\n        _this.overlayContainerStopEvent_.style.width = '100%';\n        _this.overlayContainerStopEvent_.style.height = '100%';\n        _this.overlayContainerStopEvent_.style.pointerEvents = 'none';\n        _this.overlayContainerStopEvent_.className = 'ol-overlaycontainer-stopevent';\n        _this.viewport_.appendChild(_this.overlayContainerStopEvent_);\n        /**\n         * @private\n         * @type {MapBrowserEventHandler}\n         */\n        _this.mapBrowserEventHandler_ = null;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.moveTolerance_ = options.moveTolerance;\n        /**\n         * @private\n         * @type {HTMLElement|Document}\n         */\n        _this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;\n        /**\n         * @private\n         * @type {?Array<import(\"./events.js\").EventsKey>}\n         */\n        _this.keyHandlerKeys_ = null;\n        /**\n         * @type {Collection<import(\"./control/Control.js\").default>}\n         * @protected\n         */\n        _this.controls = optionsInternal.controls || new Collection();\n        /**\n         * @type {Collection<import(\"./interaction/Interaction.js\").default>}\n         * @protected\n         */\n        _this.interactions = optionsInternal.interactions || new Collection();\n        /**\n         * @type {Collection<import(\"./Overlay.js\").default>}\n         * @private\n         */\n        _this.overlays_ = optionsInternal.overlays;\n        /**\n         * A lookup of overlays by id.\n         * @private\n         * @type {Object<string, import(\"./Overlay.js\").default>}\n         */\n        _this.overlayIdIndex_ = {};\n        /**\n         * @type {import(\"./renderer/Map.js\").default}\n         * @private\n         */\n        _this.renderer_ = null;\n        /**\n         * @type {undefined|function(Event): void}\n         * @private\n         */\n        _this.handleResize_;\n        /**\n         * @private\n         * @type {!Array<PostRenderFunction>}\n         */\n        _this.postRenderFunctions_ = [];\n        /**\n         * @private\n         * @type {TileQueue}\n         */\n        _this.tileQueue_ = new TileQueue(_this.getTilePriority.bind(_this), _this.handleTileChange_.bind(_this));\n        _this.addChangeListener(MapProperty.LAYERGROUP, _this.handleLayerGroupChanged_);\n        _this.addChangeListener(MapProperty.VIEW, _this.handleViewChanged_);\n        _this.addChangeListener(MapProperty.SIZE, _this.handleSizeChanged_);\n        _this.addChangeListener(MapProperty.TARGET, _this.handleTargetChanged_);\n        // setProperties will trigger the rendering of the map if the map\n        // is \"defined\" already.\n        _this.setProperties(optionsInternal.values);\n        _this.controls.forEach(\n        /**\n         * @param {import(\"./control/Control.js\").default} control Control.\n         * @this {PluggableMap}\n         */\n        function (control) {\n            control.setMap(this);\n        }.bind(_this));\n        _this.controls.addEventListener(CollectionEventType.ADD, \n        /**\n         * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\n         */\n        function (event) {\n            event.element.setMap(this);\n        }.bind(_this));\n        _this.controls.addEventListener(CollectionEventType.REMOVE, \n        /**\n         * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\n         */\n        function (event) {\n            event.element.setMap(null);\n        }.bind(_this));\n        _this.interactions.forEach(\n        /**\n         * @param {import(\"./interaction/Interaction.js\").default} interaction Interaction.\n         * @this {PluggableMap}\n         */\n        function (interaction) {\n            interaction.setMap(this);\n        }.bind(_this));\n        _this.interactions.addEventListener(CollectionEventType.ADD, \n        /**\n         * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\n         */\n        function (event) {\n            event.element.setMap(this);\n        }.bind(_this));\n        _this.interactions.addEventListener(CollectionEventType.REMOVE, \n        /**\n         * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\n         */\n        function (event) {\n            event.element.setMap(null);\n        }.bind(_this));\n        _this.overlays_.forEach(_this.addOverlayInternal_.bind(_this));\n        _this.overlays_.addEventListener(CollectionEventType.ADD, \n        /**\n         * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\n         */\n        function (event) {\n            this.addOverlayInternal_(\n            /** @type {import(\"./Overlay.js\").default} */ (event.element));\n        }.bind(_this));\n        _this.overlays_.addEventListener(CollectionEventType.REMOVE, \n        /**\n         * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\n         */\n        function (event) {\n            var overlay = /** @type {import(\"./Overlay.js\").default} */ (event.element);\n            var id = overlay.getId();\n            if (id !== undefined) {\n                delete this.overlayIdIndex_[id.toString()];\n            }\n            event.element.setMap(null);\n        }.bind(_this));\n        return _this;\n    }\n    /**\n     * @abstract\n     * @return {import(\"./renderer/Map.js\").default} The map renderer\n     */\n    PluggableMap.prototype.createRenderer = function () {\n        throw new Error('Use a map type that has a createRenderer method');\n    };\n    /**\n     * Add the given control to the map.\n     * @param {import(\"./control/Control.js\").default} control Control.\n     * @api\n     */\n    PluggableMap.prototype.addControl = function (control) {\n        this.getControls().push(control);\n    };\n    /**\n     * Add the given interaction to the map. If you want to add an interaction\n     * at another point of the collection use `getInteraction()` and the methods\n     * available on {@link module:ol/Collection~Collection}. This can be used to\n     * stop the event propagation from the handleEvent function. The interactions\n     * get to handle the events in the reverse order of this collection.\n     * @param {import(\"./interaction/Interaction.js\").default} interaction Interaction to add.\n     * @api\n     */\n    PluggableMap.prototype.addInteraction = function (interaction) {\n        this.getInteractions().push(interaction);\n    };\n    /**\n     * Adds the given layer to the top of this map. If you want to add a layer\n     * elsewhere in the stack, use `getLayers()` and the methods available on\n     * {@link module:ol/Collection~Collection}.\n     * @param {import(\"./layer/Base.js\").default} layer Layer.\n     * @api\n     */\n    PluggableMap.prototype.addLayer = function (layer) {\n        var layers = this.getLayerGroup().getLayers();\n        layers.push(layer);\n    };\n    /**\n     * Add the given overlay to the map.\n     * @param {import(\"./Overlay.js\").default} overlay Overlay.\n     * @api\n     */\n    PluggableMap.prototype.addOverlay = function (overlay) {\n        this.getOverlays().push(overlay);\n    };\n    /**\n     * This deals with map's overlay collection changes.\n     * @param {import(\"./Overlay.js\").default} overlay Overlay.\n     * @private\n     */\n    PluggableMap.prototype.addOverlayInternal_ = function (overlay) {\n        var id = overlay.getId();\n        if (id !== undefined) {\n            this.overlayIdIndex_[id.toString()] = overlay;\n        }\n        overlay.setMap(this);\n    };\n    /**\n     *\n     * Clean up.\n     */\n    PluggableMap.prototype.disposeInternal = function () {\n        this.setTarget(null);\n        _super.prototype.disposeInternal.call(this);\n    };\n    /**\n     * Detect features that intersect a pixel on the viewport, and execute a\n     * callback with each intersecting feature. Layers included in the detection can\n     * be configured through the `layerFilter` option in `opt_options`.\n     * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\n     * @param {function(import(\"./Feature.js\").FeatureLike, import(\"./layer/Layer.js\").default, import(\"./geom/SimpleGeometry.js\").default): T} callback Feature callback. The callback will be\n     *     called with two arguments. The first argument is one\n     *     {@link module:ol/Feature feature} or\n     *     {@link module:ol/render/Feature render feature} at the pixel, the second is\n     *     the {@link module:ol/layer/Layer layer} of the feature and will be null for\n     *     unmanaged layers. To stop detection, callback functions can return a\n     *     truthy value.\n     * @param {AtPixelOptions} [opt_options] Optional options.\n     * @return {T|undefined} Callback result, i.e. the return value of last\n     * callback execution, or the first truthy callback return value.\n     * @template S,T\n     * @api\n     */\n    PluggableMap.prototype.forEachFeatureAtPixel = function (pixel, callback, opt_options) {\n        if (!this.frameState_) {\n            return;\n        }\n        var coordinate = this.getCoordinateFromPixelInternal(pixel);\n        opt_options = opt_options !== undefined ? opt_options : {};\n        var hitTolerance = opt_options.hitTolerance !== undefined ? opt_options.hitTolerance : 0;\n        var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : TRUE;\n        var checkWrapped = opt_options.checkWrapped !== false;\n        return this.renderer_.forEachFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, callback, null, layerFilter, null);\n    };\n    /**\n     * Get all features that intersect a pixel on the viewport.\n     * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\n     * @param {AtPixelOptions} [opt_options] Optional options.\n     * @return {Array<import(\"./Feature.js\").FeatureLike>} The detected features or\n     * an empty array if none were found.\n     * @api\n     */\n    PluggableMap.prototype.getFeaturesAtPixel = function (pixel, opt_options) {\n        var features = [];\n        this.forEachFeatureAtPixel(pixel, function (feature) {\n            features.push(feature);\n        }, opt_options);\n        return features;\n    };\n    /**\n     * Detect layers that have a color value at a pixel on the viewport, and\n     * execute a callback with each matching layer. Layers included in the\n     * detection can be configured through `opt_layerFilter`.\n     *\n     * Note: this may give false positives unless the map layers have had different `className`\n     * properties assigned to them.\n     *\n     * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\n     * @param {function(this: S, import(\"./layer/Layer.js\").default, (Uint8ClampedArray|Uint8Array)): T} callback\n     *     Layer callback. This callback will receive two arguments: first is the\n     *     {@link module:ol/layer/Layer layer}, second argument is an array representing\n     *     [R, G, B, A] pixel values (0 - 255) and will be `null` for layer types\n     *     that do not currently support this argument. To stop detection, callback\n     *     functions can return a truthy value.\n     * @param {AtPixelOptions} [opt_options] Configuration options.\n     * @return {T|undefined} Callback result, i.e. the return value of last\n     * callback execution, or the first truthy callback return value.\n     * @template S,T\n     * @api\n     */\n    PluggableMap.prototype.forEachLayerAtPixel = function (pixel, callback, opt_options) {\n        if (!this.frameState_) {\n            return;\n        }\n        var options = opt_options || {};\n        var hitTolerance = options.hitTolerance !== undefined ? options.hitTolerance : 0;\n        var layerFilter = options.layerFilter || TRUE;\n        return this.renderer_.forEachLayerAtPixel(pixel, this.frameState_, hitTolerance, callback, layerFilter);\n    };\n    /**\n     * Detect if features intersect a pixel on the viewport. Layers included in the\n     * detection can be configured through `opt_layerFilter`.\n     * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\n     * @param {AtPixelOptions} [opt_options] Optional options.\n     * @return {boolean} Is there a feature at the given pixel?\n     * @api\n     */\n    PluggableMap.prototype.hasFeatureAtPixel = function (pixel, opt_options) {\n        if (!this.frameState_) {\n            return false;\n        }\n        var coordinate = this.getCoordinateFromPixelInternal(pixel);\n        opt_options = opt_options !== undefined ? opt_options : {};\n        var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : TRUE;\n        var hitTolerance = opt_options.hitTolerance !== undefined ? opt_options.hitTolerance : 0;\n        var checkWrapped = opt_options.checkWrapped !== false;\n        return this.renderer_.hasFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, layerFilter, null);\n    };\n    /**\n     * Returns the coordinate in user projection for a browser event.\n     * @param {MouseEvent} event Event.\n     * @return {import(\"./coordinate.js\").Coordinate} Coordinate.\n     * @api\n     */\n    PluggableMap.prototype.getEventCoordinate = function (event) {\n        return this.getCoordinateFromPixel(this.getEventPixel(event));\n    };\n    /**\n     * Returns the coordinate in view projection for a browser event.\n     * @param {MouseEvent} event Event.\n     * @return {import(\"./coordinate.js\").Coordinate} Coordinate.\n     */\n    PluggableMap.prototype.getEventCoordinateInternal = function (event) {\n        return this.getCoordinateFromPixelInternal(this.getEventPixel(event));\n    };\n    /**\n     * Returns the map pixel position for a browser event relative to the viewport.\n     * @param {UIEvent} event Event.\n     * @return {import(\"./pixel.js\").Pixel} Pixel.\n     * @api\n     */\n    PluggableMap.prototype.getEventPixel = function (event) {\n        var viewportPosition = this.viewport_.getBoundingClientRect();\n        var eventPosition = \n        //FIXME Are we really calling this with a TouchEvent anywhere?\n        'changedTouches' in event\n            ? /** @type {TouchEvent} */ (event).changedTouches[0]\n            : /** @type {MouseEvent} */ (event);\n        return [\n            eventPosition.clientX - viewportPosition.left,\n            eventPosition.clientY - viewportPosition.top,\n        ];\n    };\n    /**\n     * Get the target in which this map is rendered.\n     * Note that this returns what is entered as an option or in setTarget:\n     * if that was an element, it returns an element; if a string, it returns that.\n     * @return {HTMLElement|string|undefined} The Element or id of the Element that the\n     *     map is rendered in.\n     * @observable\n     * @api\n     */\n    PluggableMap.prototype.getTarget = function () {\n        return /** @type {HTMLElement|string|undefined} */ (this.get(MapProperty.TARGET));\n    };\n    /**\n     * Get the DOM element into which this map is rendered. In contrast to\n     * `getTarget` this method always return an `Element`, or `null` if the\n     * map has no target.\n     * @return {HTMLElement} The element that the map is rendered in.\n     * @api\n     */\n    PluggableMap.prototype.getTargetElement = function () {\n        var target = this.getTarget();\n        if (target !== undefined) {\n            return typeof target === 'string'\n                ? document.getElementById(target)\n                : target;\n        }\n        else {\n            return null;\n        }\n    };\n    /**\n     * Get the coordinate for a given pixel.  This returns a coordinate in the\n     * user projection.\n     * @param {import(\"./pixel.js\").Pixel} pixel Pixel position in the map viewport.\n     * @return {import(\"./coordinate.js\").Coordinate} The coordinate for the pixel position.\n     * @api\n     */\n    PluggableMap.prototype.getCoordinateFromPixel = function (pixel) {\n        return toUserCoordinate(this.getCoordinateFromPixelInternal(pixel), this.getView().getProjection());\n    };\n    /**\n     * Get the coordinate for a given pixel.  This returns a coordinate in the\n     * map view projection.\n     * @param {import(\"./pixel.js\").Pixel} pixel Pixel position in the map viewport.\n     * @return {import(\"./coordinate.js\").Coordinate} The coordinate for the pixel position.\n     */\n    PluggableMap.prototype.getCoordinateFromPixelInternal = function (pixel) {\n        var frameState = this.frameState_;\n        if (!frameState) {\n            return null;\n        }\n        else {\n            return applyTransform(frameState.pixelToCoordinateTransform, pixel.slice());\n        }\n    };\n    /**\n     * Get the map controls. Modifying this collection changes the controls\n     * associated with the map.\n     * @return {Collection<import(\"./control/Control.js\").default>} Controls.\n     * @api\n     */\n    PluggableMap.prototype.getControls = function () {\n        return this.controls;\n    };\n    /**\n     * Get the map overlays. Modifying this collection changes the overlays\n     * associated with the map.\n     * @return {Collection<import(\"./Overlay.js\").default>} Overlays.\n     * @api\n     */\n    PluggableMap.prototype.getOverlays = function () {\n        return this.overlays_;\n    };\n    /**\n     * Get an overlay by its identifier (the value returned by overlay.getId()).\n     * Note that the index treats string and numeric identifiers as the same. So\n     * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.\n     * @param {string|number} id Overlay identifier.\n     * @return {import(\"./Overlay.js\").default} Overlay.\n     * @api\n     */\n    PluggableMap.prototype.getOverlayById = function (id) {\n        var overlay = this.overlayIdIndex_[id.toString()];\n        return overlay !== undefined ? overlay : null;\n    };\n    /**\n     * Get the map interactions. Modifying this collection changes the interactions\n     * associated with the map.\n     *\n     * Interactions are used for e.g. pan, zoom and rotate.\n     * @return {Collection<import(\"./interaction/Interaction.js\").default>} Interactions.\n     * @api\n     */\n    PluggableMap.prototype.getInteractions = function () {\n        return this.interactions;\n    };\n    /**\n     * Get the layergroup associated with this map.\n     * @return {LayerGroup} A layer group containing the layers in this map.\n     * @observable\n     * @api\n     */\n    PluggableMap.prototype.getLayerGroup = function () {\n        return /** @type {LayerGroup} */ (this.get(MapProperty.LAYERGROUP));\n    };\n    /**\n     * Get the collection of layers associated with this map.\n     * @return {!Collection<import(\"./layer/Base.js\").default>} Layers.\n     * @api\n     */\n    PluggableMap.prototype.getLayers = function () {\n        var layers = this.getLayerGroup().getLayers();\n        return layers;\n    };\n    /**\n     * @return {boolean} Layers have sources that are still loading.\n     */\n    PluggableMap.prototype.getLoading = function () {\n        var layerStatesArray = this.getLayerGroup().getLayerStatesArray();\n        for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {\n            var layer = layerStatesArray[i].layer;\n            var source = /** @type {import(\"./layer/Layer.js\").default} */ (layer).getSource();\n            if (source && source.loading) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * Get the pixel for a coordinate.  This takes a coordinate in the user\n     * projection and returns the corresponding pixel.\n     * @param {import(\"./coordinate.js\").Coordinate} coordinate A map coordinate.\n     * @return {import(\"./pixel.js\").Pixel} A pixel position in the map viewport.\n     * @api\n     */\n    PluggableMap.prototype.getPixelFromCoordinate = function (coordinate) {\n        var viewCoordinate = fromUserCoordinate(coordinate, this.getView().getProjection());\n        return this.getPixelFromCoordinateInternal(viewCoordinate);\n    };\n    /**\n     * Get the pixel for a coordinate.  This takes a coordinate in the map view\n     * projection and returns the corresponding pixel.\n     * @param {import(\"./coordinate.js\").Coordinate} coordinate A map coordinate.\n     * @return {import(\"./pixel.js\").Pixel} A pixel position in the map viewport.\n     */\n    PluggableMap.prototype.getPixelFromCoordinateInternal = function (coordinate) {\n        var frameState = this.frameState_;\n        if (!frameState) {\n            return null;\n        }\n        else {\n            return applyTransform(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));\n        }\n    };\n    /**\n     * Get the map renderer.\n     * @return {import(\"./renderer/Map.js\").default} Renderer\n     */\n    PluggableMap.prototype.getRenderer = function () {\n        return this.renderer_;\n    };\n    /**\n     * Get the size of this map.\n     * @return {import(\"./size.js\").Size|undefined} The size in pixels of the map in the DOM.\n     * @observable\n     * @api\n     */\n    PluggableMap.prototype.getSize = function () {\n        return /** @type {import(\"./size.js\").Size|undefined} */ (this.get(MapProperty.SIZE));\n    };\n    /**\n     * Get the view associated with this map. A view manages properties such as\n     * center and resolution.\n     * @return {View} The view that controls this map.\n     * @observable\n     * @api\n     */\n    PluggableMap.prototype.getView = function () {\n        return /** @type {View} */ (this.get(MapProperty.VIEW));\n    };\n    /**\n     * Get the element that serves as the map viewport.\n     * @return {HTMLElement} Viewport.\n     * @api\n     */\n    PluggableMap.prototype.getViewport = function () {\n        return this.viewport_;\n    };\n    /**\n     * Get the element that serves as the container for overlays.  Elements added to\n     * this container will let mousedown and touchstart events through to the map,\n     * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}\n     * events.\n     * @return {!HTMLElement} The map's overlay container.\n     */\n    PluggableMap.prototype.getOverlayContainer = function () {\n        return this.overlayContainer_;\n    };\n    /**\n     * Get the element that serves as a container for overlays that don't allow\n     * event propagation. Elements added to this container won't let mousedown and\n     * touchstart events through to the map, so clicks and gestures on an overlay\n     * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n     * @return {!HTMLElement} The map's overlay container that stops events.\n     */\n    PluggableMap.prototype.getOverlayContainerStopEvent = function () {\n        return this.overlayContainerStopEvent_;\n    };\n    /**\n     * @return {!Document} The document where the map is displayed.\n     */\n    PluggableMap.prototype.getOwnerDocument = function () {\n        var targetElement = this.getTargetElement();\n        return targetElement ? targetElement.ownerDocument : document;\n    };\n    /**\n     * @param {import(\"./Tile.js\").default} tile Tile.\n     * @param {string} tileSourceKey Tile source key.\n     * @param {import(\"./coordinate.js\").Coordinate} tileCenter Tile center.\n     * @param {number} tileResolution Tile resolution.\n     * @return {number} Tile priority.\n     */\n    PluggableMap.prototype.getTilePriority = function (tile, tileSourceKey, tileCenter, tileResolution) {\n        return getTilePriority(this.frameState_, tile, tileSourceKey, tileCenter, tileResolution);\n    };\n    /**\n     * @param {UIEvent} browserEvent Browser event.\n     * @param {string} [opt_type] Type.\n     */\n    PluggableMap.prototype.handleBrowserEvent = function (browserEvent, opt_type) {\n        var type = opt_type || browserEvent.type;\n        var mapBrowserEvent = new MapBrowserEvent(type, this, browserEvent);\n        this.handleMapBrowserEvent(mapBrowserEvent);\n    };\n    /**\n     * @param {MapBrowserEvent} mapBrowserEvent The event to handle.\n     */\n    PluggableMap.prototype.handleMapBrowserEvent = function (mapBrowserEvent) {\n        if (!this.frameState_) {\n            // With no view defined, we cannot translate pixels into geographical\n            // coordinates so interactions cannot be used.\n            return;\n        }\n        var originalEvent = /** @type {PointerEvent} */ (mapBrowserEvent.originalEvent);\n        var eventType = originalEvent.type;\n        if (eventType === PointerEventType.POINTERDOWN ||\n            eventType === EventType.WHEEL ||\n            eventType === EventType.KEYDOWN) {\n            var doc = this.getOwnerDocument();\n            var rootNode = this.viewport_.getRootNode\n                ? this.viewport_.getRootNode()\n                : doc;\n            var target = /** @type {Node} */ (originalEvent.target);\n            if (\n            // Abort if the target is a child of the container for elements whose events are not meant\n            // to be handled by map interactions.\n            this.overlayContainerStopEvent_.contains(target) ||\n                // Abort if the event target is a child of the container that is no longer in the page.\n                // It's possible for the target to no longer be in the page if it has been removed in an\n                // event listener, this might happen in a Control that recreates it's content based on\n                // user interaction either manually or via a render in something like https://reactjs.org/\n                !(rootNode === doc ? doc.documentElement : rootNode).contains(target)) {\n                return;\n            }\n        }\n        mapBrowserEvent.frameState = this.frameState_;\n        if (this.dispatchEvent(mapBrowserEvent) !== false) {\n            var interactionsArray = this.getInteractions().getArray().slice();\n            for (var i = interactionsArray.length - 1; i >= 0; i--) {\n                var interaction = interactionsArray[i];\n                if (interaction.getMap() !== this ||\n                    !interaction.getActive() ||\n                    !this.getTargetElement()) {\n                    continue;\n                }\n                var cont = interaction.handleEvent(mapBrowserEvent);\n                if (!cont || mapBrowserEvent.propagationStopped) {\n                    break;\n                }\n            }\n        }\n    };\n    /**\n     * @protected\n     */\n    PluggableMap.prototype.handlePostRender = function () {\n        var frameState = this.frameState_;\n        // Manage the tile queue\n        // Image loads are expensive and a limited resource, so try to use them\n        // efficiently:\n        // * When the view is static we allow a large number of parallel tile loads\n        //   to complete the frame as quickly as possible.\n        // * When animating or interacting, image loads can cause janks, so we reduce\n        //   the maximum number of loads per frame and limit the number of parallel\n        //   tile loads to remain reactive to view changes and to reduce the chance of\n        //   loading tiles that will quickly disappear from view.\n        var tileQueue = this.tileQueue_;\n        if (!tileQueue.isEmpty()) {\n            var maxTotalLoading = this.maxTilesLoading_;\n            var maxNewLoads = maxTotalLoading;\n            if (frameState) {\n                var hints = frameState.viewHints;\n                if (hints[ViewHint.ANIMATING] || hints[ViewHint.INTERACTING]) {\n                    var lowOnFrameBudget = Date.now() - frameState.time > 8;\n                    maxTotalLoading = lowOnFrameBudget ? 0 : 8;\n                    maxNewLoads = lowOnFrameBudget ? 0 : 2;\n                }\n            }\n            if (tileQueue.getTilesLoading() < maxTotalLoading) {\n                tileQueue.reprioritize(); // FIXME only call if view has changed\n                tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);\n            }\n        }\n        if (frameState &&\n            this.hasListener(RenderEventType.RENDERCOMPLETE) &&\n            !frameState.animate &&\n            !this.tileQueue_.getTilesLoading() &&\n            !this.getLoading()) {\n            this.renderer_.dispatchRenderEvent(RenderEventType.RENDERCOMPLETE, frameState);\n        }\n        var postRenderFunctions = this.postRenderFunctions_;\n        for (var i = 0, ii = postRenderFunctions.length; i < ii; ++i) {\n            postRenderFunctions[i](this, frameState);\n        }\n        postRenderFunctions.length = 0;\n    };\n    /**\n     * @private\n     */\n    PluggableMap.prototype.handleSizeChanged_ = function () {\n        if (this.getView() && !this.getView().getAnimating()) {\n            this.getView().resolveConstraints(0);\n        }\n        this.render();\n    };\n    /**\n     * @private\n     */\n    PluggableMap.prototype.handleTargetChanged_ = function () {\n        // target may be undefined, null, a string or an Element.\n        // If it's a string we convert it to an Element before proceeding.\n        // If it's not now an Element we remove the viewport from the DOM.\n        // If it's an Element we append the viewport element to it.\n        var targetElement;\n        if (this.getTarget()) {\n            targetElement = this.getTargetElement();\n        }\n        if (this.mapBrowserEventHandler_) {\n            for (var i = 0, ii = this.keyHandlerKeys_.length; i < ii; ++i) {\n                unlistenByKey(this.keyHandlerKeys_[i]);\n            }\n            this.keyHandlerKeys_ = null;\n            this.viewport_.removeEventListener(EventType.CONTEXTMENU, this.boundHandleBrowserEvent_);\n            this.viewport_.removeEventListener(EventType.WHEEL, this.boundHandleBrowserEvent_);\n            if (this.handleResize_ !== undefined) {\n                removeEventListener(EventType.RESIZE, this.handleResize_, false);\n                this.handleResize_ = undefined;\n            }\n            this.mapBrowserEventHandler_.dispose();\n            this.mapBrowserEventHandler_ = null;\n            removeNode(this.viewport_);\n        }\n        if (!targetElement) {\n            if (this.renderer_) {\n                clearTimeout(this.postRenderTimeoutHandle_);\n                this.postRenderTimeoutHandle_ = undefined;\n                this.postRenderFunctions_.length = 0;\n                this.renderer_.dispose();\n                this.renderer_ = null;\n            }\n            if (this.animationDelayKey_) {\n                cancelAnimationFrame(this.animationDelayKey_);\n                this.animationDelayKey_ = undefined;\n            }\n        }\n        else {\n            targetElement.appendChild(this.viewport_);\n            if (!this.renderer_) {\n                this.renderer_ = this.createRenderer();\n            }\n            this.mapBrowserEventHandler_ = new MapBrowserEventHandler(this, this.moveTolerance_);\n            for (var key in MapBrowserEventType) {\n                this.mapBrowserEventHandler_.addEventListener(MapBrowserEventType[key], this.handleMapBrowserEvent.bind(this));\n            }\n            this.viewport_.addEventListener(EventType.CONTEXTMENU, this.boundHandleBrowserEvent_, false);\n            this.viewport_.addEventListener(EventType.WHEEL, this.boundHandleBrowserEvent_, PASSIVE_EVENT_LISTENERS ? { passive: false } : false);\n            var keyboardEventTarget = !this.keyboardEventTarget_\n                ? targetElement\n                : this.keyboardEventTarget_;\n            this.keyHandlerKeys_ = [\n                listen(keyboardEventTarget, EventType.KEYDOWN, this.handleBrowserEvent, this),\n                listen(keyboardEventTarget, EventType.KEYPRESS, this.handleBrowserEvent, this),\n            ];\n            if (!this.handleResize_) {\n                this.handleResize_ = this.updateSize.bind(this);\n                window.addEventListener(EventType.RESIZE, this.handleResize_, false);\n            }\n        }\n        this.updateSize();\n        // updateSize calls setSize, so no need to call this.render\n        // ourselves here.\n    };\n    /**\n     * @private\n     */\n    PluggableMap.prototype.handleTileChange_ = function () {\n        this.render();\n    };\n    /**\n     * @private\n     */\n    PluggableMap.prototype.handleViewPropertyChanged_ = function () {\n        this.render();\n    };\n    /**\n     * @private\n     */\n    PluggableMap.prototype.handleViewChanged_ = function () {\n        if (this.viewPropertyListenerKey_) {\n            unlistenByKey(this.viewPropertyListenerKey_);\n            this.viewPropertyListenerKey_ = null;\n        }\n        if (this.viewChangeListenerKey_) {\n            unlistenByKey(this.viewChangeListenerKey_);\n            this.viewChangeListenerKey_ = null;\n        }\n        var view = this.getView();\n        if (view) {\n            this.updateViewportSize_();\n            this.viewPropertyListenerKey_ = listen(view, ObjectEventType.PROPERTYCHANGE, this.handleViewPropertyChanged_, this);\n            this.viewChangeListenerKey_ = listen(view, EventType.CHANGE, this.handleViewPropertyChanged_, this);\n            view.resolveConstraints(0);\n        }\n        this.render();\n    };\n    /**\n     * @private\n     */\n    PluggableMap.prototype.handleLayerGroupChanged_ = function () {\n        if (this.layerGroupPropertyListenerKeys_) {\n            this.layerGroupPropertyListenerKeys_.forEach(unlistenByKey);\n            this.layerGroupPropertyListenerKeys_ = null;\n        }\n        var layerGroup = this.getLayerGroup();\n        if (layerGroup) {\n            this.layerGroupPropertyListenerKeys_ = [\n                listen(layerGroup, ObjectEventType.PROPERTYCHANGE, this.render, this),\n                listen(layerGroup, EventType.CHANGE, this.render, this),\n            ];\n        }\n        this.render();\n    };\n    /**\n     * @return {boolean} Is rendered.\n     */\n    PluggableMap.prototype.isRendered = function () {\n        return !!this.frameState_;\n    };\n    /**\n     * Requests an immediate render in a synchronous manner.\n     * @api\n     */\n    PluggableMap.prototype.renderSync = function () {\n        if (this.animationDelayKey_) {\n            cancelAnimationFrame(this.animationDelayKey_);\n        }\n        this.animationDelay_();\n    };\n    /**\n     * Redraws all text after new fonts have loaded\n     */\n    PluggableMap.prototype.redrawText = function () {\n        var layerStates = this.getLayerGroup().getLayerStatesArray();\n        for (var i = 0, ii = layerStates.length; i < ii; ++i) {\n            var layer = layerStates[i].layer;\n            if (layer.hasRenderer()) {\n                layer.getRenderer().handleFontsChanged();\n            }\n        }\n    };\n    /**\n     * Request a map rendering (at the next animation frame).\n     * @api\n     */\n    PluggableMap.prototype.render = function () {\n        if (this.renderer_ && this.animationDelayKey_ === undefined) {\n            this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);\n        }\n    };\n    /**\n     * Remove the given control from the map.\n     * @param {import(\"./control/Control.js\").default} control Control.\n     * @return {import(\"./control/Control.js\").default|undefined} The removed control (or undefined\n     *     if the control was not found).\n     * @api\n     */\n    PluggableMap.prototype.removeControl = function (control) {\n        return this.getControls().remove(control);\n    };\n    /**\n     * Remove the given interaction from the map.\n     * @param {import(\"./interaction/Interaction.js\").default} interaction Interaction to remove.\n     * @return {import(\"./interaction/Interaction.js\").default|undefined} The removed interaction (or\n     *     undefined if the interaction was not found).\n     * @api\n     */\n    PluggableMap.prototype.removeInteraction = function (interaction) {\n        return this.getInteractions().remove(interaction);\n    };\n    /**\n     * Removes the given layer from the map.\n     * @param {import(\"./layer/Base.js\").default} layer Layer.\n     * @return {import(\"./layer/Base.js\").default|undefined} The removed layer (or undefined if the\n     *     layer was not found).\n     * @api\n     */\n    PluggableMap.prototype.removeLayer = function (layer) {\n        var layers = this.getLayerGroup().getLayers();\n        return layers.remove(layer);\n    };\n    /**\n     * Remove the given overlay from the map.\n     * @param {import(\"./Overlay.js\").default} overlay Overlay.\n     * @return {import(\"./Overlay.js\").default|undefined} The removed overlay (or undefined\n     *     if the overlay was not found).\n     * @api\n     */\n    PluggableMap.prototype.removeOverlay = function (overlay) {\n        return this.getOverlays().remove(overlay);\n    };\n    /**\n     * @param {number} time Time.\n     * @private\n     */\n    PluggableMap.prototype.renderFrame_ = function (time) {\n        var _this = this;\n        var size = this.getSize();\n        var view = this.getView();\n        var previousFrameState = this.frameState_;\n        /** @type {?FrameState} */\n        var frameState = null;\n        if (size !== undefined && hasArea(size) && view && view.isDef()) {\n            var viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : undefined);\n            var viewState = view.getState();\n            frameState = {\n                animate: false,\n                coordinateToPixelTransform: this.coordinateToPixelTransform_,\n                declutterTree: null,\n                extent: getForViewAndSize(viewState.center, viewState.resolution, viewState.rotation, size),\n                index: this.frameIndex_++,\n                layerIndex: 0,\n                layerStatesArray: this.getLayerGroup().getLayerStatesArray(),\n                pixelRatio: this.pixelRatio_,\n                pixelToCoordinateTransform: this.pixelToCoordinateTransform_,\n                postRenderFunctions: [],\n                size: size,\n                tileQueue: this.tileQueue_,\n                time: time,\n                usedTiles: {},\n                viewState: viewState,\n                viewHints: viewHints,\n                wantedTiles: {},\n            };\n        }\n        this.frameState_ = frameState;\n        this.renderer_.renderFrame(frameState);\n        if (frameState) {\n            if (frameState.animate) {\n                this.render();\n            }\n            Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);\n            if (previousFrameState) {\n                var moveStart = !this.previousExtent_ ||\n                    (!isEmpty(this.previousExtent_) &&\n                        !equals(frameState.extent, this.previousExtent_));\n                if (moveStart) {\n                    this.dispatchEvent(new MapEvent(MapEventType.MOVESTART, this, previousFrameState));\n                    this.previousExtent_ = createOrUpdateEmpty(this.previousExtent_);\n                }\n            }\n            var idle = this.previousExtent_ &&\n                !frameState.viewHints[ViewHint.ANIMATING] &&\n                !frameState.viewHints[ViewHint.INTERACTING] &&\n                !equals(frameState.extent, this.previousExtent_);\n            if (idle) {\n                this.dispatchEvent(new MapEvent(MapEventType.MOVEEND, this, frameState));\n                clone(frameState.extent, this.previousExtent_);\n            }\n        }\n        this.dispatchEvent(new MapEvent(MapEventType.POSTRENDER, this, frameState));\n        if (!this.postRenderTimeoutHandle_) {\n            this.postRenderTimeoutHandle_ = setTimeout(function () {\n                _this.postRenderTimeoutHandle_ = undefined;\n                _this.handlePostRender();\n            }, 0);\n        }\n    };\n    /**\n     * Sets the layergroup of this map.\n     * @param {LayerGroup} layerGroup A layer group containing the layers in this map.\n     * @observable\n     * @api\n     */\n    PluggableMap.prototype.setLayerGroup = function (layerGroup) {\n        this.set(MapProperty.LAYERGROUP, layerGroup);\n    };\n    /**\n     * Set the size of this map.\n     * @param {import(\"./size.js\").Size|undefined} size The size in pixels of the map in the DOM.\n     * @observable\n     * @api\n     */\n    PluggableMap.prototype.setSize = function (size) {\n        this.set(MapProperty.SIZE, size);\n    };\n    /**\n     * Set the target element to render this map into.\n     * @param {HTMLElement|string} [target] The Element or id of the Element\n     *     that the map is rendered in.\n     * @observable\n     * @api\n     */\n    PluggableMap.prototype.setTarget = function (target) {\n        this.set(MapProperty.TARGET, target);\n    };\n    /**\n     * Set the view for this map.\n     * @param {View} view The view that controls this map.\n     * @observable\n     * @api\n     */\n    PluggableMap.prototype.setView = function (view) {\n        this.set(MapProperty.VIEW, view);\n    };\n    /**\n     * Force a recalculation of the map viewport size.  This should be called when\n     * third-party code changes the size of the map viewport.\n     * @api\n     */\n    PluggableMap.prototype.updateSize = function () {\n        var targetElement = this.getTargetElement();\n        var size = undefined;\n        if (targetElement) {\n            var computedStyle = getComputedStyle(targetElement);\n            var width = targetElement.offsetWidth -\n                parseFloat(computedStyle['borderLeftWidth']) -\n                parseFloat(computedStyle['paddingLeft']) -\n                parseFloat(computedStyle['paddingRight']) -\n                parseFloat(computedStyle['borderRightWidth']);\n            var height = targetElement.offsetHeight -\n                parseFloat(computedStyle['borderTopWidth']) -\n                parseFloat(computedStyle['paddingTop']) -\n                parseFloat(computedStyle['paddingBottom']) -\n                parseFloat(computedStyle['borderBottomWidth']);\n            if (!isNaN(width) && !isNaN(height)) {\n                size = [width, height];\n                if (!hasArea(size)) {\n                    // eslint-disable-next-line\n                    console.warn(\"No map visible because the map container's width or height are 0.\");\n                }\n            }\n        }\n        this.setSize(size);\n        this.updateViewportSize_();\n    };\n    /**\n     * Recomputes the viewport size and save it on the view object (if any)\n     * @private\n     */\n    PluggableMap.prototype.updateViewportSize_ = function () {\n        var view = this.getView();\n        if (view) {\n            var size = undefined;\n            var computedStyle = getComputedStyle(this.viewport_);\n            if (computedStyle.width && computedStyle.height) {\n                size = [\n                    parseInt(computedStyle.width, 10),\n                    parseInt(computedStyle.height, 10),\n                ];\n            }\n            view.setViewportSize(size);\n        }\n    };\n    return PluggableMap;\n}(BaseObject));\n/**\n * @param {MapOptions} options Map options.\n * @return {MapOptionsInternal} Internal map options.\n */\nfunction createOptionsInternal(options) {\n    /**\n     * @type {HTMLElement|Document}\n     */\n    var keyboardEventTarget = null;\n    if (options.keyboardEventTarget !== undefined) {\n        keyboardEventTarget =\n            typeof options.keyboardEventTarget === 'string'\n                ? document.getElementById(options.keyboardEventTarget)\n                : options.keyboardEventTarget;\n    }\n    /**\n     * @type {Object<string, *>}\n     */\n    var values = {};\n    var layerGroup = options.layers &&\n        typeof ( /** @type {?} */(options.layers).getLayers) === 'function'\n        ? /** @type {LayerGroup} */ (options.layers)\n        : new LayerGroup({ layers: /** @type {Collection} */ (options.layers) });\n    values[MapProperty.LAYERGROUP] = layerGroup;\n    values[MapProperty.TARGET] = options.target;\n    values[MapProperty.VIEW] =\n        options.view !== undefined ? options.view : new View();\n    var controls;\n    if (options.controls !== undefined) {\n        if (Array.isArray(options.controls)) {\n            controls = new Collection(options.controls.slice());\n        }\n        else {\n            assert(typeof ( /** @type {?} */(options.controls).getArray) === 'function', 47); // Expected `controls` to be an array or an `import(\"./Collection.js\").Collection`\n            controls = /** @type {Collection} */ (options.controls);\n        }\n    }\n    var interactions;\n    if (options.interactions !== undefined) {\n        if (Array.isArray(options.interactions)) {\n            interactions = new Collection(options.interactions.slice());\n        }\n        else {\n            assert(typeof ( /** @type {?} */(options.interactions).getArray) ===\n                'function', 48); // Expected `interactions` to be an array or an `import(\"./Collection.js\").Collection`\n            interactions = /** @type {Collection} */ (options.interactions);\n        }\n    }\n    var overlays;\n    if (options.overlays !== undefined) {\n        if (Array.isArray(options.overlays)) {\n            overlays = new Collection(options.overlays.slice());\n        }\n        else {\n            assert(typeof ( /** @type {?} */(options.overlays).getArray) === 'function', 49); // Expected `overlays` to be an array or an `import(\"./Collection.js\").Collection`\n            overlays = options.overlays;\n        }\n    }\n    else {\n        overlays = new Collection();\n    }\n    return {\n        controls: controls,\n        interactions: interactions,\n        keyboardEventTarget: keyboardEventTarget,\n        overlays: overlays,\n        values: values,\n    };\n}\nexport default PluggableMap;\n//# sourceMappingURL=PluggableMap.js.map"]},"metadata":{},"sourceType":"module"}