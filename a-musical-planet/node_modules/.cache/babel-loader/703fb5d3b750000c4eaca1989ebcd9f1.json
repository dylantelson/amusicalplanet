{"ast":null,"code":"/**\n * @module ol/geom/flat/closest\n */\nimport { lerp, squaredDistance as squaredDx } from '../../math.js';\n/**\n * Returns the point on the 2D line segment flatCoordinates[offset1] to\n * flatCoordinates[offset2] that is closest to the point (x, y).  Extra\n * dimensions are linearly interpolated.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset1 Offset 1.\n * @param {number} offset2 Offset 2.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n */\n\nfunction assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {\n  var x1 = flatCoordinates[offset1];\n  var y1 = flatCoordinates[offset1 + 1];\n  var dx = flatCoordinates[offset2] - x1;\n  var dy = flatCoordinates[offset2 + 1] - y1;\n  var offset;\n\n  if (dx === 0 && dy === 0) {\n    offset = offset1;\n  } else {\n    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n\n    if (t > 1) {\n      offset = offset2;\n    } else if (t > 0) {\n      for (var i = 0; i < stride; ++i) {\n        closestPoint[i] = lerp(flatCoordinates[offset1 + i], flatCoordinates[offset2 + i], t);\n      }\n\n      closestPoint.length = stride;\n      return;\n    } else {\n      offset = offset1;\n    }\n  }\n\n  for (var i = 0; i < stride; ++i) {\n    closestPoint[i] = flatCoordinates[offset + i];\n  }\n\n  closestPoint.length = stride;\n}\n/**\n * Return the squared of the largest distance between any pair of consecutive\n * coordinates.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\n\n\nexport function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {\n  var x1 = flatCoordinates[offset];\n  var y1 = flatCoordinates[offset + 1];\n\n  for (offset += stride; offset < end; offset += stride) {\n    var x2 = flatCoordinates[offset];\n    var y2 = flatCoordinates[offset + 1];\n    var squaredDelta = squaredDx(x1, y1, x2, y2);\n\n    if (squaredDelta > max) {\n      max = squaredDelta;\n    }\n\n    x1 = x2;\n    y1 = y2;\n  }\n\n  return max;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\n\nexport function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);\n    offset = end;\n  }\n\n  return max;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\n\nexport function multiArrayMaxSquaredDelta(flatCoordinates, offset, endss, stride, max) {\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);\n    offset = ends[ends.length - 1];\n  }\n\n  return max;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>} [opt_tmpPoint] Temporary point object.\n * @return {number} Minimum squared distance.\n */\n\nexport function assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {\n  if (offset == end) {\n    return minSquaredDistance;\n  }\n\n  var i, squaredDistance;\n\n  if (maxDelta === 0) {\n    // All points are identical, so just test the first point.\n    squaredDistance = squaredDx(x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);\n\n    if (squaredDistance < minSquaredDistance) {\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = flatCoordinates[offset + i];\n      }\n\n      closestPoint.length = stride;\n      return squaredDistance;\n    } else {\n      return minSquaredDistance;\n    }\n  }\n\n  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n  var index = offset + stride;\n\n  while (index < end) {\n    assignClosest(flatCoordinates, index - stride, index, stride, x, y, tmpPoint);\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\n\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n\n      closestPoint.length = stride;\n      index += stride;\n    } else {\n      // Skip ahead multiple points, because we know that all the skipped\n      // points cannot be any closer than the closest point we have found so\n      // far.  We know this because we know how close the current point is, how\n      // close the closest point we have found so far is, and the maximum\n      // distance between consecutive points.  For example, if we're currently\n      // at distance 10, the best we've found so far is 3, and that the maximum\n      // distance between consecutive points is 2, then we'll need to skip at\n      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of\n      // finding a closer point.  We use Math.max(..., 1) to ensure that we\n      // always advance at least one point, to avoid an infinite loop.\n      index += stride * Math.max((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) / maxDelta | 0, 1);\n    }\n  }\n\n  if (isRing) {\n    // Check the closing segment.\n    assignClosest(flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\n\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n\n      closestPoint.length = stride;\n    }\n  }\n\n  return minSquaredDistance;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>} [opt_tmpPoint] Temporary point object.\n * @return {number} Minimum squared distance.\n */\n\nexport function assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {\n  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    minSquaredDistance = assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\n    offset = end;\n  }\n\n  return minSquaredDistance;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>} [opt_tmpPoint] Temporary point object.\n * @return {number} Minimum squared distance.\n */\n\nexport function assignClosestMultiArrayPoint(flatCoordinates, offset, endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {\n  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    minSquaredDistance = assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\n    offset = ends[ends.length - 1];\n  }\n\n  return minSquaredDistance;\n}","map":{"version":3,"sources":["../../src/geom/flat/closest.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @module ol/geom/flat/closest\n */\nimport { lerp, squaredDistance as squaredDx } from '../../math.js';\n/**\n * Returns the point on the 2D line segment flatCoordinates[offset1] to\n * flatCoordinates[offset2] that is closest to the point (x, y).  Extra\n * dimensions are linearly interpolated.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset1 Offset 1.\n * @param {number} offset2 Offset 2.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n */\nfunction assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {\n    var x1 = flatCoordinates[offset1];\n    var y1 = flatCoordinates[offset1 + 1];\n    var dx = flatCoordinates[offset2] - x1;\n    var dy = flatCoordinates[offset2 + 1] - y1;\n    var offset;\n    if (dx === 0 && dy === 0) {\n        offset = offset1;\n    }\n    else {\n        var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n        if (t > 1) {\n            offset = offset2;\n        }\n        else if (t > 0) {\n            for (var i = 0; i < stride; ++i) {\n                closestPoint[i] = lerp(flatCoordinates[offset1 + i], flatCoordinates[offset2 + i], t);\n            }\n            closestPoint.length = stride;\n            return;\n        }\n        else {\n            offset = offset1;\n        }\n    }\n    for (var i = 0; i < stride; ++i) {\n        closestPoint[i] = flatCoordinates[offset + i];\n    }\n    closestPoint.length = stride;\n}\n/**\n * Return the squared of the largest distance between any pair of consecutive\n * coordinates.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {\n    var x1 = flatCoordinates[offset];\n    var y1 = flatCoordinates[offset + 1];\n    for (offset += stride; offset < end; offset += stride) {\n        var x2 = flatCoordinates[offset];\n        var y2 = flatCoordinates[offset + 1];\n        var squaredDelta = squaredDx(x1, y1, x2, y2);\n        if (squaredDelta > max) {\n            max = squaredDelta;\n        }\n        x1 = x2;\n        y1 = y2;\n    }\n    return max;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);\n        offset = end;\n    }\n    return max;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function multiArrayMaxSquaredDelta(flatCoordinates, offset, endss, stride, max) {\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);\n        offset = ends[ends.length - 1];\n    }\n    return max;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>} [opt_tmpPoint] Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {\n    if (offset == end) {\n        return minSquaredDistance;\n    }\n    var i, squaredDistance;\n    if (maxDelta === 0) {\n        // All points are identical, so just test the first point.\n        squaredDistance = squaredDx(x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);\n        if (squaredDistance < minSquaredDistance) {\n            for (i = 0; i < stride; ++i) {\n                closestPoint[i] = flatCoordinates[offset + i];\n            }\n            closestPoint.length = stride;\n            return squaredDistance;\n        }\n        else {\n            return minSquaredDistance;\n        }\n    }\n    var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n    var index = offset + stride;\n    while (index < end) {\n        assignClosest(flatCoordinates, index - stride, index, stride, x, y, tmpPoint);\n        squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\n        if (squaredDistance < minSquaredDistance) {\n            minSquaredDistance = squaredDistance;\n            for (i = 0; i < stride; ++i) {\n                closestPoint[i] = tmpPoint[i];\n            }\n            closestPoint.length = stride;\n            index += stride;\n        }\n        else {\n            // Skip ahead multiple points, because we know that all the skipped\n            // points cannot be any closer than the closest point we have found so\n            // far.  We know this because we know how close the current point is, how\n            // close the closest point we have found so far is, and the maximum\n            // distance between consecutive points.  For example, if we're currently\n            // at distance 10, the best we've found so far is 3, and that the maximum\n            // distance between consecutive points is 2, then we'll need to skip at\n            // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of\n            // finding a closer point.  We use Math.max(..., 1) to ensure that we\n            // always advance at least one point, to avoid an infinite loop.\n            index +=\n                stride *\n                    Math.max(((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) /\n                        maxDelta) |\n                        0, 1);\n        }\n    }\n    if (isRing) {\n        // Check the closing segment.\n        assignClosest(flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);\n        squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\n        if (squaredDistance < minSquaredDistance) {\n            minSquaredDistance = squaredDistance;\n            for (i = 0; i < stride; ++i) {\n                closestPoint[i] = tmpPoint[i];\n            }\n            closestPoint.length = stride;\n        }\n    }\n    return minSquaredDistance;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>} [opt_tmpPoint] Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {\n    var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        minSquaredDistance = assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\n        offset = end;\n    }\n    return minSquaredDistance;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>} [opt_tmpPoint] Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestMultiArrayPoint(flatCoordinates, offset, endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {\n    var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        minSquaredDistance = assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\n        offset = ends[ends.length - 1];\n    }\n    return minSquaredDistance;\n}\n//# sourceMappingURL=closest.js.map"]},"metadata":{},"sourceType":"module"}