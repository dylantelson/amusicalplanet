{"ast":null,"code":"/**\n * @module ol/geom/flat/geodesic\n */\nimport { get as getProjection, getTransform } from '../../proj.js';\nimport { squaredSegmentDistance, toDegrees, toRadians } from '../../math.js';\n/**\n * @param {function(number): import(\"../../coordinate.js\").Coordinate} interpolate Interpolate function.\n * @param {import(\"../../proj.js\").TransformFunction} transform Transform from longitude/latitude to\n *     projected coordinates.\n * @param {number} squaredTolerance Squared tolerance.\n * @return {Array<number>} Flat coordinates.\n */\n\nfunction line(interpolate, transform, squaredTolerance) {\n  // FIXME reduce garbage generation\n  // FIXME optimize stack operations\n\n  /** @type {Array<number>} */\n  var flatCoordinates = [];\n  var geoA = interpolate(0);\n  var geoB = interpolate(1);\n  var a = transform(geoA);\n  var b = transform(geoB);\n  /** @type {Array<import(\"../../coordinate.js\").Coordinate>} */\n\n  var geoStack = [geoB, geoA];\n  /** @type {Array<import(\"../../coordinate.js\").Coordinate>} */\n\n  var stack = [b, a];\n  /** @type {Array<number>} */\n\n  var fractionStack = [1, 0];\n  /** @type {!Object<string, boolean>} */\n\n  var fractions = {};\n  var maxIterations = 1e5;\n  var geoM, m, fracA, fracB, fracM, key;\n\n  while (--maxIterations > 0 && fractionStack.length > 0) {\n    // Pop the a coordinate off the stack\n    fracA = fractionStack.pop();\n    geoA = geoStack.pop();\n    a = stack.pop(); // Add the a coordinate if it has not been added yet\n\n    key = fracA.toString();\n\n    if (!(key in fractions)) {\n      flatCoordinates.push(a[0], a[1]);\n      fractions[key] = true;\n    } // Pop the b coordinate off the stack\n\n\n    fracB = fractionStack.pop();\n    geoB = geoStack.pop();\n    b = stack.pop(); // Find the m point between the a and b coordinates\n\n    fracM = (fracA + fracB) / 2;\n    geoM = interpolate(fracM);\n    m = transform(geoM);\n\n    if (squaredSegmentDistance(m[0], m[1], a[0], a[1], b[0], b[1]) < squaredTolerance) {\n      // If the m point is sufficiently close to the straight line, then we\n      // discard it.  Just use the b coordinate and move on to the next line\n      // segment.\n      flatCoordinates.push(b[0], b[1]);\n      key = fracB.toString();\n      fractions[key] = true;\n    } else {\n      // Otherwise, we need to subdivide the current line segment.  Split it\n      // into two and push the two line segments onto the stack.\n      fractionStack.push(fracB, fracM, fracM, fracA);\n      stack.push(b, m, m, a);\n      geoStack.push(geoB, geoM, geoM, geoA);\n    }\n  }\n\n  return flatCoordinates;\n}\n/**\n * Generate a great-circle arcs between two lat/lon points.\n * @param {number} lon1 Longitude 1 in degrees.\n * @param {number} lat1 Latitude 1 in degrees.\n * @param {number} lon2 Longitude 2 in degrees.\n * @param {number} lat2 Latitude 2 in degrees.\n * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n * @param {number} squaredTolerance Squared tolerance.\n * @return {Array<number>} Flat coordinates.\n */\n\n\nexport function greatCircleArc(lon1, lat1, lon2, lat2, projection, squaredTolerance) {\n  var geoProjection = getProjection('EPSG:4326');\n  var cosLat1 = Math.cos(toRadians(lat1));\n  var sinLat1 = Math.sin(toRadians(lat1));\n  var cosLat2 = Math.cos(toRadians(lat2));\n  var sinLat2 = Math.sin(toRadians(lat2));\n  var cosDeltaLon = Math.cos(toRadians(lon2 - lon1));\n  var sinDeltaLon = Math.sin(toRadians(lon2 - lon1));\n  var d = sinLat1 * sinLat2 + cosLat1 * cosLat2 * cosDeltaLon;\n  return line(\n  /**\n   * @param {number} frac Fraction.\n   * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n   */\n  function (frac) {\n    if (1 <= d) {\n      return [lon2, lat2];\n    }\n\n    var D = frac * Math.acos(d);\n    var cosD = Math.cos(D);\n    var sinD = Math.sin(D);\n    var y = sinDeltaLon * cosLat2;\n    var x = cosLat1 * sinLat2 - sinLat1 * cosLat2 * cosDeltaLon;\n    var theta = Math.atan2(y, x);\n    var lat = Math.asin(sinLat1 * cosD + cosLat1 * sinD * Math.cos(theta));\n    var lon = toRadians(lon1) + Math.atan2(Math.sin(theta) * sinD * cosLat1, cosD - sinLat1 * Math.sin(lat));\n    return [toDegrees(lon), toDegrees(lat)];\n  }, getTransform(geoProjection, projection), squaredTolerance);\n}\n/**\n * Generate a meridian (line at constant longitude).\n * @param {number} lon Longitude.\n * @param {number} lat1 Latitude 1.\n * @param {number} lat2 Latitude 2.\n * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n * @param {number} squaredTolerance Squared tolerance.\n * @return {Array<number>} Flat coordinates.\n */\n\nexport function meridian(lon, lat1, lat2, projection, squaredTolerance) {\n  var epsg4326Projection = getProjection('EPSG:4326');\n  return line(\n  /**\n   * @param {number} frac Fraction.\n   * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n   */\n  function (frac) {\n    return [lon, lat1 + (lat2 - lat1) * frac];\n  }, getTransform(epsg4326Projection, projection), squaredTolerance);\n}\n/**\n * Generate a parallel (line at constant latitude).\n * @param {number} lat Latitude.\n * @param {number} lon1 Longitude 1.\n * @param {number} lon2 Longitude 2.\n * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n * @param {number} squaredTolerance Squared tolerance.\n * @return {Array<number>} Flat coordinates.\n */\n\nexport function parallel(lat, lon1, lon2, projection, squaredTolerance) {\n  var epsg4326Projection = getProjection('EPSG:4326');\n  return line(\n  /**\n   * @param {number} frac Fraction.\n   * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n   */\n  function (frac) {\n    return [lon1 + (lon2 - lon1) * frac, lat];\n  }, getTransform(epsg4326Projection, projection), squaredTolerance);\n}","map":{"version":3,"sources":["../../src/geom/flat/geodesic.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @module ol/geom/flat/geodesic\n */\nimport { get as getProjection, getTransform } from '../../proj.js';\nimport { squaredSegmentDistance, toDegrees, toRadians } from '../../math.js';\n/**\n * @param {function(number): import(\"../../coordinate.js\").Coordinate} interpolate Interpolate function.\n * @param {import(\"../../proj.js\").TransformFunction} transform Transform from longitude/latitude to\n *     projected coordinates.\n * @param {number} squaredTolerance Squared tolerance.\n * @return {Array<number>} Flat coordinates.\n */\nfunction line(interpolate, transform, squaredTolerance) {\n    // FIXME reduce garbage generation\n    // FIXME optimize stack operations\n    /** @type {Array<number>} */\n    var flatCoordinates = [];\n    var geoA = interpolate(0);\n    var geoB = interpolate(1);\n    var a = transform(geoA);\n    var b = transform(geoB);\n    /** @type {Array<import(\"../../coordinate.js\").Coordinate>} */\n    var geoStack = [geoB, geoA];\n    /** @type {Array<import(\"../../coordinate.js\").Coordinate>} */\n    var stack = [b, a];\n    /** @type {Array<number>} */\n    var fractionStack = [1, 0];\n    /** @type {!Object<string, boolean>} */\n    var fractions = {};\n    var maxIterations = 1e5;\n    var geoM, m, fracA, fracB, fracM, key;\n    while (--maxIterations > 0 && fractionStack.length > 0) {\n        // Pop the a coordinate off the stack\n        fracA = fractionStack.pop();\n        geoA = geoStack.pop();\n        a = stack.pop();\n        // Add the a coordinate if it has not been added yet\n        key = fracA.toString();\n        if (!(key in fractions)) {\n            flatCoordinates.push(a[0], a[1]);\n            fractions[key] = true;\n        }\n        // Pop the b coordinate off the stack\n        fracB = fractionStack.pop();\n        geoB = geoStack.pop();\n        b = stack.pop();\n        // Find the m point between the a and b coordinates\n        fracM = (fracA + fracB) / 2;\n        geoM = interpolate(fracM);\n        m = transform(geoM);\n        if (squaredSegmentDistance(m[0], m[1], a[0], a[1], b[0], b[1]) <\n            squaredTolerance) {\n            // If the m point is sufficiently close to the straight line, then we\n            // discard it.  Just use the b coordinate and move on to the next line\n            // segment.\n            flatCoordinates.push(b[0], b[1]);\n            key = fracB.toString();\n            fractions[key] = true;\n        }\n        else {\n            // Otherwise, we need to subdivide the current line segment.  Split it\n            // into two and push the two line segments onto the stack.\n            fractionStack.push(fracB, fracM, fracM, fracA);\n            stack.push(b, m, m, a);\n            geoStack.push(geoB, geoM, geoM, geoA);\n        }\n    }\n    return flatCoordinates;\n}\n/**\n * Generate a great-circle arcs between two lat/lon points.\n * @param {number} lon1 Longitude 1 in degrees.\n * @param {number} lat1 Latitude 1 in degrees.\n * @param {number} lon2 Longitude 2 in degrees.\n * @param {number} lat2 Latitude 2 in degrees.\n * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n * @param {number} squaredTolerance Squared tolerance.\n * @return {Array<number>} Flat coordinates.\n */\nexport function greatCircleArc(lon1, lat1, lon2, lat2, projection, squaredTolerance) {\n    var geoProjection = getProjection('EPSG:4326');\n    var cosLat1 = Math.cos(toRadians(lat1));\n    var sinLat1 = Math.sin(toRadians(lat1));\n    var cosLat2 = Math.cos(toRadians(lat2));\n    var sinLat2 = Math.sin(toRadians(lat2));\n    var cosDeltaLon = Math.cos(toRadians(lon2 - lon1));\n    var sinDeltaLon = Math.sin(toRadians(lon2 - lon1));\n    var d = sinLat1 * sinLat2 + cosLat1 * cosLat2 * cosDeltaLon;\n    return line(\n    /**\n     * @param {number} frac Fraction.\n     * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n     */\n    function (frac) {\n        if (1 <= d) {\n            return [lon2, lat2];\n        }\n        var D = frac * Math.acos(d);\n        var cosD = Math.cos(D);\n        var sinD = Math.sin(D);\n        var y = sinDeltaLon * cosLat2;\n        var x = cosLat1 * sinLat2 - sinLat1 * cosLat2 * cosDeltaLon;\n        var theta = Math.atan2(y, x);\n        var lat = Math.asin(sinLat1 * cosD + cosLat1 * sinD * Math.cos(theta));\n        var lon = toRadians(lon1) +\n            Math.atan2(Math.sin(theta) * sinD * cosLat1, cosD - sinLat1 * Math.sin(lat));\n        return [toDegrees(lon), toDegrees(lat)];\n    }, getTransform(geoProjection, projection), squaredTolerance);\n}\n/**\n * Generate a meridian (line at constant longitude).\n * @param {number} lon Longitude.\n * @param {number} lat1 Latitude 1.\n * @param {number} lat2 Latitude 2.\n * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n * @param {number} squaredTolerance Squared tolerance.\n * @return {Array<number>} Flat coordinates.\n */\nexport function meridian(lon, lat1, lat2, projection, squaredTolerance) {\n    var epsg4326Projection = getProjection('EPSG:4326');\n    return line(\n    /**\n     * @param {number} frac Fraction.\n     * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n     */\n    function (frac) {\n        return [lon, lat1 + (lat2 - lat1) * frac];\n    }, getTransform(epsg4326Projection, projection), squaredTolerance);\n}\n/**\n * Generate a parallel (line at constant latitude).\n * @param {number} lat Latitude.\n * @param {number} lon1 Longitude 1.\n * @param {number} lon2 Longitude 2.\n * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n * @param {number} squaredTolerance Squared tolerance.\n * @return {Array<number>} Flat coordinates.\n */\nexport function parallel(lat, lon1, lon2, projection, squaredTolerance) {\n    var epsg4326Projection = getProjection('EPSG:4326');\n    return line(\n    /**\n     * @param {number} frac Fraction.\n     * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n     */\n    function (frac) {\n        return [lon1 + (lon2 - lon1) * frac, lat];\n    }, getTransform(epsg4326Projection, projection), squaredTolerance);\n}\n//# sourceMappingURL=geodesic.js.map"]},"metadata":{},"sourceType":"module"}