{"ast":null,"code":"'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar callBound = require('call-bind/callBound');\n\nvar inspect = require('object-inspect');\n\nvar $TypeError = GetIntrinsic('%TypeError%');\nvar $WeakMap = GetIntrinsic('%WeakMap%', true);\nvar $Map = GetIntrinsic('%Map%', true);\nvar $weakMapGet = callBound('WeakMap.prototype.get', true);\nvar $weakMapSet = callBound('WeakMap.prototype.set', true);\nvar $weakMapHas = callBound('WeakMap.prototype.has', true);\nvar $mapGet = callBound('Map.prototype.get', true);\nvar $mapSet = callBound('Map.prototype.set', true);\nvar $mapHas = callBound('Map.prototype.has', true);\n/*\n * This function traverses the list returning the node corresponding to the\n * given key.\n *\n * That node is also moved to the head of the list, so that if it's accessed\n * again we don't need to traverse the whole list. By doing so, all the recently\n * used nodes can be accessed relatively quickly.\n */\n\nvar listGetNode = function (list, key) {\n  // eslint-disable-line consistent-return\n  for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {\n    if (curr.key === key) {\n      prev.next = curr.next;\n      curr.next = list.next;\n      list.next = curr; // eslint-disable-line no-param-reassign\n\n      return curr;\n    }\n  }\n};\n\nvar listGet = function (objects, key) {\n  var node = listGetNode(objects, key);\n  return node && node.value;\n};\n\nvar listSet = function (objects, key, value) {\n  var node = listGetNode(objects, key);\n\n  if (node) {\n    node.value = value;\n  } else {\n    // Prepend the new node to the beginning of the list\n    objects.next = {\n      // eslint-disable-line no-param-reassign\n      key: key,\n      next: objects.next,\n      value: value\n    };\n  }\n};\n\nvar listHas = function (objects, key) {\n  return !!listGetNode(objects, key);\n};\n\nmodule.exports = function getSideChannel() {\n  var $wm;\n  var $m;\n  var $o;\n  var channel = {\n    assert: function (key) {\n      if (!channel.has(key)) {\n        throw new $TypeError('Side channel does not contain ' + inspect(key));\n      }\n    },\n    get: function (key) {\n      // eslint-disable-line consistent-return\n      if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n        if ($wm) {\n          return $weakMapGet($wm, key);\n        }\n      } else if ($Map) {\n        if ($m) {\n          return $mapGet($m, key);\n        }\n      } else {\n        if ($o) {\n          // eslint-disable-line no-lonely-if\n          return listGet($o, key);\n        }\n      }\n    },\n    has: function (key) {\n      if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n        if ($wm) {\n          return $weakMapHas($wm, key);\n        }\n      } else if ($Map) {\n        if ($m) {\n          return $mapHas($m, key);\n        }\n      } else {\n        if ($o) {\n          // eslint-disable-line no-lonely-if\n          return listHas($o, key);\n        }\n      }\n\n      return false;\n    },\n    set: function (key, value) {\n      if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n        if (!$wm) {\n          $wm = new $WeakMap();\n        }\n\n        $weakMapSet($wm, key, value);\n      } else if ($Map) {\n        if (!$m) {\n          $m = new $Map();\n        }\n\n        $mapSet($m, key, value);\n      } else {\n        if (!$o) {\n          /*\n           * Initialize the linked list as an empty node, so that we don't have\n           * to special-case handling of the first node: we can always refer to\n           * it as (previous node).next, instead of something like (list).head\n           */\n          $o = {\n            key: {},\n            next: null\n          };\n        }\n\n        listSet($o, key, value);\n      }\n    }\n  };\n  return channel;\n};","map":{"version":3,"sources":["/home/dylan/MusicGuessr/a-musical-planet/node_modules/side-channel/index.js"],"names":["GetIntrinsic","require","callBound","inspect","$TypeError","$WeakMap","$Map","$weakMapGet","$weakMapSet","$weakMapHas","$mapGet","$mapSet","$mapHas","listGetNode","list","key","prev","curr","next","listGet","objects","node","value","listSet","listHas","module","exports","getSideChannel","$wm","$m","$o","channel","assert","has","get","set"],"mappings":"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","sourcesContent":["'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\nvar callBound = require('call-bind/callBound');\nvar inspect = require('object-inspect');\n\nvar $TypeError = GetIntrinsic('%TypeError%');\nvar $WeakMap = GetIntrinsic('%WeakMap%', true);\nvar $Map = GetIntrinsic('%Map%', true);\n\nvar $weakMapGet = callBound('WeakMap.prototype.get', true);\nvar $weakMapSet = callBound('WeakMap.prototype.set', true);\nvar $weakMapHas = callBound('WeakMap.prototype.has', true);\nvar $mapGet = callBound('Map.prototype.get', true);\nvar $mapSet = callBound('Map.prototype.set', true);\nvar $mapHas = callBound('Map.prototype.has', true);\n\n/*\n * This function traverses the list returning the node corresponding to the\n * given key.\n *\n * That node is also moved to the head of the list, so that if it's accessed\n * again we don't need to traverse the whole list. By doing so, all the recently\n * used nodes can be accessed relatively quickly.\n */\nvar listGetNode = function (list, key) { // eslint-disable-line consistent-return\n\tfor (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {\n\t\tif (curr.key === key) {\n\t\t\tprev.next = curr.next;\n\t\t\tcurr.next = list.next;\n\t\t\tlist.next = curr; // eslint-disable-line no-param-reassign\n\t\t\treturn curr;\n\t\t}\n\t}\n};\n\nvar listGet = function (objects, key) {\n\tvar node = listGetNode(objects, key);\n\treturn node && node.value;\n};\nvar listSet = function (objects, key, value) {\n\tvar node = listGetNode(objects, key);\n\tif (node) {\n\t\tnode.value = value;\n\t} else {\n\t\t// Prepend the new node to the beginning of the list\n\t\tobjects.next = { // eslint-disable-line no-param-reassign\n\t\t\tkey: key,\n\t\t\tnext: objects.next,\n\t\t\tvalue: value\n\t\t};\n\t}\n};\nvar listHas = function (objects, key) {\n\treturn !!listGetNode(objects, key);\n};\n\nmodule.exports = function getSideChannel() {\n\tvar $wm;\n\tvar $m;\n\tvar $o;\n\tvar channel = {\n\t\tassert: function (key) {\n\t\t\tif (!channel.has(key)) {\n\t\t\t\tthrow new $TypeError('Side channel does not contain ' + inspect(key));\n\t\t\t}\n\t\t},\n\t\tget: function (key) { // eslint-disable-line consistent-return\n\t\t\tif ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n\t\t\t\tif ($wm) {\n\t\t\t\t\treturn $weakMapGet($wm, key);\n\t\t\t\t}\n\t\t\t} else if ($Map) {\n\t\t\t\tif ($m) {\n\t\t\t\t\treturn $mapGet($m, key);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ($o) { // eslint-disable-line no-lonely-if\n\t\t\t\t\treturn listGet($o, key);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\thas: function (key) {\n\t\t\tif ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n\t\t\t\tif ($wm) {\n\t\t\t\t\treturn $weakMapHas($wm, key);\n\t\t\t\t}\n\t\t\t} else if ($Map) {\n\t\t\t\tif ($m) {\n\t\t\t\t\treturn $mapHas($m, key);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ($o) { // eslint-disable-line no-lonely-if\n\t\t\t\t\treturn listHas($o, key);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\tset: function (key, value) {\n\t\t\tif ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\n\t\t\t\tif (!$wm) {\n\t\t\t\t\t$wm = new $WeakMap();\n\t\t\t\t}\n\t\t\t\t$weakMapSet($wm, key, value);\n\t\t\t} else if ($Map) {\n\t\t\t\tif (!$m) {\n\t\t\t\t\t$m = new $Map();\n\t\t\t\t}\n\t\t\t\t$mapSet($m, key, value);\n\t\t\t} else {\n\t\t\t\tif (!$o) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Initialize the linked list as an empty node, so that we don't have\n\t\t\t\t\t * to special-case handling of the first node: we can always refer to\n\t\t\t\t\t * it as (previous node).next, instead of something like (list).head\n\t\t\t\t\t */\n\t\t\t\t\t$o = { key: {}, next: null };\n\t\t\t\t}\n\t\t\t\tlistSet($o, key, value);\n\t\t\t}\n\t\t}\n\t};\n\treturn channel;\n};\n"]},"metadata":{},"sourceType":"script"}