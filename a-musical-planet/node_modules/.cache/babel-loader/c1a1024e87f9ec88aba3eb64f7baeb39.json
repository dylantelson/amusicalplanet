{"ast":null,"code":"/**\n * @module ol/render/canvas/Executor\n */\nimport CanvasInstruction from './Instruction.js';\nimport { TEXT_ALIGN } from './TextBuilder.js';\nimport { WORKER_OFFSCREEN_CANVAS } from '../../has.js';\nimport { apply as applyTransform, compose as composeTransform, create as createTransform, setFromArray as transformSetFromArray } from '../../transform.js';\nimport { createEmpty, createOrUpdate, intersects } from '../../extent.js';\nimport { defaultPadding, defaultTextBaseline, drawImageOrLabel } from '../canvas.js';\nimport { defaultTextAlign, measureAndCacheTextWidth, measureTextHeight, measureTextWidths } from '../canvas.js';\nimport { drawTextOnPath } from '../../geom/flat/textpath.js';\nimport { equals } from '../../array.js';\nimport { lineStringLength } from '../../geom/flat/length.js';\nimport { transform2D } from '../../geom/flat/transform.js';\n/**\n * @typedef {Object} BBox\n * @property {number} minX Minimal x.\n * @property {number} minY Minimal y.\n * @property {number} maxX Maximal x.\n * @property {number} maxY Maximal y\n * @property {*} value Value.\n */\n\n/**\n * @typedef {Object} ImageOrLabelDimensions\n * @property {number} drawImageX DrawImageX.\n * @property {number} drawImageY DrawImageY.\n * @property {number} drawImageW DrawImageW.\n * @property {number} drawImageH DrawImageH.\n * @property {number} originX OriginX.\n * @property {number} originY OriginY.\n * @property {Array<number>} scale Scale.\n * @property {BBox} declutterBox DeclutterBox.\n * @property {import(\"../../transform.js\").Transform} canvasTransform CanvasTransform.\n */\n\n/**\n * @typedef {{0: CanvasRenderingContext2D, 1: number, 2: import(\"../canvas.js\").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement, 3: ImageOrLabelDimensions, 4: number, 5: Array<*>, 6: Array<*>}} ReplayImageOrLabelArgs\n */\n\n/**\n * @template T\n * @typedef {function(import(\"../../Feature.js\").FeatureLike, import(\"../../geom/SimpleGeometry.js\").default): T} FeatureCallback\n */\n\n/**\n * @type {import(\"../../extent.js\").Extent}\n */\n\nvar tmpExtent = createEmpty();\n/** @type {import(\"../../coordinate.js\").Coordinate} */\n\nvar p1 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\n\nvar p2 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\n\nvar p3 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\n\nvar p4 = [];\n/**\n * @param {ReplayImageOrLabelArgs} replayImageOrLabelArgs Arguments to replayImageOrLabel\n * @return {BBox} Declutter bbox.\n */\n\nfunction getDeclutterBox(replayImageOrLabelArgs) {\n  return replayImageOrLabelArgs[3].declutterBox;\n}\n\nvar rtlRegEx = new RegExp(\n/* eslint-disable prettier/prettier */\n'[' + String.fromCharCode(0x00591) + '-' + String.fromCharCode(0x008ff) + String.fromCharCode(0x0fb1d) + '-' + String.fromCharCode(0x0fdff) + String.fromCharCode(0x0fe70) + '-' + String.fromCharCode(0x0fefc) + String.fromCharCode(0x10800) + '-' + String.fromCharCode(0x10fff) + String.fromCharCode(0x1e800) + '-' + String.fromCharCode(0x1efff) + ']'\n/* eslint-enable prettier/prettier */\n);\n/**\n * @param {string} text Text.\n * @param {string} align Alignment.\n * @return {number} Text alignment.\n */\n\nfunction horizontalTextAlign(text, align) {\n  if ((align === 'start' || align === 'end') && !rtlRegEx.test(text)) {\n    align = align === 'start' ? 'left' : 'right';\n  }\n\n  return TEXT_ALIGN[align];\n}\n\nvar Executor = function () {\n  /**\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {boolean} overlaps The replay can have overlapping geometries.\n   * @param {import(\"../canvas.js\").SerializableInstructions} instructions The serializable instructions\n   */\n  function Executor(resolution, pixelRatio, overlaps, instructions) {\n    /**\n     * @protected\n     * @type {boolean}\n     */\n    this.overlaps = overlaps;\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    this.pixelRatio = pixelRatio;\n    /**\n     * @protected\n     * @const\n     * @type {number}\n     */\n\n    this.resolution = resolution;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.alignFill_;\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n\n    this.instructions = instructions.instructions;\n    /**\n     * @protected\n     * @type {Array<number>}\n     */\n\n    this.coordinates = instructions.coordinates;\n    /**\n     * @private\n     * @type {!Object<number,import(\"../../coordinate.js\").Coordinate|Array<import(\"../../coordinate.js\").Coordinate>|Array<Array<import(\"../../coordinate.js\").Coordinate>>>}\n     */\n\n    this.coordinateCache_ = {};\n    /**\n     * @private\n     * @type {!import(\"../../transform.js\").Transform}\n     */\n\n    this.renderedTransform_ = createTransform();\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n\n    this.hitDetectionInstructions = instructions.hitDetectionInstructions;\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n\n    this.pixelCoordinates_ = null;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.viewRotation_ = 0;\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").FillState>}\n     */\n\n    this.fillStates = instructions.fillStates || {};\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").StrokeState>}\n     */\n\n    this.strokeStates = instructions.strokeStates || {};\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").TextState>}\n     */\n\n    this.textStates = instructions.textStates || {};\n    /**\n     * @private\n     * @type {Object<string, Object<string, number>>}\n     */\n\n    this.widths_ = {};\n    /**\n     * @private\n     * @type {Object<string, import(\"../canvas.js\").Label>}\n     */\n\n    this.labels_ = {};\n  }\n  /**\n   * @param {string} text Text.\n   * @param {string} textKey Text style key.\n   * @param {string} fillKey Fill style key.\n   * @param {string} strokeKey Stroke style key.\n   * @return {import(\"../canvas.js\").Label} Label.\n   */\n\n\n  Executor.prototype.createLabel = function (text, textKey, fillKey, strokeKey) {\n    var key = text + textKey + fillKey + strokeKey;\n\n    if (this.labels_[key]) {\n      return this.labels_[key];\n    }\n\n    var strokeState = strokeKey ? this.strokeStates[strokeKey] : null;\n    var fillState = fillKey ? this.fillStates[fillKey] : null;\n    var textState = this.textStates[textKey];\n    var pixelRatio = this.pixelRatio;\n    var scale = [textState.scale[0] * pixelRatio, textState.scale[1] * pixelRatio];\n    var align = horizontalTextAlign(text, textState.textAlign || defaultTextAlign);\n    var strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;\n    var lines = text.split('\\n');\n    var numLines = lines.length;\n    var widths = [];\n    var width = measureTextWidths(textState.font, lines, widths);\n    var lineHeight = measureTextHeight(textState.font);\n    var height = lineHeight * numLines;\n    var renderWidth = width + strokeWidth;\n    var contextInstructions = []; // make canvas 2 pixels wider to account for italic text width measurement errors\n\n    var w = (renderWidth + 2) * scale[0];\n    var h = (height + strokeWidth) * scale[1];\n    /** @type {import(\"../canvas.js\").Label} */\n\n    var label = {\n      width: w < 0 ? Math.floor(w) : Math.ceil(w),\n      height: h < 0 ? Math.floor(h) : Math.ceil(h),\n      contextInstructions: contextInstructions\n    };\n\n    if (scale[0] != 1 || scale[1] != 1) {\n      contextInstructions.push('scale', scale);\n    }\n\n    contextInstructions.push('font', textState.font);\n\n    if (strokeKey) {\n      contextInstructions.push('strokeStyle', strokeState.strokeStyle);\n      contextInstructions.push('lineWidth', strokeWidth);\n      contextInstructions.push('lineCap', strokeState.lineCap);\n      contextInstructions.push('lineJoin', strokeState.lineJoin);\n      contextInstructions.push('miterLimit', strokeState.miterLimit); // eslint-disable-next-line\n\n      var Context = WORKER_OFFSCREEN_CANVAS ? OffscreenCanvasRenderingContext2D : CanvasRenderingContext2D;\n\n      if (Context.prototype.setLineDash) {\n        contextInstructions.push('setLineDash', [strokeState.lineDash]);\n        contextInstructions.push('lineDashOffset', strokeState.lineDashOffset);\n      }\n    }\n\n    if (fillKey) {\n      contextInstructions.push('fillStyle', fillState.fillStyle);\n    }\n\n    contextInstructions.push('textBaseline', 'middle');\n    contextInstructions.push('textAlign', 'center');\n    var leftRight = 0.5 - align;\n    var x = align * renderWidth + leftRight * strokeWidth;\n    var i;\n\n    if (strokeKey) {\n      for (i = 0; i < numLines; ++i) {\n        contextInstructions.push('strokeText', [lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight]);\n      }\n    }\n\n    if (fillKey) {\n      for (i = 0; i < numLines; ++i) {\n        contextInstructions.push('fillText', [lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight]);\n      }\n    }\n\n    this.labels_[key] = label;\n    return label;\n  };\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../coordinate.js\").Coordinate} p1 1st point of the background box.\n   * @param {import(\"../../coordinate.js\").Coordinate} p2 2nd point of the background box.\n   * @param {import(\"../../coordinate.js\").Coordinate} p3 3rd point of the background box.\n   * @param {import(\"../../coordinate.js\").Coordinate} p4 4th point of the background box.\n   * @param {Array<*>} fillInstruction Fill instruction.\n   * @param {Array<*>} strokeInstruction Stroke instruction.\n   */\n\n\n  Executor.prototype.replayTextBackground_ = function (context, p1, p2, p3, p4, fillInstruction, strokeInstruction) {\n    context.beginPath();\n    context.moveTo.apply(context, p1);\n    context.lineTo.apply(context, p2);\n    context.lineTo.apply(context, p3);\n    context.lineTo.apply(context, p4);\n    context.lineTo.apply(context, p1);\n\n    if (fillInstruction) {\n      this.alignFill_ = fillInstruction[2];\n      this.fill_(context);\n    }\n\n    if (strokeInstruction) {\n      this.setStrokeStyle_(context, strokeInstruction);\n      context.stroke();\n    }\n  };\n  /**\n   * @private\n   * @param {number} sheetWidth Width of the sprite sheet.\n   * @param {number} sheetHeight Height of the sprite sheet.\n   * @param {number} centerX X.\n   * @param {number} centerY Y.\n   * @param {number} width Width.\n   * @param {number} height Height.\n   * @param {number} anchorX Anchor X.\n   * @param {number} anchorY Anchor Y.\n   * @param {number} originX Origin X.\n   * @param {number} originY Origin Y.\n   * @param {number} rotation Rotation.\n   * @param {import(\"../../size.js\").Size} scale Scale.\n   * @param {boolean} snapToPixel Snap to pixel.\n   * @param {Array<number>} padding Padding.\n   * @param {boolean} fillStroke Background fill or stroke.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.\n   */\n\n\n  Executor.prototype.calculateImageOrLabelDimensions_ = function (sheetWidth, sheetHeight, centerX, centerY, width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, fillStroke, feature) {\n    anchorX *= scale[0];\n    anchorY *= scale[1];\n    var x = centerX - anchorX;\n    var y = centerY - anchorY;\n    var w = width + originX > sheetWidth ? sheetWidth - originX : width;\n    var h = height + originY > sheetHeight ? sheetHeight - originY : height;\n    var boxW = padding[3] + w * scale[0] + padding[1];\n    var boxH = padding[0] + h * scale[1] + padding[2];\n    var boxX = x - padding[3];\n    var boxY = y - padding[0];\n\n    if (fillStroke || rotation !== 0) {\n      p1[0] = boxX;\n      p4[0] = boxX;\n      p1[1] = boxY;\n      p2[1] = boxY;\n      p2[0] = boxX + boxW;\n      p3[0] = p2[0];\n      p3[1] = boxY + boxH;\n      p4[1] = p3[1];\n    }\n\n    var transform;\n\n    if (rotation !== 0) {\n      transform = composeTransform(createTransform(), centerX, centerY, 1, 1, rotation, -centerX, -centerY);\n      applyTransform(transform, p1);\n      applyTransform(transform, p2);\n      applyTransform(transform, p3);\n      applyTransform(transform, p4);\n      createOrUpdate(Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1]), tmpExtent);\n    } else {\n      createOrUpdate(Math.min(boxX, boxX + boxW), Math.min(boxY, boxY + boxH), Math.max(boxX, boxX + boxW), Math.max(boxY, boxY + boxH), tmpExtent);\n    }\n\n    if (snapToPixel) {\n      x = Math.round(x);\n      y = Math.round(y);\n    }\n\n    return {\n      drawImageX: x,\n      drawImageY: y,\n      drawImageW: w,\n      drawImageH: h,\n      originX: originX,\n      originY: originY,\n      declutterBox: {\n        minX: tmpExtent[0],\n        minY: tmpExtent[1],\n        maxX: tmpExtent[2],\n        maxY: tmpExtent[3],\n        value: feature\n      },\n      canvasTransform: transform,\n      scale: scale\n    };\n  };\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} contextScale Scale of the context.\n   * @param {import(\"../canvas.js\").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.\n   * @param {ImageOrLabelDimensions} dimensions Dimensions.\n   * @param {number} opacity Opacity.\n   * @param {Array<*>} fillInstruction Fill instruction.\n   * @param {Array<*>} strokeInstruction Stroke instruction.\n   * @return {boolean} The image or label was rendered.\n   */\n\n\n  Executor.prototype.replayImageOrLabel_ = function (context, contextScale, imageOrLabel, dimensions, opacity, fillInstruction, strokeInstruction) {\n    var fillStroke = !!(fillInstruction || strokeInstruction);\n    var box = dimensions.declutterBox;\n    var canvas = context.canvas;\n    var strokePadding = strokeInstruction ? strokeInstruction[2] * dimensions.scale[0] / 2 : 0;\n    var intersects = box.minX - strokePadding <= canvas.width / contextScale && box.maxX + strokePadding >= 0 && box.minY - strokePadding <= canvas.height / contextScale && box.maxY + strokePadding >= 0;\n\n    if (intersects) {\n      if (fillStroke) {\n        this.replayTextBackground_(context, p1, p2, p3, p4, fillInstruction, strokeInstruction);\n      }\n\n      drawImageOrLabel(context, dimensions.canvasTransform, opacity, imageOrLabel, dimensions.originX, dimensions.originY, dimensions.drawImageW, dimensions.drawImageH, dimensions.drawImageX, dimensions.drawImageY, dimensions.scale);\n    }\n\n    return true;\n  };\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   */\n\n\n  Executor.prototype.fill_ = function (context) {\n    if (this.alignFill_) {\n      var origin_1 = applyTransform(this.renderedTransform_, [0, 0]);\n      var repeatSize = 512 * this.pixelRatio;\n      context.save();\n      context.translate(origin_1[0] % repeatSize, origin_1[1] % repeatSize);\n      context.rotate(this.viewRotation_);\n    }\n\n    context.fill();\n\n    if (this.alignFill_) {\n      context.restore();\n    }\n  };\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {Array<*>} instruction Instruction.\n   */\n\n\n  Executor.prototype.setStrokeStyle_ = function (context, instruction) {\n    context['strokeStyle'] = instruction[1];\n    context.lineWidth = instruction[2];\n    context.lineCap = instruction[3];\n    context.lineJoin = instruction[4];\n    context.miterLimit = instruction[5];\n\n    if (context.setLineDash) {\n      context.lineDashOffset = instruction[7];\n      context.setLineDash(instruction[6]);\n    }\n  };\n  /**\n   * @private\n   * @param {string} text The text to draw.\n   * @param {string} textKey The key of the text state.\n   * @param {string} strokeKey The key for the stroke state.\n   * @param {string} fillKey The key for the fill state.\n   * @return {{label: import(\"../canvas.js\").Label, anchorX: number, anchorY: number}} The text image and its anchor.\n   */\n\n\n  Executor.prototype.drawLabelWithPointPlacement_ = function (text, textKey, strokeKey, fillKey) {\n    var textState = this.textStates[textKey];\n    var label = this.createLabel(text, textKey, fillKey, strokeKey);\n    var strokeState = this.strokeStates[strokeKey];\n    var pixelRatio = this.pixelRatio;\n    var align = horizontalTextAlign(text, textState.textAlign || defaultTextAlign);\n    var baseline = TEXT_ALIGN[textState.textBaseline || defaultTextBaseline];\n    var strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0; // Remove the 2 pixels we added in createLabel() for the anchor\n\n    var width = label.width / pixelRatio - 2 * textState.scale[0];\n    var anchorX = align * width + 2 * (0.5 - align) * strokeWidth;\n    var anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;\n    return {\n      label: label,\n      anchorX: anchorX,\n      anchorY: anchorY\n    };\n  };\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} contextScale Scale of the context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {Array<*>} instructions Instructions array.\n   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n   * @param {FeatureCallback<T>} [opt_featureCallback] Feature callback.\n   * @param {import(\"../../extent.js\").Extent} [opt_hitExtent] Only check\n   *     features that intersect this extent.\n   * @param {import(\"rbush\").default} [opt_declutterTree] Declutter tree.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n\n\n  Executor.prototype.execute_ = function (context, contextScale, transform, instructions, snapToPixel, opt_featureCallback, opt_hitExtent, opt_declutterTree) {\n    /** @type {Array<number>} */\n    var pixelCoordinates;\n\n    if (this.pixelCoordinates_ && equals(transform, this.renderedTransform_)) {\n      pixelCoordinates = this.pixelCoordinates_;\n    } else {\n      if (!this.pixelCoordinates_) {\n        this.pixelCoordinates_ = [];\n      }\n\n      pixelCoordinates = transform2D(this.coordinates, 0, this.coordinates.length, 2, transform, this.pixelCoordinates_);\n      transformSetFromArray(this.renderedTransform_, transform);\n    }\n\n    var i = 0; // instruction index\n\n    var ii = instructions.length; // end of instructions\n\n    var d = 0; // data index\n\n    var dd; // end of per-instruction data\n\n    var anchorX, anchorY, prevX, prevY, roundX, roundY, image, text, textKey, strokeKey, fillKey;\n    var pendingFill = 0;\n    var pendingStroke = 0;\n    var lastFillInstruction = null;\n    var lastStrokeInstruction = null;\n    var coordinateCache = this.coordinateCache_;\n    var viewRotation = this.viewRotation_;\n    var viewRotationFromTransform = Math.round(Math.atan2(-transform[1], transform[0]) * 1e12) / 1e12;\n    var state = {\n      context: context,\n      pixelRatio: this.pixelRatio,\n      resolution: this.resolution,\n      rotation: viewRotation\n    }; // When the batch size gets too big, performance decreases. 200 is a good\n    // balance between batch size and number of fill/stroke instructions.\n\n    var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;\n    var\n    /** @type {import(\"../../Feature.js\").FeatureLike} */\n    feature;\n    var x, y, currentGeometry;\n\n    while (i < ii) {\n      var instruction = instructions[i];\n      var type = instruction[0];\n\n      switch (type) {\n        case CanvasInstruction.BEGIN_GEOMETRY:\n          feature = instruction[1];\n          currentGeometry = instruction[3];\n\n          if (!feature.getGeometry()) {\n            i = instruction[2];\n          } else if (opt_hitExtent !== undefined && !intersects(opt_hitExtent, currentGeometry.getExtent())) {\n            i =\n            /** @type {number} */\n            instruction[2] + 1;\n          } else {\n            ++i;\n          }\n\n          break;\n\n        case CanvasInstruction.BEGIN_PATH:\n          if (pendingFill > batchSize) {\n            this.fill_(context);\n            pendingFill = 0;\n          }\n\n          if (pendingStroke > batchSize) {\n            context.stroke();\n            pendingStroke = 0;\n          }\n\n          if (!pendingFill && !pendingStroke) {\n            context.beginPath();\n            prevX = NaN;\n            prevY = NaN;\n          }\n\n          ++i;\n          break;\n\n        case CanvasInstruction.CIRCLE:\n          d = instruction[1];\n          var x1 = pixelCoordinates[d];\n          var y1 = pixelCoordinates[d + 1];\n          var x2 = pixelCoordinates[d + 2];\n          var y2 = pixelCoordinates[d + 3];\n          var dx = x2 - x1;\n          var dy = y2 - y1;\n          var r = Math.sqrt(dx * dx + dy * dy);\n          context.moveTo(x1 + r, y1);\n          context.arc(x1, y1, r, 0, 2 * Math.PI, true);\n          ++i;\n          break;\n\n        case CanvasInstruction.CLOSE_PATH:\n          context.closePath();\n          ++i;\n          break;\n\n        case CanvasInstruction.CUSTOM:\n          d = instruction[1];\n          dd = instruction[2];\n          var geometry = instruction[3];\n          var renderer = instruction[4];\n          var fn = instruction.length == 6 ? instruction[5] : undefined;\n          state.geometry = geometry;\n          state.feature = feature;\n\n          if (!(i in coordinateCache)) {\n            coordinateCache[i] = [];\n          }\n\n          var coords = coordinateCache[i];\n\n          if (fn) {\n            fn(pixelCoordinates, d, dd, 2, coords);\n          } else {\n            coords[0] = pixelCoordinates[d];\n            coords[1] = pixelCoordinates[d + 1];\n            coords.length = 2;\n          }\n\n          renderer(coords, state);\n          ++i;\n          break;\n\n        case CanvasInstruction.DRAW_IMAGE:\n          d = instruction[1];\n          dd = instruction[2];\n          image = instruction[3]; // Remaining arguments in DRAW_IMAGE are in alphabetical order\n\n          anchorX = instruction[4];\n          anchorY = instruction[5];\n          var height = instruction[6];\n          var opacity = instruction[7];\n          var originX = instruction[8];\n          var originY = instruction[9];\n          var rotateWithView = instruction[10];\n          var rotation = instruction[11];\n          var scale = instruction[12];\n          var width = instruction[13];\n          var declutterImageWithText = instruction[14];\n\n          if (!image && instruction.length >= 19) {\n            // create label images\n            text = instruction[18];\n            textKey = instruction[19];\n            strokeKey = instruction[20];\n            fillKey = instruction[21];\n            var labelWithAnchor = this.drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey);\n            image = labelWithAnchor.label;\n            instruction[3] = image;\n            var textOffsetX = instruction[22];\n            anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;\n            instruction[4] = anchorX;\n            var textOffsetY = instruction[23];\n            anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;\n            instruction[5] = anchorY;\n            height = image.height;\n            instruction[6] = height;\n            width = image.width;\n            instruction[13] = width;\n          }\n\n          var geometryWidths = void 0;\n\n          if (instruction.length > 24) {\n            geometryWidths = instruction[24];\n          }\n\n          var padding = void 0,\n              backgroundFill = void 0,\n              backgroundStroke = void 0;\n\n          if (instruction.length > 16) {\n            padding = instruction[15];\n            backgroundFill = instruction[16];\n            backgroundStroke = instruction[17];\n          } else {\n            padding = defaultPadding;\n            backgroundFill = false;\n            backgroundStroke = false;\n          }\n\n          if (rotateWithView && viewRotationFromTransform) {\n            // Canvas is expected to be rotated to reverse view rotation.\n            rotation += viewRotation;\n          } else if (!rotateWithView && !viewRotationFromTransform) {\n            // Canvas is not rotated, images need to be rotated back to be north-up.\n            rotation -= viewRotation;\n          }\n\n          var widthIndex = 0;\n\n          for (; d < dd; d += 2) {\n            if (geometryWidths && geometryWidths[widthIndex++] < width / this.pixelRatio) {\n              continue;\n            }\n\n            var dimensions = this.calculateImageOrLabelDimensions_(image.width, image.height, pixelCoordinates[d], pixelCoordinates[d + 1], width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, backgroundFill || backgroundStroke, feature);\n            /** @type {ReplayImageOrLabelArgs} */\n\n            var args = [context, contextScale, image, dimensions, opacity, backgroundFill ? lastFillInstruction : null, backgroundStroke ? lastStrokeInstruction : null];\n            var imageArgs = void 0;\n            var imageDeclutterBox = void 0;\n\n            if (opt_declutterTree && declutterImageWithText) {\n              var index = dd - d;\n\n              if (!declutterImageWithText[index]) {\n                // We now have the image for an image+text combination.\n                declutterImageWithText[index] = args; // Don't render anything for now, wait for the text.\n\n                continue;\n              }\n\n              imageArgs = declutterImageWithText[index];\n              delete declutterImageWithText[index];\n              imageDeclutterBox = getDeclutterBox(imageArgs);\n\n              if (opt_declutterTree.collides(imageDeclutterBox)) {\n                continue;\n              }\n            }\n\n            if (opt_declutterTree && opt_declutterTree.collides(dimensions.declutterBox)) {\n              continue;\n            }\n\n            if (imageArgs) {\n              // We now have image and text for an image+text combination.\n              if (opt_declutterTree) {\n                opt_declutterTree.insert(imageDeclutterBox);\n              } // Render the image before we render the text.\n\n\n              this.replayImageOrLabel_.apply(this, imageArgs);\n            }\n\n            if (opt_declutterTree) {\n              opt_declutterTree.insert(dimensions.declutterBox);\n            }\n\n            this.replayImageOrLabel_.apply(this, args);\n          }\n\n          ++i;\n          break;\n\n        case CanvasInstruction.DRAW_CHARS:\n          var begin = instruction[1];\n          var end = instruction[2];\n          var baseline = instruction[3];\n          var overflow = instruction[4];\n          fillKey = instruction[5];\n          var maxAngle = instruction[6];\n          var measurePixelRatio = instruction[7];\n          var offsetY = instruction[8];\n          strokeKey = instruction[9];\n          var strokeWidth = instruction[10];\n          text = instruction[11];\n          textKey = instruction[12];\n          var pixelRatioScale = [\n            /** @type {number} */\n\n            /** @type {number} */\n          instruction[13], instruction[13]];\n          var textState = this.textStates[textKey];\n          var font = textState.font;\n          var textScale = [textState.scale[0] * measurePixelRatio, textState.scale[1] * measurePixelRatio];\n          var cachedWidths = void 0;\n\n          if (font in this.widths_) {\n            cachedWidths = this.widths_[font];\n          } else {\n            cachedWidths = {};\n            this.widths_[font] = cachedWidths;\n          }\n\n          var pathLength = lineStringLength(pixelCoordinates, begin, end, 2);\n          var textLength = Math.abs(textScale[0]) * measureAndCacheTextWidth(font, text, cachedWidths);\n\n          if (overflow || textLength <= pathLength) {\n            var textAlign = this.textStates[textKey].textAlign;\n            var startM = (pathLength - textLength) * TEXT_ALIGN[textAlign];\n            var parts = drawTextOnPath(pixelCoordinates, begin, end, 2, text, startM, maxAngle, Math.abs(textScale[0]), measureAndCacheTextWidth, font, cachedWidths, viewRotationFromTransform ? 0 : this.viewRotation_);\n\n            drawChars: if (parts) {\n              /** @type {Array<ReplayImageOrLabelArgs>} */\n              var replayImageOrLabelArgs = [];\n              var c = void 0,\n                  cc = void 0,\n                  chars = void 0,\n                  label = void 0,\n                  part = void 0;\n\n              if (strokeKey) {\n                for (c = 0, cc = parts.length; c < cc; ++c) {\n                  part = parts[c]; // x, y, anchorX, rotation, chunk\n\n                  chars = part[4];\n                  label = this.createLabel(chars, textKey, '', strokeKey);\n                  anchorX =\n                  /** @type {number} */\n                  part[2] + (textScale[0] < 0 ? -strokeWidth : strokeWidth);\n                  anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth * textScale[1] / textScale[0] - offsetY;\n                  var dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, defaultPadding, false, feature);\n\n                  if (opt_declutterTree && opt_declutterTree.collides(dimensions.declutterBox)) {\n                    break drawChars;\n                  }\n\n                  replayImageOrLabelArgs.push([context, contextScale, label, dimensions, 1, null, null]);\n                }\n              }\n\n              if (fillKey) {\n                for (c = 0, cc = parts.length; c < cc; ++c) {\n                  part = parts[c]; // x, y, anchorX, rotation, chunk\n\n                  chars = part[4];\n                  label = this.createLabel(chars, textKey, fillKey, '');\n                  anchorX = part[2];\n                  anchorY = baseline * label.height - offsetY;\n                  var dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, defaultPadding, false, feature);\n\n                  if (opt_declutterTree && opt_declutterTree.collides(dimensions.declutterBox)) {\n                    break drawChars;\n                  }\n\n                  replayImageOrLabelArgs.push([context, contextScale, label, dimensions, 1, null, null]);\n                }\n              }\n\n              if (opt_declutterTree) {\n                opt_declutterTree.load(replayImageOrLabelArgs.map(getDeclutterBox));\n              }\n\n              for (var i_1 = 0, ii_1 = replayImageOrLabelArgs.length; i_1 < ii_1; ++i_1) {\n                this.replayImageOrLabel_.apply(this, replayImageOrLabelArgs[i_1]);\n              }\n            }\n          }\n\n          ++i;\n          break;\n\n        case CanvasInstruction.END_GEOMETRY:\n          if (opt_featureCallback !== undefined) {\n            feature = instruction[1];\n            var result = opt_featureCallback(feature, currentGeometry);\n\n            if (result) {\n              return result;\n            }\n          }\n\n          ++i;\n          break;\n\n        case CanvasInstruction.FILL:\n          if (batchSize) {\n            pendingFill++;\n          } else {\n            this.fill_(context);\n          }\n\n          ++i;\n          break;\n\n        case CanvasInstruction.MOVE_TO_LINE_TO:\n          d = instruction[1];\n          dd = instruction[2];\n          x = pixelCoordinates[d];\n          y = pixelCoordinates[d + 1];\n          roundX = x + 0.5 | 0;\n          roundY = y + 0.5 | 0;\n\n          if (roundX !== prevX || roundY !== prevY) {\n            context.moveTo(x, y);\n            prevX = roundX;\n            prevY = roundY;\n          }\n\n          for (d += 2; d < dd; d += 2) {\n            x = pixelCoordinates[d];\n            y = pixelCoordinates[d + 1];\n            roundX = x + 0.5 | 0;\n            roundY = y + 0.5 | 0;\n\n            if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {\n              context.lineTo(x, y);\n              prevX = roundX;\n              prevY = roundY;\n            }\n          }\n\n          ++i;\n          break;\n\n        case CanvasInstruction.SET_FILL_STYLE:\n          lastFillInstruction = instruction;\n          this.alignFill_ = instruction[2];\n\n          if (pendingFill) {\n            this.fill_(context);\n            pendingFill = 0;\n\n            if (pendingStroke) {\n              context.stroke();\n              pendingStroke = 0;\n            }\n          }\n\n          context.fillStyle = instruction[1];\n          ++i;\n          break;\n\n        case CanvasInstruction.SET_STROKE_STYLE:\n          lastStrokeInstruction = instruction;\n\n          if (pendingStroke) {\n            context.stroke();\n            pendingStroke = 0;\n          }\n\n          this.setStrokeStyle_(context, instruction);\n          ++i;\n          break;\n\n        case CanvasInstruction.STROKE:\n          if (batchSize) {\n            pendingStroke++;\n          } else {\n            context.stroke();\n          }\n\n          ++i;\n          break;\n\n        default:\n          ++i; // consume the instruction anyway, to avoid an infinite loop\n\n          break;\n      }\n    }\n\n    if (pendingFill) {\n      this.fill_(context);\n    }\n\n    if (pendingStroke) {\n      context.stroke();\n    }\n\n    return undefined;\n  };\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} contextScale Scale of the context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n   * @param {import(\"rbush\").default} [opt_declutterTree] Declutter tree.\n   */\n\n\n  Executor.prototype.execute = function (context, contextScale, transform, viewRotation, snapToPixel, opt_declutterTree) {\n    this.viewRotation_ = viewRotation;\n    this.execute_(context, contextScale, transform, this.instructions, snapToPixel, undefined, undefined, opt_declutterTree);\n  };\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {FeatureCallback<T>} [opt_featureCallback] Feature callback.\n   * @param {import(\"../../extent.js\").Extent} [opt_hitExtent] Only check\n   *     features that intersect this extent.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n\n\n  Executor.prototype.executeHitDetection = function (context, transform, viewRotation, opt_featureCallback, opt_hitExtent) {\n    this.viewRotation_ = viewRotation;\n    return this.execute_(context, 1, transform, this.hitDetectionInstructions, true, opt_featureCallback, opt_hitExtent);\n  };\n\n  return Executor;\n}();\n\nexport default Executor;","map":{"version":3,"sources":["../../src/render/canvas/Executor.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @module ol/render/canvas/Executor\n */\nimport CanvasInstruction from './Instruction.js';\nimport { TEXT_ALIGN } from './TextBuilder.js';\nimport { WORKER_OFFSCREEN_CANVAS } from '../../has.js';\nimport { apply as applyTransform, compose as composeTransform, create as createTransform, setFromArray as transformSetFromArray, } from '../../transform.js';\nimport { createEmpty, createOrUpdate, intersects } from '../../extent.js';\nimport { defaultPadding, defaultTextBaseline, drawImageOrLabel, } from '../canvas.js';\nimport { defaultTextAlign, measureAndCacheTextWidth, measureTextHeight, measureTextWidths, } from '../canvas.js';\nimport { drawTextOnPath } from '../../geom/flat/textpath.js';\nimport { equals } from '../../array.js';\nimport { lineStringLength } from '../../geom/flat/length.js';\nimport { transform2D } from '../../geom/flat/transform.js';\n/**\n * @typedef {Object} BBox\n * @property {number} minX Minimal x.\n * @property {number} minY Minimal y.\n * @property {number} maxX Maximal x.\n * @property {number} maxY Maximal y\n * @property {*} value Value.\n */\n/**\n * @typedef {Object} ImageOrLabelDimensions\n * @property {number} drawImageX DrawImageX.\n * @property {number} drawImageY DrawImageY.\n * @property {number} drawImageW DrawImageW.\n * @property {number} drawImageH DrawImageH.\n * @property {number} originX OriginX.\n * @property {number} originY OriginY.\n * @property {Array<number>} scale Scale.\n * @property {BBox} declutterBox DeclutterBox.\n * @property {import(\"../../transform.js\").Transform} canvasTransform CanvasTransform.\n */\n/**\n * @typedef {{0: CanvasRenderingContext2D, 1: number, 2: import(\"../canvas.js\").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement, 3: ImageOrLabelDimensions, 4: number, 5: Array<*>, 6: Array<*>}} ReplayImageOrLabelArgs\n */\n/**\n * @template T\n * @typedef {function(import(\"../../Feature.js\").FeatureLike, import(\"../../geom/SimpleGeometry.js\").default): T} FeatureCallback\n */\n/**\n * @type {import(\"../../extent.js\").Extent}\n */\nvar tmpExtent = createEmpty();\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nvar p1 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nvar p2 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nvar p3 = [];\n/** @type {import(\"../../coordinate.js\").Coordinate} */\nvar p4 = [];\n/**\n * @param {ReplayImageOrLabelArgs} replayImageOrLabelArgs Arguments to replayImageOrLabel\n * @return {BBox} Declutter bbox.\n */\nfunction getDeclutterBox(replayImageOrLabelArgs) {\n    return replayImageOrLabelArgs[3].declutterBox;\n}\nvar rtlRegEx = new RegExp(\n/* eslint-disable prettier/prettier */\n'[' +\n    String.fromCharCode(0x00591) + '-' + String.fromCharCode(0x008ff) +\n    String.fromCharCode(0x0fb1d) + '-' + String.fromCharCode(0x0fdff) +\n    String.fromCharCode(0x0fe70) + '-' + String.fromCharCode(0x0fefc) +\n    String.fromCharCode(0x10800) + '-' + String.fromCharCode(0x10fff) +\n    String.fromCharCode(0x1e800) + '-' + String.fromCharCode(0x1efff) +\n    ']'\n/* eslint-enable prettier/prettier */\n);\n/**\n * @param {string} text Text.\n * @param {string} align Alignment.\n * @return {number} Text alignment.\n */\nfunction horizontalTextAlign(text, align) {\n    if ((align === 'start' || align === 'end') && !rtlRegEx.test(text)) {\n        align = align === 'start' ? 'left' : 'right';\n    }\n    return TEXT_ALIGN[align];\n}\nvar Executor = /** @class */ (function () {\n    /**\n     * @param {number} resolution Resolution.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {boolean} overlaps The replay can have overlapping geometries.\n     * @param {import(\"../canvas.js\").SerializableInstructions} instructions The serializable instructions\n     */\n    function Executor(resolution, pixelRatio, overlaps, instructions) {\n        /**\n         * @protected\n         * @type {boolean}\n         */\n        this.overlaps = overlaps;\n        /**\n         * @protected\n         * @type {number}\n         */\n        this.pixelRatio = pixelRatio;\n        /**\n         * @protected\n         * @const\n         * @type {number}\n         */\n        this.resolution = resolution;\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this.alignFill_;\n        /**\n         * @protected\n         * @type {Array<*>}\n         */\n        this.instructions = instructions.instructions;\n        /**\n         * @protected\n         * @type {Array<number>}\n         */\n        this.coordinates = instructions.coordinates;\n        /**\n         * @private\n         * @type {!Object<number,import(\"../../coordinate.js\").Coordinate|Array<import(\"../../coordinate.js\").Coordinate>|Array<Array<import(\"../../coordinate.js\").Coordinate>>>}\n         */\n        this.coordinateCache_ = {};\n        /**\n         * @private\n         * @type {!import(\"../../transform.js\").Transform}\n         */\n        this.renderedTransform_ = createTransform();\n        /**\n         * @protected\n         * @type {Array<*>}\n         */\n        this.hitDetectionInstructions = instructions.hitDetectionInstructions;\n        /**\n         * @private\n         * @type {Array<number>}\n         */\n        this.pixelCoordinates_ = null;\n        /**\n         * @private\n         * @type {number}\n         */\n        this.viewRotation_ = 0;\n        /**\n         * @type {!Object<string, import(\"../canvas.js\").FillState>}\n         */\n        this.fillStates = instructions.fillStates || {};\n        /**\n         * @type {!Object<string, import(\"../canvas.js\").StrokeState>}\n         */\n        this.strokeStates = instructions.strokeStates || {};\n        /**\n         * @type {!Object<string, import(\"../canvas.js\").TextState>}\n         */\n        this.textStates = instructions.textStates || {};\n        /**\n         * @private\n         * @type {Object<string, Object<string, number>>}\n         */\n        this.widths_ = {};\n        /**\n         * @private\n         * @type {Object<string, import(\"../canvas.js\").Label>}\n         */\n        this.labels_ = {};\n    }\n    /**\n     * @param {string} text Text.\n     * @param {string} textKey Text style key.\n     * @param {string} fillKey Fill style key.\n     * @param {string} strokeKey Stroke style key.\n     * @return {import(\"../canvas.js\").Label} Label.\n     */\n    Executor.prototype.createLabel = function (text, textKey, fillKey, strokeKey) {\n        var key = text + textKey + fillKey + strokeKey;\n        if (this.labels_[key]) {\n            return this.labels_[key];\n        }\n        var strokeState = strokeKey ? this.strokeStates[strokeKey] : null;\n        var fillState = fillKey ? this.fillStates[fillKey] : null;\n        var textState = this.textStates[textKey];\n        var pixelRatio = this.pixelRatio;\n        var scale = [\n            textState.scale[0] * pixelRatio,\n            textState.scale[1] * pixelRatio,\n        ];\n        var align = horizontalTextAlign(text, textState.textAlign || defaultTextAlign);\n        var strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;\n        var lines = text.split('\\n');\n        var numLines = lines.length;\n        var widths = [];\n        var width = measureTextWidths(textState.font, lines, widths);\n        var lineHeight = measureTextHeight(textState.font);\n        var height = lineHeight * numLines;\n        var renderWidth = width + strokeWidth;\n        var contextInstructions = [];\n        // make canvas 2 pixels wider to account for italic text width measurement errors\n        var w = (renderWidth + 2) * scale[0];\n        var h = (height + strokeWidth) * scale[1];\n        /** @type {import(\"../canvas.js\").Label} */\n        var label = {\n            width: w < 0 ? Math.floor(w) : Math.ceil(w),\n            height: h < 0 ? Math.floor(h) : Math.ceil(h),\n            contextInstructions: contextInstructions,\n        };\n        if (scale[0] != 1 || scale[1] != 1) {\n            contextInstructions.push('scale', scale);\n        }\n        contextInstructions.push('font', textState.font);\n        if (strokeKey) {\n            contextInstructions.push('strokeStyle', strokeState.strokeStyle);\n            contextInstructions.push('lineWidth', strokeWidth);\n            contextInstructions.push('lineCap', strokeState.lineCap);\n            contextInstructions.push('lineJoin', strokeState.lineJoin);\n            contextInstructions.push('miterLimit', strokeState.miterLimit);\n            // eslint-disable-next-line\n            var Context = WORKER_OFFSCREEN_CANVAS ? OffscreenCanvasRenderingContext2D : CanvasRenderingContext2D;\n            if (Context.prototype.setLineDash) {\n                contextInstructions.push('setLineDash', [strokeState.lineDash]);\n                contextInstructions.push('lineDashOffset', strokeState.lineDashOffset);\n            }\n        }\n        if (fillKey) {\n            contextInstructions.push('fillStyle', fillState.fillStyle);\n        }\n        contextInstructions.push('textBaseline', 'middle');\n        contextInstructions.push('textAlign', 'center');\n        var leftRight = 0.5 - align;\n        var x = align * renderWidth + leftRight * strokeWidth;\n        var i;\n        if (strokeKey) {\n            for (i = 0; i < numLines; ++i) {\n                contextInstructions.push('strokeText', [\n                    lines[i],\n                    x + leftRight * widths[i],\n                    0.5 * (strokeWidth + lineHeight) + i * lineHeight,\n                ]);\n            }\n        }\n        if (fillKey) {\n            for (i = 0; i < numLines; ++i) {\n                contextInstructions.push('fillText', [\n                    lines[i],\n                    x + leftRight * widths[i],\n                    0.5 * (strokeWidth + lineHeight) + i * lineHeight,\n                ]);\n            }\n        }\n        this.labels_[key] = label;\n        return label;\n    };\n    /**\n     * @param {CanvasRenderingContext2D} context Context.\n     * @param {import(\"../../coordinate.js\").Coordinate} p1 1st point of the background box.\n     * @param {import(\"../../coordinate.js\").Coordinate} p2 2nd point of the background box.\n     * @param {import(\"../../coordinate.js\").Coordinate} p3 3rd point of the background box.\n     * @param {import(\"../../coordinate.js\").Coordinate} p4 4th point of the background box.\n     * @param {Array<*>} fillInstruction Fill instruction.\n     * @param {Array<*>} strokeInstruction Stroke instruction.\n     */\n    Executor.prototype.replayTextBackground_ = function (context, p1, p2, p3, p4, fillInstruction, strokeInstruction) {\n        context.beginPath();\n        context.moveTo.apply(context, p1);\n        context.lineTo.apply(context, p2);\n        context.lineTo.apply(context, p3);\n        context.lineTo.apply(context, p4);\n        context.lineTo.apply(context, p1);\n        if (fillInstruction) {\n            this.alignFill_ = /** @type {boolean} */ (fillInstruction[2]);\n            this.fill_(context);\n        }\n        if (strokeInstruction) {\n            this.setStrokeStyle_(context, \n            /** @type {Array<*>} */ (strokeInstruction));\n            context.stroke();\n        }\n    };\n    /**\n     * @private\n     * @param {number} sheetWidth Width of the sprite sheet.\n     * @param {number} sheetHeight Height of the sprite sheet.\n     * @param {number} centerX X.\n     * @param {number} centerY Y.\n     * @param {number} width Width.\n     * @param {number} height Height.\n     * @param {number} anchorX Anchor X.\n     * @param {number} anchorY Anchor Y.\n     * @param {number} originX Origin X.\n     * @param {number} originY Origin Y.\n     * @param {number} rotation Rotation.\n     * @param {import(\"../../size.js\").Size} scale Scale.\n     * @param {boolean} snapToPixel Snap to pixel.\n     * @param {Array<number>} padding Padding.\n     * @param {boolean} fillStroke Background fill or stroke.\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.\n     */\n    Executor.prototype.calculateImageOrLabelDimensions_ = function (sheetWidth, sheetHeight, centerX, centerY, width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, fillStroke, feature) {\n        anchorX *= scale[0];\n        anchorY *= scale[1];\n        var x = centerX - anchorX;\n        var y = centerY - anchorY;\n        var w = width + originX > sheetWidth ? sheetWidth - originX : width;\n        var h = height + originY > sheetHeight ? sheetHeight - originY : height;\n        var boxW = padding[3] + w * scale[0] + padding[1];\n        var boxH = padding[0] + h * scale[1] + padding[2];\n        var boxX = x - padding[3];\n        var boxY = y - padding[0];\n        if (fillStroke || rotation !== 0) {\n            p1[0] = boxX;\n            p4[0] = boxX;\n            p1[1] = boxY;\n            p2[1] = boxY;\n            p2[0] = boxX + boxW;\n            p3[0] = p2[0];\n            p3[1] = boxY + boxH;\n            p4[1] = p3[1];\n        }\n        var transform;\n        if (rotation !== 0) {\n            transform = composeTransform(createTransform(), centerX, centerY, 1, 1, rotation, -centerX, -centerY);\n            applyTransform(transform, p1);\n            applyTransform(transform, p2);\n            applyTransform(transform, p3);\n            applyTransform(transform, p4);\n            createOrUpdate(Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1]), tmpExtent);\n        }\n        else {\n            createOrUpdate(Math.min(boxX, boxX + boxW), Math.min(boxY, boxY + boxH), Math.max(boxX, boxX + boxW), Math.max(boxY, boxY + boxH), tmpExtent);\n        }\n        if (snapToPixel) {\n            x = Math.round(x);\n            y = Math.round(y);\n        }\n        return {\n            drawImageX: x,\n            drawImageY: y,\n            drawImageW: w,\n            drawImageH: h,\n            originX: originX,\n            originY: originY,\n            declutterBox: {\n                minX: tmpExtent[0],\n                minY: tmpExtent[1],\n                maxX: tmpExtent[2],\n                maxY: tmpExtent[3],\n                value: feature,\n            },\n            canvasTransform: transform,\n            scale: scale,\n        };\n    };\n    /**\n     * @private\n     * @param {CanvasRenderingContext2D} context Context.\n     * @param {number} contextScale Scale of the context.\n     * @param {import(\"../canvas.js\").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.\n     * @param {ImageOrLabelDimensions} dimensions Dimensions.\n     * @param {number} opacity Opacity.\n     * @param {Array<*>} fillInstruction Fill instruction.\n     * @param {Array<*>} strokeInstruction Stroke instruction.\n     * @return {boolean} The image or label was rendered.\n     */\n    Executor.prototype.replayImageOrLabel_ = function (context, contextScale, imageOrLabel, dimensions, opacity, fillInstruction, strokeInstruction) {\n        var fillStroke = !!(fillInstruction || strokeInstruction);\n        var box = dimensions.declutterBox;\n        var canvas = context.canvas;\n        var strokePadding = strokeInstruction\n            ? (strokeInstruction[2] * dimensions.scale[0]) / 2\n            : 0;\n        var intersects = box.minX - strokePadding <= canvas.width / contextScale &&\n            box.maxX + strokePadding >= 0 &&\n            box.minY - strokePadding <= canvas.height / contextScale &&\n            box.maxY + strokePadding >= 0;\n        if (intersects) {\n            if (fillStroke) {\n                this.replayTextBackground_(context, p1, p2, p3, p4, \n                /** @type {Array<*>} */ (fillInstruction), \n                /** @type {Array<*>} */ (strokeInstruction));\n            }\n            drawImageOrLabel(context, dimensions.canvasTransform, opacity, imageOrLabel, dimensions.originX, dimensions.originY, dimensions.drawImageW, dimensions.drawImageH, dimensions.drawImageX, dimensions.drawImageY, dimensions.scale);\n        }\n        return true;\n    };\n    /**\n     * @private\n     * @param {CanvasRenderingContext2D} context Context.\n     */\n    Executor.prototype.fill_ = function (context) {\n        if (this.alignFill_) {\n            var origin_1 = applyTransform(this.renderedTransform_, [0, 0]);\n            var repeatSize = 512 * this.pixelRatio;\n            context.save();\n            context.translate(origin_1[0] % repeatSize, origin_1[1] % repeatSize);\n            context.rotate(this.viewRotation_);\n        }\n        context.fill();\n        if (this.alignFill_) {\n            context.restore();\n        }\n    };\n    /**\n     * @private\n     * @param {CanvasRenderingContext2D} context Context.\n     * @param {Array<*>} instruction Instruction.\n     */\n    Executor.prototype.setStrokeStyle_ = function (context, instruction) {\n        context['strokeStyle'] =\n            /** @type {import(\"../../colorlike.js\").ColorLike} */ (instruction[1]);\n        context.lineWidth = /** @type {number} */ (instruction[2]);\n        context.lineCap = /** @type {CanvasLineCap} */ (instruction[3]);\n        context.lineJoin = /** @type {CanvasLineJoin} */ (instruction[4]);\n        context.miterLimit = /** @type {number} */ (instruction[5]);\n        if (context.setLineDash) {\n            context.lineDashOffset = /** @type {number} */ (instruction[7]);\n            context.setLineDash(/** @type {Array<number>} */ (instruction[6]));\n        }\n    };\n    /**\n     * @private\n     * @param {string} text The text to draw.\n     * @param {string} textKey The key of the text state.\n     * @param {string} strokeKey The key for the stroke state.\n     * @param {string} fillKey The key for the fill state.\n     * @return {{label: import(\"../canvas.js\").Label, anchorX: number, anchorY: number}} The text image and its anchor.\n     */\n    Executor.prototype.drawLabelWithPointPlacement_ = function (text, textKey, strokeKey, fillKey) {\n        var textState = this.textStates[textKey];\n        var label = this.createLabel(text, textKey, fillKey, strokeKey);\n        var strokeState = this.strokeStates[strokeKey];\n        var pixelRatio = this.pixelRatio;\n        var align = horizontalTextAlign(text, textState.textAlign || defaultTextAlign);\n        var baseline = TEXT_ALIGN[textState.textBaseline || defaultTextBaseline];\n        var strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;\n        // Remove the 2 pixels we added in createLabel() for the anchor\n        var width = label.width / pixelRatio - 2 * textState.scale[0];\n        var anchorX = align * width + 2 * (0.5 - align) * strokeWidth;\n        var anchorY = (baseline * label.height) / pixelRatio +\n            2 * (0.5 - baseline) * strokeWidth;\n        return {\n            label: label,\n            anchorX: anchorX,\n            anchorY: anchorY,\n        };\n    };\n    /**\n     * @private\n     * @param {CanvasRenderingContext2D} context Context.\n     * @param {number} contextScale Scale of the context.\n     * @param {import(\"../../transform.js\").Transform} transform Transform.\n     * @param {Array<*>} instructions Instructions array.\n     * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n     * @param {FeatureCallback<T>} [opt_featureCallback] Feature callback.\n     * @param {import(\"../../extent.js\").Extent} [opt_hitExtent] Only check\n     *     features that intersect this extent.\n     * @param {import(\"rbush\").default} [opt_declutterTree] Declutter tree.\n     * @return {T|undefined} Callback result.\n     * @template T\n     */\n    Executor.prototype.execute_ = function (context, contextScale, transform, instructions, snapToPixel, opt_featureCallback, opt_hitExtent, opt_declutterTree) {\n        /** @type {Array<number>} */\n        var pixelCoordinates;\n        if (this.pixelCoordinates_ && equals(transform, this.renderedTransform_)) {\n            pixelCoordinates = this.pixelCoordinates_;\n        }\n        else {\n            if (!this.pixelCoordinates_) {\n                this.pixelCoordinates_ = [];\n            }\n            pixelCoordinates = transform2D(this.coordinates, 0, this.coordinates.length, 2, transform, this.pixelCoordinates_);\n            transformSetFromArray(this.renderedTransform_, transform);\n        }\n        var i = 0; // instruction index\n        var ii = instructions.length; // end of instructions\n        var d = 0; // data index\n        var dd; // end of per-instruction data\n        var anchorX, anchorY, prevX, prevY, roundX, roundY, image, text, textKey, strokeKey, fillKey;\n        var pendingFill = 0;\n        var pendingStroke = 0;\n        var lastFillInstruction = null;\n        var lastStrokeInstruction = null;\n        var coordinateCache = this.coordinateCache_;\n        var viewRotation = this.viewRotation_;\n        var viewRotationFromTransform = Math.round(Math.atan2(-transform[1], transform[0]) * 1e12) / 1e12;\n        var state = /** @type {import(\"../../render.js\").State} */ ({\n            context: context,\n            pixelRatio: this.pixelRatio,\n            resolution: this.resolution,\n            rotation: viewRotation,\n        });\n        // When the batch size gets too big, performance decreases. 200 is a good\n        // balance between batch size and number of fill/stroke instructions.\n        var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;\n        var /** @type {import(\"../../Feature.js\").FeatureLike} */ feature;\n        var x, y, currentGeometry;\n        while (i < ii) {\n            var instruction = instructions[i];\n            var type = /** @type {import(\"./Instruction.js\").default} */ (instruction[0]);\n            switch (type) {\n                case CanvasInstruction.BEGIN_GEOMETRY:\n                    feature = /** @type {import(\"../../Feature.js\").FeatureLike} */ (instruction[1]);\n                    currentGeometry = instruction[3];\n                    if (!feature.getGeometry()) {\n                        i = /** @type {number} */ (instruction[2]);\n                    }\n                    else if (opt_hitExtent !== undefined &&\n                        !intersects(opt_hitExtent, currentGeometry.getExtent())) {\n                        i = /** @type {number} */ (instruction[2]) + 1;\n                    }\n                    else {\n                        ++i;\n                    }\n                    break;\n                case CanvasInstruction.BEGIN_PATH:\n                    if (pendingFill > batchSize) {\n                        this.fill_(context);\n                        pendingFill = 0;\n                    }\n                    if (pendingStroke > batchSize) {\n                        context.stroke();\n                        pendingStroke = 0;\n                    }\n                    if (!pendingFill && !pendingStroke) {\n                        context.beginPath();\n                        prevX = NaN;\n                        prevY = NaN;\n                    }\n                    ++i;\n                    break;\n                case CanvasInstruction.CIRCLE:\n                    d = /** @type {number} */ (instruction[1]);\n                    var x1 = pixelCoordinates[d];\n                    var y1 = pixelCoordinates[d + 1];\n                    var x2 = pixelCoordinates[d + 2];\n                    var y2 = pixelCoordinates[d + 3];\n                    var dx = x2 - x1;\n                    var dy = y2 - y1;\n                    var r = Math.sqrt(dx * dx + dy * dy);\n                    context.moveTo(x1 + r, y1);\n                    context.arc(x1, y1, r, 0, 2 * Math.PI, true);\n                    ++i;\n                    break;\n                case CanvasInstruction.CLOSE_PATH:\n                    context.closePath();\n                    ++i;\n                    break;\n                case CanvasInstruction.CUSTOM:\n                    d = /** @type {number} */ (instruction[1]);\n                    dd = instruction[2];\n                    var geometry = \n                    /** @type {import(\"../../geom/SimpleGeometry.js\").default} */ (instruction[3]);\n                    var renderer = instruction[4];\n                    var fn = instruction.length == 6 ? instruction[5] : undefined;\n                    state.geometry = geometry;\n                    state.feature = feature;\n                    if (!(i in coordinateCache)) {\n                        coordinateCache[i] = [];\n                    }\n                    var coords = coordinateCache[i];\n                    if (fn) {\n                        fn(pixelCoordinates, d, dd, 2, coords);\n                    }\n                    else {\n                        coords[0] = pixelCoordinates[d];\n                        coords[1] = pixelCoordinates[d + 1];\n                        coords.length = 2;\n                    }\n                    renderer(coords, state);\n                    ++i;\n                    break;\n                case CanvasInstruction.DRAW_IMAGE:\n                    d = /** @type {number} */ (instruction[1]);\n                    dd = /** @type {number} */ (instruction[2]);\n                    image =\n                        /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */ (instruction[3]);\n                    // Remaining arguments in DRAW_IMAGE are in alphabetical order\n                    anchorX = /** @type {number} */ (instruction[4]);\n                    anchorY = /** @type {number} */ (instruction[5]);\n                    var height = /** @type {number} */ (instruction[6]);\n                    var opacity = /** @type {number} */ (instruction[7]);\n                    var originX = /** @type {number} */ (instruction[8]);\n                    var originY = /** @type {number} */ (instruction[9]);\n                    var rotateWithView = /** @type {boolean} */ (instruction[10]);\n                    var rotation = /** @type {number} */ (instruction[11]);\n                    var scale = /** @type {import(\"../../size.js\").Size} */ (instruction[12]);\n                    var width = /** @type {number} */ (instruction[13]);\n                    var declutterImageWithText = \n                    /** @type {import(\"../canvas.js\").DeclutterImageWithText} */ (instruction[14]);\n                    if (!image && instruction.length >= 19) {\n                        // create label images\n                        text = /** @type {string} */ (instruction[18]);\n                        textKey = /** @type {string} */ (instruction[19]);\n                        strokeKey = /** @type {string} */ (instruction[20]);\n                        fillKey = /** @type {string} */ (instruction[21]);\n                        var labelWithAnchor = this.drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey);\n                        image = labelWithAnchor.label;\n                        instruction[3] = image;\n                        var textOffsetX = /** @type {number} */ (instruction[22]);\n                        anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;\n                        instruction[4] = anchorX;\n                        var textOffsetY = /** @type {number} */ (instruction[23]);\n                        anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;\n                        instruction[5] = anchorY;\n                        height = image.height;\n                        instruction[6] = height;\n                        width = image.width;\n                        instruction[13] = width;\n                    }\n                    var geometryWidths = void 0;\n                    if (instruction.length > 24) {\n                        geometryWidths = /** @type {number} */ (instruction[24]);\n                    }\n                    var padding = void 0, backgroundFill = void 0, backgroundStroke = void 0;\n                    if (instruction.length > 16) {\n                        padding = /** @type {Array<number>} */ (instruction[15]);\n                        backgroundFill = /** @type {boolean} */ (instruction[16]);\n                        backgroundStroke = /** @type {boolean} */ (instruction[17]);\n                    }\n                    else {\n                        padding = defaultPadding;\n                        backgroundFill = false;\n                        backgroundStroke = false;\n                    }\n                    if (rotateWithView && viewRotationFromTransform) {\n                        // Canvas is expected to be rotated to reverse view rotation.\n                        rotation += viewRotation;\n                    }\n                    else if (!rotateWithView && !viewRotationFromTransform) {\n                        // Canvas is not rotated, images need to be rotated back to be north-up.\n                        rotation -= viewRotation;\n                    }\n                    var widthIndex = 0;\n                    for (; d < dd; d += 2) {\n                        if (geometryWidths &&\n                            geometryWidths[widthIndex++] < width / this.pixelRatio) {\n                            continue;\n                        }\n                        var dimensions = this.calculateImageOrLabelDimensions_(image.width, image.height, pixelCoordinates[d], pixelCoordinates[d + 1], width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, backgroundFill || backgroundStroke, feature);\n                        /** @type {ReplayImageOrLabelArgs} */\n                        var args = [\n                            context,\n                            contextScale,\n                            image,\n                            dimensions,\n                            opacity,\n                            backgroundFill\n                                ? /** @type {Array<*>} */ (lastFillInstruction)\n                                : null,\n                            backgroundStroke\n                                ? /** @type {Array<*>} */ (lastStrokeInstruction)\n                                : null,\n                        ];\n                        var imageArgs = void 0;\n                        var imageDeclutterBox = void 0;\n                        if (opt_declutterTree && declutterImageWithText) {\n                            var index = dd - d;\n                            if (!declutterImageWithText[index]) {\n                                // We now have the image for an image+text combination.\n                                declutterImageWithText[index] = args;\n                                // Don't render anything for now, wait for the text.\n                                continue;\n                            }\n                            imageArgs = declutterImageWithText[index];\n                            delete declutterImageWithText[index];\n                            imageDeclutterBox = getDeclutterBox(imageArgs);\n                            if (opt_declutterTree.collides(imageDeclutterBox)) {\n                                continue;\n                            }\n                        }\n                        if (opt_declutterTree &&\n                            opt_declutterTree.collides(dimensions.declutterBox)) {\n                            continue;\n                        }\n                        if (imageArgs) {\n                            // We now have image and text for an image+text combination.\n                            if (opt_declutterTree) {\n                                opt_declutterTree.insert(imageDeclutterBox);\n                            }\n                            // Render the image before we render the text.\n                            this.replayImageOrLabel_.apply(this, imageArgs);\n                        }\n                        if (opt_declutterTree) {\n                            opt_declutterTree.insert(dimensions.declutterBox);\n                        }\n                        this.replayImageOrLabel_.apply(this, args);\n                    }\n                    ++i;\n                    break;\n                case CanvasInstruction.DRAW_CHARS:\n                    var begin = /** @type {number} */ (instruction[1]);\n                    var end = /** @type {number} */ (instruction[2]);\n                    var baseline = /** @type {number} */ (instruction[3]);\n                    var overflow = /** @type {number} */ (instruction[4]);\n                    fillKey = /** @type {string} */ (instruction[5]);\n                    var maxAngle = /** @type {number} */ (instruction[6]);\n                    var measurePixelRatio = /** @type {number} */ (instruction[7]);\n                    var offsetY = /** @type {number} */ (instruction[8]);\n                    strokeKey = /** @type {string} */ (instruction[9]);\n                    var strokeWidth = /** @type {number} */ (instruction[10]);\n                    text = /** @type {string} */ (instruction[11]);\n                    textKey = /** @type {string} */ (instruction[12]);\n                    var pixelRatioScale = [\n                        /** @type {number} */ (instruction[13]),\n                        /** @type {number} */ (instruction[13]),\n                    ];\n                    var textState = this.textStates[textKey];\n                    var font = textState.font;\n                    var textScale = [\n                        textState.scale[0] * measurePixelRatio,\n                        textState.scale[1] * measurePixelRatio,\n                    ];\n                    var cachedWidths = void 0;\n                    if (font in this.widths_) {\n                        cachedWidths = this.widths_[font];\n                    }\n                    else {\n                        cachedWidths = {};\n                        this.widths_[font] = cachedWidths;\n                    }\n                    var pathLength = lineStringLength(pixelCoordinates, begin, end, 2);\n                    var textLength = Math.abs(textScale[0]) *\n                        measureAndCacheTextWidth(font, text, cachedWidths);\n                    if (overflow || textLength <= pathLength) {\n                        var textAlign = this.textStates[textKey].textAlign;\n                        var startM = (pathLength - textLength) * TEXT_ALIGN[textAlign];\n                        var parts = drawTextOnPath(pixelCoordinates, begin, end, 2, text, startM, maxAngle, Math.abs(textScale[0]), measureAndCacheTextWidth, font, cachedWidths, viewRotationFromTransform ? 0 : this.viewRotation_);\n                        drawChars: if (parts) {\n                            /** @type {Array<ReplayImageOrLabelArgs>} */\n                            var replayImageOrLabelArgs = [];\n                            var c = void 0, cc = void 0, chars = void 0, label = void 0, part = void 0;\n                            if (strokeKey) {\n                                for (c = 0, cc = parts.length; c < cc; ++c) {\n                                    part = parts[c]; // x, y, anchorX, rotation, chunk\n                                    chars = /** @type {string} */ (part[4]);\n                                    label = this.createLabel(chars, textKey, '', strokeKey);\n                                    anchorX =\n                                        /** @type {number} */ (part[2]) +\n                                            (textScale[0] < 0 ? -strokeWidth : strokeWidth);\n                                    anchorY =\n                                        baseline * label.height +\n                                            ((0.5 - baseline) * 2 * strokeWidth * textScale[1]) /\n                                                textScale[0] -\n                                            offsetY;\n                                    var dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, defaultPadding, false, feature);\n                                    if (opt_declutterTree &&\n                                        opt_declutterTree.collides(dimensions.declutterBox)) {\n                                        break drawChars;\n                                    }\n                                    replayImageOrLabelArgs.push([\n                                        context,\n                                        contextScale,\n                                        label,\n                                        dimensions,\n                                        1,\n                                        null,\n                                        null,\n                                    ]);\n                                }\n                            }\n                            if (fillKey) {\n                                for (c = 0, cc = parts.length; c < cc; ++c) {\n                                    part = parts[c]; // x, y, anchorX, rotation, chunk\n                                    chars = /** @type {string} */ (part[4]);\n                                    label = this.createLabel(chars, textKey, fillKey, '');\n                                    anchorX = /** @type {number} */ (part[2]);\n                                    anchorY = baseline * label.height - offsetY;\n                                    var dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, defaultPadding, false, feature);\n                                    if (opt_declutterTree &&\n                                        opt_declutterTree.collides(dimensions.declutterBox)) {\n                                        break drawChars;\n                                    }\n                                    replayImageOrLabelArgs.push([\n                                        context,\n                                        contextScale,\n                                        label,\n                                        dimensions,\n                                        1,\n                                        null,\n                                        null,\n                                    ]);\n                                }\n                            }\n                            if (opt_declutterTree) {\n                                opt_declutterTree.load(replayImageOrLabelArgs.map(getDeclutterBox));\n                            }\n                            for (var i_1 = 0, ii_1 = replayImageOrLabelArgs.length; i_1 < ii_1; ++i_1) {\n                                this.replayImageOrLabel_.apply(this, replayImageOrLabelArgs[i_1]);\n                            }\n                        }\n                    }\n                    ++i;\n                    break;\n                case CanvasInstruction.END_GEOMETRY:\n                    if (opt_featureCallback !== undefined) {\n                        feature = /** @type {import(\"../../Feature.js\").FeatureLike} */ (instruction[1]);\n                        var result = opt_featureCallback(feature, currentGeometry);\n                        if (result) {\n                            return result;\n                        }\n                    }\n                    ++i;\n                    break;\n                case CanvasInstruction.FILL:\n                    if (batchSize) {\n                        pendingFill++;\n                    }\n                    else {\n                        this.fill_(context);\n                    }\n                    ++i;\n                    break;\n                case CanvasInstruction.MOVE_TO_LINE_TO:\n                    d = /** @type {number} */ (instruction[1]);\n                    dd = /** @type {number} */ (instruction[2]);\n                    x = pixelCoordinates[d];\n                    y = pixelCoordinates[d + 1];\n                    roundX = (x + 0.5) | 0;\n                    roundY = (y + 0.5) | 0;\n                    if (roundX !== prevX || roundY !== prevY) {\n                        context.moveTo(x, y);\n                        prevX = roundX;\n                        prevY = roundY;\n                    }\n                    for (d += 2; d < dd; d += 2) {\n                        x = pixelCoordinates[d];\n                        y = pixelCoordinates[d + 1];\n                        roundX = (x + 0.5) | 0;\n                        roundY = (y + 0.5) | 0;\n                        if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {\n                            context.lineTo(x, y);\n                            prevX = roundX;\n                            prevY = roundY;\n                        }\n                    }\n                    ++i;\n                    break;\n                case CanvasInstruction.SET_FILL_STYLE:\n                    lastFillInstruction = instruction;\n                    this.alignFill_ = instruction[2];\n                    if (pendingFill) {\n                        this.fill_(context);\n                        pendingFill = 0;\n                        if (pendingStroke) {\n                            context.stroke();\n                            pendingStroke = 0;\n                        }\n                    }\n                    context.fillStyle =\n                        /** @type {import(\"../../colorlike.js\").ColorLike} */ (instruction[1]);\n                    ++i;\n                    break;\n                case CanvasInstruction.SET_STROKE_STYLE:\n                    lastStrokeInstruction = instruction;\n                    if (pendingStroke) {\n                        context.stroke();\n                        pendingStroke = 0;\n                    }\n                    this.setStrokeStyle_(context, /** @type {Array<*>} */ (instruction));\n                    ++i;\n                    break;\n                case CanvasInstruction.STROKE:\n                    if (batchSize) {\n                        pendingStroke++;\n                    }\n                    else {\n                        context.stroke();\n                    }\n                    ++i;\n                    break;\n                default:\n                    ++i; // consume the instruction anyway, to avoid an infinite loop\n                    break;\n            }\n        }\n        if (pendingFill) {\n            this.fill_(context);\n        }\n        if (pendingStroke) {\n            context.stroke();\n        }\n        return undefined;\n    };\n    /**\n     * @param {CanvasRenderingContext2D} context Context.\n     * @param {number} contextScale Scale of the context.\n     * @param {import(\"../../transform.js\").Transform} transform Transform.\n     * @param {number} viewRotation View rotation.\n     * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n     * @param {import(\"rbush\").default} [opt_declutterTree] Declutter tree.\n     */\n    Executor.prototype.execute = function (context, contextScale, transform, viewRotation, snapToPixel, opt_declutterTree) {\n        this.viewRotation_ = viewRotation;\n        this.execute_(context, contextScale, transform, this.instructions, snapToPixel, undefined, undefined, opt_declutterTree);\n    };\n    /**\n     * @param {CanvasRenderingContext2D} context Context.\n     * @param {import(\"../../transform.js\").Transform} transform Transform.\n     * @param {number} viewRotation View rotation.\n     * @param {FeatureCallback<T>} [opt_featureCallback] Feature callback.\n     * @param {import(\"../../extent.js\").Extent} [opt_hitExtent] Only check\n     *     features that intersect this extent.\n     * @return {T|undefined} Callback result.\n     * @template T\n     */\n    Executor.prototype.executeHitDetection = function (context, transform, viewRotation, opt_featureCallback, opt_hitExtent) {\n        this.viewRotation_ = viewRotation;\n        return this.execute_(context, 1, transform, this.hitDetectionInstructions, true, opt_featureCallback, opt_hitExtent);\n    };\n    return Executor;\n}());\nexport default Executor;\n//# sourceMappingURL=Executor.js.map"]},"metadata":{},"sourceType":"module"}