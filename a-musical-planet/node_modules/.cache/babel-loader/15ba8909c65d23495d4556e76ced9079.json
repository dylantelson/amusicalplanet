{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/layer/Graticule\n */\n\n\nimport Collection from '../Collection.js';\nimport EventType from '../render/EventType.js';\nimport Feature from '../Feature.js';\nimport Fill from '../style/Fill.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport LineString from '../geom/LineString.js';\nimport Point from '../geom/Point.js';\nimport Stroke from '../style/Stroke.js';\nimport Style from '../style/Style.js';\nimport Text from '../style/Text.js';\nimport VectorLayer from './Vector.js';\nimport VectorSource from '../source/Vector.js';\nimport { applyTransform, approximatelyEquals, containsCoordinate, containsExtent, equals, getCenter, getHeight, getIntersection, getWidth, intersects, isEmpty, wrapX as wrapExtentX } from '../extent.js';\nimport { assign } from '../obj.js';\nimport { clamp } from '../math.js';\nimport { degreesToStringHDMS } from '../coordinate.js';\nimport { equivalent as equivalentProjection, get as getProjection, getTransform } from '../proj.js';\nimport { getVectorContext } from '../render.js';\nimport { meridian, parallel } from '../geom/flat/geodesic.js';\n/**\n * @type {Stroke}\n * @private\n * @const\n */\n\nvar DEFAULT_STROKE_STYLE = new Stroke({\n  color: 'rgba(0,0,0,0.2)'\n});\n/**\n * @type {Array<number>}\n * @private\n */\n\nvar INTERVALS = [90, 45, 30, 20, 10, 5, 2, 1, 0.5, 0.2, 0.1, 0.05, 0.01, 0.005, 0.002, 0.001];\n/**\n * @typedef {Object} GraticuleLabelDataType\n * @property {Point} geom Geometry.\n * @property {string} text Text.\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {number} [maxLines=100] The maximum number of meridians and\n * parallels from the center of the map. The default value of 100 means that at\n * most 200 meridians and 200 parallels will be displayed. The default value is\n * appropriate for conformal projections like Spherical Mercator. If you\n * increase the value, more lines will be drawn and the drawing performance will\n * decrease.\n * @property {Stroke} [strokeStyle='rgba(0,0,0,0.2)'] The\n * stroke style to use for drawing the graticule. If not provided, a not fully\n * opaque black will be used.\n * @property {number} [targetSize=100] The target size of the graticule cells,\n * in pixels.\n * @property {boolean} [showLabels=false] Render a label with the respective\n * latitude/longitude for each graticule line.\n * @property {function(number):string} [lonLabelFormatter] Label formatter for\n * longitudes. This function is called with the longitude as argument, and\n * should return a formatted string representing the longitude. By default,\n * labels are formatted as degrees, minutes, seconds and hemisphere.\n * @property {function(number):string} [latLabelFormatter] Label formatter for\n * latitudes. This function is called with the latitude as argument, and\n * should return a formatted string representing the latitude. By default,\n * labels are formatted as degrees, minutes, seconds and hemisphere.\n * @property {number} [lonLabelPosition=0] Longitude label position in fractions\n * (0..1) of view extent. 0 means at the bottom of the viewport, 1 means at the\n * top.\n * @property {number} [latLabelPosition=1] Latitude label position in fractions\n * (0..1) of view extent. 0 means at the left of the viewport, 1 means at the\n * right.\n * @property {Text} [lonLabelStyle] Longitude label text\n * style. If not provided, the following style will be used:\n * ```js\n * new Text({\n *   font: '12px Calibri,sans-serif',\n *   textBaseline: 'bottom',\n *   fill: new Fill({\n *     color: 'rgba(0,0,0,1)'\n *   }),\n *   stroke: new Stroke({\n *     color: 'rgba(255,255,255,1)',\n *     width: 3\n *   })\n * });\n * ```\n * Note that the default's `textBaseline` configuration will not work well for\n * `lonLabelPosition` configurations that position labels close to the top of\n * the viewport.\n * @property {Text} [latLabelStyle] Latitude label text style.\n * If not provided, the following style will be used:\n * ```js\n * new Text({\n *   font: '12px Calibri,sans-serif',\n *   textAlign: 'end',\n *   fill: new Fill({\n *     color: 'rgba(0,0,0,1)'\n *   }),\n *   stroke: Stroke({\n *     color: 'rgba(255,255,255,1)',\n *     width: 3\n *   })\n * });\n * ```\n * Note that the default's `textAlign` configuration will not work well for\n * `latLabelPosition` configurations that position labels close to the left of\n * the viewport.\n * @property {Array<number>} [intervals=[90, 45, 30, 20, 10, 5, 2, 1, 0.5, 0.2, 0.1, 0.05, 0.01, 0.005, 0.002, 0.001]]\n * Intervals (in degrees) for the graticule. Example to limit graticules to 30 and 10 degrees intervals:\n * ```js\n * [30, 10]\n * ```\n * @property {boolean} [wrapX=true] Whether to repeat the graticule horizontally.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @classdesc\n * Layer that renders a grid for a coordinate system (currently only EPSG:4326 is supported).\n * Note that the view projection must define both extent and worldExtent.\n *\n * @fires import(\"../render/Event.js\").RenderEvent\n * @extends {VectorLayer<import(\"../source/Vector.js\").default>}\n * @api\n */\n\nvar Graticule = function (_super) {\n  __extends(Graticule, _super);\n  /**\n   * @param {Options} [opt_options] Options.\n   */\n\n\n  function Graticule(opt_options) {\n    var _this = this;\n\n    var options = opt_options ? opt_options : {};\n    var baseOptions = assign({\n      updateWhileAnimating: true,\n      updateWhileInteracting: true,\n      renderBuffer: 0\n    }, options);\n    delete baseOptions.maxLines;\n    delete baseOptions.strokeStyle;\n    delete baseOptions.targetSize;\n    delete baseOptions.showLabels;\n    delete baseOptions.lonLabelFormatter;\n    delete baseOptions.latLabelFormatter;\n    delete baseOptions.lonLabelPosition;\n    delete baseOptions.latLabelPosition;\n    delete baseOptions.lonLabelStyle;\n    delete baseOptions.latLabelStyle;\n    delete baseOptions.intervals;\n    _this = _super.call(this, baseOptions) || this;\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n\n    _this.projection_ = null;\n    /**\n     * @type {number}\n     * @private\n     */\n\n    _this.maxLat_ = Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n\n    _this.maxLon_ = Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n\n    _this.minLat_ = -Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n\n    _this.minLon_ = -Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n\n    _this.maxX_ = Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n\n    _this.maxY_ = Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n\n    _this.minX_ = -Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n\n    _this.minY_ = -Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n\n    _this.targetSize_ = options.targetSize !== undefined ? options.targetSize : 100;\n    /**\n     * @type {number}\n     * @private\n     */\n\n    _this.maxLines_ = options.maxLines !== undefined ? options.maxLines : 100;\n    /**\n     * @type {Array<LineString>}\n     * @private\n     */\n\n    _this.meridians_ = [];\n    /**\n     * @type {Array<LineString>}\n     * @private\n     */\n\n    _this.parallels_ = [];\n    /**\n     * @type {Stroke}\n     * @private\n     */\n\n    _this.strokeStyle_ = options.strokeStyle !== undefined ? options.strokeStyle : DEFAULT_STROKE_STYLE;\n    /**\n     * @type {import(\"../proj.js\").TransformFunction|undefined}\n     * @private\n     */\n\n    _this.fromLonLatTransform_ = undefined;\n    /**\n     * @type {import(\"../proj.js\").TransformFunction|undefined}\n     * @private\n     */\n\n    _this.toLonLatTransform_ = undefined;\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n\n    _this.projectionCenterLonLat_ = null;\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n\n    _this.bottomLeft_ = null;\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n\n    _this.bottomRight_ = null;\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n\n    _this.topLeft_ = null;\n    /**\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n\n    _this.topRight_ = null;\n    /**\n     * @type {Array<GraticuleLabelDataType>}\n     * @private\n     */\n\n    _this.meridiansLabels_ = null;\n    /**\n     * @type {Array<GraticuleLabelDataType>}\n     * @private\n     */\n\n    _this.parallelsLabels_ = null;\n\n    if (options.showLabels) {\n      /**\n       * @type {null|function(number):string}\n       * @private\n       */\n      _this.lonLabelFormatter_ = options.lonLabelFormatter == undefined ? degreesToStringHDMS.bind(_this, 'EW') : options.lonLabelFormatter;\n      /**\n       * @type {function(number):string}\n       * @private\n       */\n\n      _this.latLabelFormatter_ = options.latLabelFormatter == undefined ? degreesToStringHDMS.bind(_this, 'NS') : options.latLabelFormatter;\n      /**\n       * Longitude label position in fractions (0..1) of view extent. 0 means\n       * bottom, 1 means top.\n       * @type {number}\n       * @private\n       */\n\n      _this.lonLabelPosition_ = options.lonLabelPosition == undefined ? 0 : options.lonLabelPosition;\n      /**\n       * Latitude Label position in fractions (0..1) of view extent. 0 means left, 1\n       * means right.\n       * @type {number}\n       * @private\n       */\n\n      _this.latLabelPosition_ = options.latLabelPosition == undefined ? 1 : options.latLabelPosition;\n      /**\n       * @type {Style}\n       * @private\n       */\n\n      _this.lonLabelStyleBase_ = new Style({\n        text: options.lonLabelStyle !== undefined ? options.lonLabelStyle.clone() : new Text({\n          font: '12px Calibri,sans-serif',\n          textBaseline: 'bottom',\n          fill: new Fill({\n            color: 'rgba(0,0,0,1)'\n          }),\n          stroke: new Stroke({\n            color: 'rgba(255,255,255,1)',\n            width: 3\n          })\n        })\n      });\n      /**\n       * @private\n       * @param {import(\"../Feature\").default} feature Feature\n       * @return {Style} style\n       */\n\n      _this.lonLabelStyle_ = function (feature) {\n        var label = feature.get('graticule_label');\n        this.lonLabelStyleBase_.getText().setText(label);\n        return this.lonLabelStyleBase_;\n      }.bind(_this);\n      /**\n       * @type {Style}\n       * @private\n       */\n\n\n      _this.latLabelStyleBase_ = new Style({\n        text: options.latLabelStyle !== undefined ? options.latLabelStyle.clone() : new Text({\n          font: '12px Calibri,sans-serif',\n          textAlign: 'right',\n          fill: new Fill({\n            color: 'rgba(0,0,0,1)'\n          }),\n          stroke: new Stroke({\n            color: 'rgba(255,255,255,1)',\n            width: 3\n          })\n        })\n      });\n      /**\n       * @private\n       * @param {import(\"../Feature\").default} feature Feature\n       * @return {Style} style\n       */\n\n      _this.latLabelStyle_ = function (feature) {\n        var label = feature.get('graticule_label');\n        this.latLabelStyleBase_.getText().setText(label);\n        return this.latLabelStyleBase_;\n      }.bind(_this);\n\n      _this.meridiansLabels_ = [];\n      _this.parallelsLabels_ = [];\n\n      _this.addEventListener(EventType.POSTRENDER, _this.drawLabels_.bind(_this));\n    }\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n\n\n    _this.intervals_ = options.intervals !== undefined ? options.intervals : INTERVALS; // use a source with a custom loader for lines & text\n\n    _this.setSource(new VectorSource({\n      loader: _this.loaderFunction.bind(_this),\n      strategy: _this.strategyFunction.bind(_this),\n      features: new Collection(),\n      overlaps: false,\n      useSpatialIndex: false,\n      wrapX: options.wrapX\n    }));\n    /**\n     * feature pool to use when updating graticule\n     * @type {Array<Feature>}\n     * @private\n     */\n\n\n    _this.featurePool_ = [];\n    /**\n     * @type {Style}\n     * @private\n     */\n\n    _this.lineStyle_ = new Style({\n      stroke: _this.strokeStyle_\n    });\n    /**\n     * @type {?import(\"../extent.js\").Extent}\n     * @private\n     */\n\n    _this.loadedExtent_ = null;\n    /**\n     * @type {?import(\"../extent.js\").Extent}\n     */\n\n    _this.renderedExtent_ = null;\n\n    _this.setRenderOrder(null);\n\n    return _this;\n  }\n  /**\n   * Strategy function for loading features based on the view's extent and\n   * resolution.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @return {Array<import(\"../extent.js\").Extent>} Extents.\n   */\n\n\n  Graticule.prototype.strategyFunction = function (extent, resolution) {\n    // extents may be passed in different worlds, to avoid endless loop we use only one\n    var realWorldExtent = extent.slice();\n\n    if (this.projection_ && this.getSource().getWrapX()) {\n      wrapExtentX(realWorldExtent, this.projection_);\n    }\n\n    if (this.loadedExtent_) {\n      if (approximatelyEquals(this.loadedExtent_, realWorldExtent, resolution)) {\n        // make sure result is exactly equal to previous extent\n        realWorldExtent = this.loadedExtent_.slice();\n      } else {\n        // we should not keep track of loaded extents\n        this.getSource().removeLoadedExtent(this.loadedExtent_);\n      }\n    }\n\n    return [realWorldExtent];\n  };\n  /**\n   * Update geometries in the source based on current view\n   * @param {import(\"../extent\").Extent} extent Extent\n   * @param {number} resolution Resolution\n   * @param {import(\"../proj/Projection.js\").default} projection Projection\n   */\n\n\n  Graticule.prototype.loaderFunction = function (extent, resolution, projection) {\n    this.loadedExtent_ = extent;\n    var source = this.getSource(); // only consider the intersection between our own extent & the requested one\n\n    var layerExtent = this.getExtent() || [-Infinity, -Infinity, Infinity, Infinity];\n    var renderExtent = getIntersection(layerExtent, extent);\n\n    if (this.renderedExtent_ && equals(this.renderedExtent_, renderExtent)) {\n      return;\n    }\n\n    this.renderedExtent_ = renderExtent; // bail out if nothing to render\n\n    if (isEmpty(renderExtent)) {\n      return;\n    } // update projection info\n\n\n    var center = getCenter(renderExtent);\n    var squaredTolerance = resolution * resolution / 4;\n    var updateProjectionInfo = !this.projection_ || !equivalentProjection(this.projection_, projection);\n\n    if (updateProjectionInfo) {\n      this.updateProjectionInfo_(projection);\n    }\n\n    this.createGraticule_(renderExtent, center, resolution, squaredTolerance); // first make sure we have enough features in the pool\n\n    var featureCount = this.meridians_.length + this.parallels_.length;\n\n    if (this.meridiansLabels_) {\n      featureCount += this.meridians_.length;\n    }\n\n    if (this.parallelsLabels_) {\n      featureCount += this.parallels_.length;\n    }\n\n    var feature;\n\n    while (featureCount > this.featurePool_.length) {\n      feature = new Feature();\n      this.featurePool_.push(feature);\n    }\n\n    var featuresColl = source.getFeaturesCollection();\n    featuresColl.clear();\n    var poolIndex = 0; // add features for the lines & labels\n\n    var i, l;\n\n    for (i = 0, l = this.meridians_.length; i < l; ++i) {\n      feature = this.featurePool_[poolIndex++];\n      feature.setGeometry(this.meridians_[i]);\n      feature.setStyle(this.lineStyle_);\n      featuresColl.push(feature);\n    }\n\n    for (i = 0, l = this.parallels_.length; i < l; ++i) {\n      feature = this.featurePool_[poolIndex++];\n      feature.setGeometry(this.parallels_[i]);\n      feature.setStyle(this.lineStyle_);\n      featuresColl.push(feature);\n    }\n  };\n  /**\n   * @param {number} lon Longitude.\n   * @param {number} minLat Minimal latitude.\n   * @param {number} maxLat Maximal latitude.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} index Index.\n   * @return {number} Index.\n   * @private\n   */\n\n\n  Graticule.prototype.addMeridian_ = function (lon, minLat, maxLat, squaredTolerance, extent, index) {\n    var lineString = this.getMeridian_(lon, minLat, maxLat, squaredTolerance, index);\n\n    if (intersects(lineString.getExtent(), extent)) {\n      if (this.meridiansLabels_) {\n        var text = this.lonLabelFormatter_(lon);\n\n        if (index in this.meridiansLabels_) {\n          this.meridiansLabels_[index].text = text;\n        } else {\n          this.meridiansLabels_[index] = {\n            geom: new Point([]),\n            text: text\n          };\n        }\n      }\n\n      this.meridians_[index++] = lineString;\n    }\n\n    return index;\n  };\n  /**\n   * @param {number} lat Latitude.\n   * @param {number} minLon Minimal longitude.\n   * @param {number} maxLon Maximal longitude.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} index Index.\n   * @return {number} Index.\n   * @private\n   */\n\n\n  Graticule.prototype.addParallel_ = function (lat, minLon, maxLon, squaredTolerance, extent, index) {\n    var lineString = this.getParallel_(lat, minLon, maxLon, squaredTolerance, index);\n\n    if (intersects(lineString.getExtent(), extent)) {\n      if (this.parallelsLabels_) {\n        var text = this.latLabelFormatter_(lat);\n\n        if (index in this.parallelsLabels_) {\n          this.parallelsLabels_[index].text = text;\n        } else {\n          this.parallelsLabels_[index] = {\n            geom: new Point([]),\n            text: text\n          };\n        }\n      }\n\n      this.parallels_[index++] = lineString;\n    }\n\n    return index;\n  };\n  /**\n   * @param {import(\"../render/Event.js\").default} event Render event.\n   * @private\n   */\n\n\n  Graticule.prototype.drawLabels_ = function (event) {\n    var rotation = event.frameState.viewState.rotation;\n    var extent = event.frameState.extent;\n    var rotationCenter = getCenter(extent);\n    var rotationExtent = extent;\n\n    if (rotation) {\n      var width = getWidth(extent);\n      var height = getHeight(extent);\n      var cr = Math.abs(Math.cos(rotation));\n      var sr = Math.abs(Math.sin(rotation));\n      var unrotatedWidth = (sr * height - cr * width) / (sr * sr - cr * cr);\n      var unrotatedHeight = (sr * width - cr * height) / (sr * sr - cr * cr);\n      rotationExtent = [rotationCenter[0] - unrotatedWidth / 2, rotationCenter[1] - unrotatedHeight / 2, rotationCenter[0] + unrotatedWidth / 2, rotationCenter[1] + unrotatedHeight / 2];\n    }\n\n    var startWorld = 0;\n    var endWorld = 0;\n    var labelsAtStart = this.latLabelPosition_ < 0.5;\n    var projectionExtent = this.projection_.getExtent();\n    var worldWidth = getWidth(projectionExtent);\n\n    if (this.getSource().getWrapX() && this.projection_.canWrapX() && !containsExtent(projectionExtent, extent)) {\n      startWorld = Math.floor((extent[0] - projectionExtent[0]) / worldWidth);\n      endWorld = Math.ceil((extent[2] - projectionExtent[2]) / worldWidth);\n      var inverted = Math.abs(rotation) > Math.PI / 2;\n      labelsAtStart = labelsAtStart !== inverted;\n    }\n\n    var vectorContext = getVectorContext(event);\n\n    for (var world = startWorld; world <= endWorld; ++world) {\n      var poolIndex = this.meridians_.length + this.parallels_.length;\n      var feature = void 0,\n          index = void 0,\n          l = void 0,\n          textPoint = void 0;\n\n      if (this.meridiansLabels_) {\n        for (index = 0, l = this.meridiansLabels_.length; index < l; ++index) {\n          var lineString = this.meridians_[index];\n\n          if (!rotation && world === 0) {\n            textPoint = this.getMeridianPoint_(lineString, extent, index);\n          } else {\n            var clone = lineString.clone();\n            clone.translate(world * worldWidth, 0);\n            clone.rotate(-rotation, rotationCenter);\n            textPoint = this.getMeridianPoint_(clone, rotationExtent, index);\n            textPoint.rotate(rotation, rotationCenter);\n          }\n\n          feature = this.featurePool_[poolIndex++];\n          feature.setGeometry(textPoint);\n          feature.set('graticule_label', this.meridiansLabels_[index].text);\n          vectorContext.drawFeature(feature, this.lonLabelStyle_(feature));\n        }\n      }\n\n      if (this.parallelsLabels_) {\n        if (world === startWorld && labelsAtStart || world === endWorld && !labelsAtStart) {\n          for (index = 0, l = this.parallels_.length; index < l; ++index) {\n            var lineString = this.parallels_[index];\n\n            if (!rotation && world === 0) {\n              textPoint = this.getParallelPoint_(lineString, extent, index);\n            } else {\n              var clone = lineString.clone();\n              clone.translate(world * worldWidth, 0);\n              clone.rotate(-rotation, rotationCenter);\n              textPoint = this.getParallelPoint_(clone, rotationExtent, index);\n              textPoint.rotate(rotation, rotationCenter);\n            }\n\n            feature = this.featurePool_[poolIndex++];\n            feature.setGeometry(textPoint);\n            feature.set('graticule_label', this.parallelsLabels_[index].text);\n            vectorContext.drawFeature(feature, this.latLabelStyle_(feature));\n          }\n        }\n      }\n    }\n  };\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {import(\"../coordinate.js\").Coordinate} center Center.\n   * @param {number} resolution Resolution.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @private\n   */\n\n\n  Graticule.prototype.createGraticule_ = function (extent, center, resolution, squaredTolerance) {\n    var interval = this.getInterval_(resolution);\n\n    if (interval == -1) {\n      this.meridians_.length = 0;\n      this.parallels_.length = 0;\n\n      if (this.meridiansLabels_) {\n        this.meridiansLabels_.length = 0;\n      }\n\n      if (this.parallelsLabels_) {\n        this.parallelsLabels_.length = 0;\n      }\n\n      return;\n    }\n\n    var wrapX = false;\n    var projectionExtent = this.projection_.getExtent();\n    var worldWidth = getWidth(projectionExtent);\n\n    if (this.getSource().getWrapX() && this.projection_.canWrapX() && !containsExtent(projectionExtent, extent)) {\n      if (getWidth(extent) >= worldWidth) {\n        extent[0] = projectionExtent[0];\n        extent[2] = projectionExtent[2];\n      } else {\n        wrapX = true;\n      }\n    } // Constrain the center to fit into the extent available to the graticule\n\n\n    var validCenterP = [clamp(center[0], this.minX_, this.maxX_), clamp(center[1], this.minY_, this.maxY_)]; // Transform the center to lon lat\n    // Some projections may have a void area at the poles\n    // so replace any NaN latitudes with the min or max value closest to a pole\n\n    var centerLonLat = this.toLonLatTransform_(validCenterP);\n\n    if (isNaN(centerLonLat[1])) {\n      centerLonLat[1] = Math.abs(this.maxLat_) >= Math.abs(this.minLat_) ? this.maxLat_ : this.minLat_;\n    }\n\n    var centerLon = clamp(centerLonLat[0], this.minLon_, this.maxLon_);\n    var centerLat = clamp(centerLonLat[1], this.minLat_, this.maxLat_);\n    var maxLines = this.maxLines_;\n    var cnt, idx, lat, lon; // Limit the extent to fit into the extent available to the graticule\n\n    var validExtentP = extent;\n\n    if (!wrapX) {\n      validExtentP = [clamp(extent[0], this.minX_, this.maxX_), clamp(extent[1], this.minY_, this.maxY_), clamp(extent[2], this.minX_, this.maxX_), clamp(extent[3], this.minY_, this.maxY_)];\n    } // Transform the extent to get the lon lat ranges for the edges of the extent\n\n\n    var validExtent = applyTransform(validExtentP, this.toLonLatTransform_, undefined, 8);\n    var maxLat = validExtent[3];\n    var maxLon = validExtent[2];\n    var minLat = validExtent[1];\n    var minLon = validExtent[0];\n\n    if (!wrapX) {\n      // Check if extremities of the world extent lie inside the extent\n      // (for example the pole in a polar projection)\n      // and extend the extent as appropriate\n      if (containsCoordinate(validExtentP, this.bottomLeft_)) {\n        minLon = this.minLon_;\n        minLat = this.minLat_;\n      }\n\n      if (containsCoordinate(validExtentP, this.bottomRight_)) {\n        maxLon = this.maxLon_;\n        minLat = this.minLat_;\n      }\n\n      if (containsCoordinate(validExtentP, this.topLeft_)) {\n        minLon = this.minLon_;\n        maxLat = this.maxLat_;\n      }\n\n      if (containsCoordinate(validExtentP, this.topRight_)) {\n        maxLon = this.maxLon_;\n        maxLat = this.maxLat_;\n      } // The transformed center may also extend the lon lat ranges used for rendering\n\n\n      maxLat = clamp(maxLat, centerLat, this.maxLat_);\n      maxLon = clamp(maxLon, centerLon, this.maxLon_);\n      minLat = clamp(minLat, this.minLat_, centerLat);\n      minLon = clamp(minLon, this.minLon_, centerLon);\n    } // Create meridians\n\n\n    centerLon = Math.floor(centerLon / interval) * interval;\n    lon = clamp(centerLon, this.minLon_, this.maxLon_);\n    idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, 0);\n    cnt = 0;\n\n    if (wrapX) {\n      while ((lon -= interval) >= minLon && cnt++ < maxLines) {\n        idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);\n      }\n    } else {\n      while (lon != this.minLon_ && cnt++ < maxLines) {\n        lon = Math.max(lon - interval, this.minLon_);\n        idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);\n      }\n    }\n\n    lon = clamp(centerLon, this.minLon_, this.maxLon_);\n    cnt = 0;\n\n    if (wrapX) {\n      while ((lon += interval) <= maxLon && cnt++ < maxLines) {\n        idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);\n      }\n    } else {\n      while (lon != this.maxLon_ && cnt++ < maxLines) {\n        lon = Math.min(lon + interval, this.maxLon_);\n        idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);\n      }\n    }\n\n    this.meridians_.length = idx;\n\n    if (this.meridiansLabels_) {\n      this.meridiansLabels_.length = idx;\n    } // Create parallels\n\n\n    centerLat = Math.floor(centerLat / interval) * interval;\n    lat = clamp(centerLat, this.minLat_, this.maxLat_);\n    idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, 0);\n    cnt = 0;\n\n    while (lat != this.minLat_ && cnt++ < maxLines) {\n      lat = Math.max(lat - interval, this.minLat_);\n      idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, idx);\n    }\n\n    lat = clamp(centerLat, this.minLat_, this.maxLat_);\n    cnt = 0;\n\n    while (lat != this.maxLat_ && cnt++ < maxLines) {\n      lat = Math.min(lat + interval, this.maxLat_);\n      idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, idx);\n    }\n\n    this.parallels_.length = idx;\n\n    if (this.parallelsLabels_) {\n      this.parallelsLabels_.length = idx;\n    }\n  };\n  /**\n   * @param {number} resolution Resolution.\n   * @return {number} The interval in degrees.\n   * @private\n   */\n\n\n  Graticule.prototype.getInterval_ = function (resolution) {\n    var centerLon = this.projectionCenterLonLat_[0];\n    var centerLat = this.projectionCenterLonLat_[1];\n    var interval = -1;\n    var target = Math.pow(this.targetSize_ * resolution, 2);\n    /** @type {Array<number>} **/\n\n    var p1 = [];\n    /** @type {Array<number>} **/\n\n    var p2 = [];\n\n    for (var i = 0, ii = this.intervals_.length; i < ii; ++i) {\n      var delta = clamp(this.intervals_[i] / 2, 0, 90); // Don't attempt to transform latitudes beyond the poles!\n\n      var clampedLat = clamp(centerLat, -90 + delta, 90 - delta);\n      p1[0] = centerLon - delta;\n      p1[1] = clampedLat - delta;\n      p2[0] = centerLon + delta;\n      p2[1] = clampedLat + delta;\n      this.fromLonLatTransform_(p1, p1);\n      this.fromLonLatTransform_(p2, p2);\n      var dist = Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2);\n\n      if (dist <= target) {\n        break;\n      }\n\n      interval = this.intervals_[i];\n    }\n\n    return interval;\n  };\n  /**\n   * @param {number} lon Longitude.\n   * @param {number} minLat Minimal latitude.\n   * @param {number} maxLat Maximal latitude.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {LineString} The meridian line string.\n   * @param {number} index Index.\n   * @private\n   */\n\n\n  Graticule.prototype.getMeridian_ = function (lon, minLat, maxLat, squaredTolerance, index) {\n    var flatCoordinates = meridian(lon, minLat, maxLat, this.projection_, squaredTolerance);\n    var lineString = this.meridians_[index];\n\n    if (!lineString) {\n      lineString = new LineString(flatCoordinates, GeometryLayout.XY);\n      this.meridians_[index] = lineString;\n    } else {\n      lineString.setFlatCoordinates(GeometryLayout.XY, flatCoordinates);\n      lineString.changed();\n    }\n\n    return lineString;\n  };\n  /**\n   * @param {LineString} lineString Meridian\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} index Index.\n   * @return {Point} Meridian point.\n   * @private\n   */\n\n\n  Graticule.prototype.getMeridianPoint_ = function (lineString, extent, index) {\n    var flatCoordinates = lineString.getFlatCoordinates();\n    var bottom = 1;\n    var top = flatCoordinates.length - 1;\n\n    if (flatCoordinates[bottom] > flatCoordinates[top]) {\n      bottom = top;\n      top = 1;\n    }\n\n    var clampedBottom = Math.max(extent[1], flatCoordinates[bottom]);\n    var clampedTop = Math.min(extent[3], flatCoordinates[top]);\n    var lat = clamp(extent[1] + Math.abs(extent[1] - extent[3]) * this.lonLabelPosition_, clampedBottom, clampedTop);\n    var coordinate0 = flatCoordinates[bottom - 1] + (flatCoordinates[top - 1] - flatCoordinates[bottom - 1]) * (lat - flatCoordinates[bottom]) / (flatCoordinates[top] - flatCoordinates[bottom]);\n    var coordinate = [coordinate0, lat];\n    var point = this.meridiansLabels_[index].geom;\n    point.setCoordinates(coordinate);\n    return point;\n  };\n  /**\n   * Get the list of meridians.  Meridians are lines of equal longitude.\n   * @return {Array<LineString>} The meridians.\n   * @api\n   */\n\n\n  Graticule.prototype.getMeridians = function () {\n    return this.meridians_;\n  };\n  /**\n   * @param {number} lat Latitude.\n   * @param {number} minLon Minimal longitude.\n   * @param {number} maxLon Maximal longitude.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {LineString} The parallel line string.\n   * @param {number} index Index.\n   * @private\n   */\n\n\n  Graticule.prototype.getParallel_ = function (lat, minLon, maxLon, squaredTolerance, index) {\n    var flatCoordinates = parallel(lat, minLon, maxLon, this.projection_, squaredTolerance);\n    var lineString = this.parallels_[index];\n\n    if (!lineString) {\n      lineString = new LineString(flatCoordinates, GeometryLayout.XY);\n    } else {\n      lineString.setFlatCoordinates(GeometryLayout.XY, flatCoordinates);\n      lineString.changed();\n    }\n\n    return lineString;\n  };\n  /**\n   * @param {LineString} lineString Parallels.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} index Index.\n   * @return {Point} Parallel point.\n   * @private\n   */\n\n\n  Graticule.prototype.getParallelPoint_ = function (lineString, extent, index) {\n    var flatCoordinates = lineString.getFlatCoordinates();\n    var left = 0;\n    var right = flatCoordinates.length - 2;\n\n    if (flatCoordinates[left] > flatCoordinates[right]) {\n      left = right;\n      right = 0;\n    }\n\n    var clampedLeft = Math.max(extent[0], flatCoordinates[left]);\n    var clampedRight = Math.min(extent[2], flatCoordinates[right]);\n    var lon = clamp(extent[0] + Math.abs(extent[0] - extent[2]) * this.latLabelPosition_, clampedLeft, clampedRight);\n    var coordinate1 = flatCoordinates[left + 1] + (flatCoordinates[right + 1] - flatCoordinates[left + 1]) * (lon - flatCoordinates[left]) / (flatCoordinates[right] - flatCoordinates[left]);\n    var coordinate = [lon, coordinate1];\n    var point = this.parallelsLabels_[index].geom;\n    point.setCoordinates(coordinate);\n    return point;\n  };\n  /**\n   * Get the list of parallels.  Parallels are lines of equal latitude.\n   * @return {Array<LineString>} The parallels.\n   * @api\n   */\n\n\n  Graticule.prototype.getParallels = function () {\n    return this.parallels_;\n  };\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n\n\n  Graticule.prototype.updateProjectionInfo_ = function (projection) {\n    var epsg4326Projection = getProjection('EPSG:4326');\n    var worldExtent = projection.getWorldExtent();\n    this.maxLat_ = worldExtent[3];\n    this.maxLon_ = worldExtent[2];\n    this.minLat_ = worldExtent[1];\n    this.minLon_ = worldExtent[0]; // If the world extent crosses the dateline define a custom transform to\n    // return longitudes which wrap the dateline\n\n    var toLonLatTransform = getTransform(projection, epsg4326Projection);\n\n    if (this.minLon_ < this.maxLon_) {\n      this.toLonLatTransform_ = toLonLatTransform;\n    } else {\n      var split_1 = this.minLon_ + this.maxLon_ / 2;\n      this.maxLon_ += 360;\n\n      this.toLonLatTransform_ = function (coordinates, opt_output, opt_dimension) {\n        var dimension = opt_dimension || 2;\n        var lonLatCoordinates = toLonLatTransform(coordinates, opt_output, dimension);\n\n        for (var i = 0, l = lonLatCoordinates.length; i < l; i += dimension) {\n          if (lonLatCoordinates[i] < split_1) {\n            lonLatCoordinates[i] += 360;\n          }\n        }\n\n        return lonLatCoordinates;\n      };\n    } // Transform the extent to get the limits of the view projection extent\n    // which should be available to the graticule\n\n\n    this.fromLonLatTransform_ = getTransform(epsg4326Projection, projection);\n    var worldExtentP = applyTransform([this.minLon_, this.minLat_, this.maxLon_, this.maxLat_], this.fromLonLatTransform_, undefined, 8);\n    this.minX_ = worldExtentP[0];\n    this.maxX_ = worldExtentP[2];\n    this.minY_ = worldExtentP[1];\n    this.maxY_ = worldExtentP[3]; // Determine the view projection coordinates of the extremities of the world extent\n    // as these may lie inside a view extent (for example the pole in a polar projection)\n\n    this.bottomLeft_ = this.fromLonLatTransform_([this.minLon_, this.minLat_]);\n    this.bottomRight_ = this.fromLonLatTransform_([this.maxLon_, this.minLat_]);\n    this.topLeft_ = this.fromLonLatTransform_([this.minLon_, this.maxLat_]);\n    this.topRight_ = this.fromLonLatTransform_([this.maxLon_, this.maxLat_]); // Transform the projection center to lon lat\n    // Some projections may have a void area at the poles\n    // so replace any NaN latitudes with the min or max value closest to a pole\n\n    this.projectionCenterLonLat_ = this.toLonLatTransform_(getCenter(projection.getExtent()));\n\n    if (isNaN(this.projectionCenterLonLat_[1])) {\n      this.projectionCenterLonLat_[1] = Math.abs(this.maxLat_) >= Math.abs(this.minLat_) ? this.maxLat_ : this.minLat_;\n    }\n\n    this.projection_ = projection;\n  };\n\n  return Graticule;\n}(VectorLayer);\n\nexport default Graticule;","map":{"version":3,"sources":["../src/layer/Graticule.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/layer/Graticule\n */\nimport Collection from '../Collection.js';\nimport EventType from '../render/EventType.js';\nimport Feature from '../Feature.js';\nimport Fill from '../style/Fill.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport LineString from '../geom/LineString.js';\nimport Point from '../geom/Point.js';\nimport Stroke from '../style/Stroke.js';\nimport Style from '../style/Style.js';\nimport Text from '../style/Text.js';\nimport VectorLayer from './Vector.js';\nimport VectorSource from '../source/Vector.js';\nimport { applyTransform, approximatelyEquals, containsCoordinate, containsExtent, equals, getCenter, getHeight, getIntersection, getWidth, intersects, isEmpty, wrapX as wrapExtentX, } from '../extent.js';\nimport { assign } from '../obj.js';\nimport { clamp } from '../math.js';\nimport { degreesToStringHDMS } from '../coordinate.js';\nimport { equivalent as equivalentProjection, get as getProjection, getTransform, } from '../proj.js';\nimport { getVectorContext } from '../render.js';\nimport { meridian, parallel } from '../geom/flat/geodesic.js';\n/**\n * @type {Stroke}\n * @private\n * @const\n */\nvar DEFAULT_STROKE_STYLE = new Stroke({\n    color: 'rgba(0,0,0,0.2)',\n});\n/**\n * @type {Array<number>}\n * @private\n */\nvar INTERVALS = [\n    90, 45, 30, 20, 10, 5, 2, 1, 0.5, 0.2, 0.1, 0.05, 0.01, 0.005, 0.002, 0.001,\n];\n/**\n * @typedef {Object} GraticuleLabelDataType\n * @property {Point} geom Geometry.\n * @property {string} text Text.\n */\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {number} [maxLines=100] The maximum number of meridians and\n * parallels from the center of the map. The default value of 100 means that at\n * most 200 meridians and 200 parallels will be displayed. The default value is\n * appropriate for conformal projections like Spherical Mercator. If you\n * increase the value, more lines will be drawn and the drawing performance will\n * decrease.\n * @property {Stroke} [strokeStyle='rgba(0,0,0,0.2)'] The\n * stroke style to use for drawing the graticule. If not provided, a not fully\n * opaque black will be used.\n * @property {number} [targetSize=100] The target size of the graticule cells,\n * in pixels.\n * @property {boolean} [showLabels=false] Render a label with the respective\n * latitude/longitude for each graticule line.\n * @property {function(number):string} [lonLabelFormatter] Label formatter for\n * longitudes. This function is called with the longitude as argument, and\n * should return a formatted string representing the longitude. By default,\n * labels are formatted as degrees, minutes, seconds and hemisphere.\n * @property {function(number):string} [latLabelFormatter] Label formatter for\n * latitudes. This function is called with the latitude as argument, and\n * should return a formatted string representing the latitude. By default,\n * labels are formatted as degrees, minutes, seconds and hemisphere.\n * @property {number} [lonLabelPosition=0] Longitude label position in fractions\n * (0..1) of view extent. 0 means at the bottom of the viewport, 1 means at the\n * top.\n * @property {number} [latLabelPosition=1] Latitude label position in fractions\n * (0..1) of view extent. 0 means at the left of the viewport, 1 means at the\n * right.\n * @property {Text} [lonLabelStyle] Longitude label text\n * style. If not provided, the following style will be used:\n * ```js\n * new Text({\n *   font: '12px Calibri,sans-serif',\n *   textBaseline: 'bottom',\n *   fill: new Fill({\n *     color: 'rgba(0,0,0,1)'\n *   }),\n *   stroke: new Stroke({\n *     color: 'rgba(255,255,255,1)',\n *     width: 3\n *   })\n * });\n * ```\n * Note that the default's `textBaseline` configuration will not work well for\n * `lonLabelPosition` configurations that position labels close to the top of\n * the viewport.\n * @property {Text} [latLabelStyle] Latitude label text style.\n * If not provided, the following style will be used:\n * ```js\n * new Text({\n *   font: '12px Calibri,sans-serif',\n *   textAlign: 'end',\n *   fill: new Fill({\n *     color: 'rgba(0,0,0,1)'\n *   }),\n *   stroke: Stroke({\n *     color: 'rgba(255,255,255,1)',\n *     width: 3\n *   })\n * });\n * ```\n * Note that the default's `textAlign` configuration will not work well for\n * `latLabelPosition` configurations that position labels close to the left of\n * the viewport.\n * @property {Array<number>} [intervals=[90, 45, 30, 20, 10, 5, 2, 1, 0.5, 0.2, 0.1, 0.05, 0.01, 0.005, 0.002, 0.001]]\n * Intervals (in degrees) for the graticule. Example to limit graticules to 30 and 10 degrees intervals:\n * ```js\n * [30, 10]\n * ```\n * @property {boolean} [wrapX=true] Whether to repeat the graticule horizontally.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n/**\n * @classdesc\n * Layer that renders a grid for a coordinate system (currently only EPSG:4326 is supported).\n * Note that the view projection must define both extent and worldExtent.\n *\n * @fires import(\"../render/Event.js\").RenderEvent\n * @extends {VectorLayer<import(\"../source/Vector.js\").default>}\n * @api\n */\nvar Graticule = /** @class */ (function (_super) {\n    __extends(Graticule, _super);\n    /**\n     * @param {Options} [opt_options] Options.\n     */\n    function Graticule(opt_options) {\n        var _this = this;\n        var options = opt_options ? opt_options : {};\n        var baseOptions = assign({\n            updateWhileAnimating: true,\n            updateWhileInteracting: true,\n            renderBuffer: 0,\n        }, options);\n        delete baseOptions.maxLines;\n        delete baseOptions.strokeStyle;\n        delete baseOptions.targetSize;\n        delete baseOptions.showLabels;\n        delete baseOptions.lonLabelFormatter;\n        delete baseOptions.latLabelFormatter;\n        delete baseOptions.lonLabelPosition;\n        delete baseOptions.latLabelPosition;\n        delete baseOptions.lonLabelStyle;\n        delete baseOptions.latLabelStyle;\n        delete baseOptions.intervals;\n        _this = _super.call(this, baseOptions) || this;\n        /**\n         * @type {import(\"../proj/Projection.js\").default}\n         */\n        _this.projection_ = null;\n        /**\n         * @type {number}\n         * @private\n         */\n        _this.maxLat_ = Infinity;\n        /**\n         * @type {number}\n         * @private\n         */\n        _this.maxLon_ = Infinity;\n        /**\n         * @type {number}\n         * @private\n         */\n        _this.minLat_ = -Infinity;\n        /**\n         * @type {number}\n         * @private\n         */\n        _this.minLon_ = -Infinity;\n        /**\n         * @type {number}\n         * @private\n         */\n        _this.maxX_ = Infinity;\n        /**\n         * @type {number}\n         * @private\n         */\n        _this.maxY_ = Infinity;\n        /**\n         * @type {number}\n         * @private\n         */\n        _this.minX_ = -Infinity;\n        /**\n         * @type {number}\n         * @private\n         */\n        _this.minY_ = -Infinity;\n        /**\n         * @type {number}\n         * @private\n         */\n        _this.targetSize_ =\n            options.targetSize !== undefined ? options.targetSize : 100;\n        /**\n         * @type {number}\n         * @private\n         */\n        _this.maxLines_ = options.maxLines !== undefined ? options.maxLines : 100;\n        /**\n         * @type {Array<LineString>}\n         * @private\n         */\n        _this.meridians_ = [];\n        /**\n         * @type {Array<LineString>}\n         * @private\n         */\n        _this.parallels_ = [];\n        /**\n         * @type {Stroke}\n         * @private\n         */\n        _this.strokeStyle_ =\n            options.strokeStyle !== undefined\n                ? options.strokeStyle\n                : DEFAULT_STROKE_STYLE;\n        /**\n         * @type {import(\"../proj.js\").TransformFunction|undefined}\n         * @private\n         */\n        _this.fromLonLatTransform_ = undefined;\n        /**\n         * @type {import(\"../proj.js\").TransformFunction|undefined}\n         * @private\n         */\n        _this.toLonLatTransform_ = undefined;\n        /**\n         * @type {import(\"../coordinate.js\").Coordinate}\n         * @private\n         */\n        _this.projectionCenterLonLat_ = null;\n        /**\n         * @type {import(\"../coordinate.js\").Coordinate}\n         * @private\n         */\n        _this.bottomLeft_ = null;\n        /**\n         * @type {import(\"../coordinate.js\").Coordinate}\n         * @private\n         */\n        _this.bottomRight_ = null;\n        /**\n         * @type {import(\"../coordinate.js\").Coordinate}\n         * @private\n         */\n        _this.topLeft_ = null;\n        /**\n         * @type {import(\"../coordinate.js\").Coordinate}\n         * @private\n         */\n        _this.topRight_ = null;\n        /**\n         * @type {Array<GraticuleLabelDataType>}\n         * @private\n         */\n        _this.meridiansLabels_ = null;\n        /**\n         * @type {Array<GraticuleLabelDataType>}\n         * @private\n         */\n        _this.parallelsLabels_ = null;\n        if (options.showLabels) {\n            /**\n             * @type {null|function(number):string}\n             * @private\n             */\n            _this.lonLabelFormatter_ =\n                options.lonLabelFormatter == undefined\n                    ? degreesToStringHDMS.bind(_this, 'EW')\n                    : options.lonLabelFormatter;\n            /**\n             * @type {function(number):string}\n             * @private\n             */\n            _this.latLabelFormatter_ =\n                options.latLabelFormatter == undefined\n                    ? degreesToStringHDMS.bind(_this, 'NS')\n                    : options.latLabelFormatter;\n            /**\n             * Longitude label position in fractions (0..1) of view extent. 0 means\n             * bottom, 1 means top.\n             * @type {number}\n             * @private\n             */\n            _this.lonLabelPosition_ =\n                options.lonLabelPosition == undefined ? 0 : options.lonLabelPosition;\n            /**\n             * Latitude Label position in fractions (0..1) of view extent. 0 means left, 1\n             * means right.\n             * @type {number}\n             * @private\n             */\n            _this.latLabelPosition_ =\n                options.latLabelPosition == undefined ? 1 : options.latLabelPosition;\n            /**\n             * @type {Style}\n             * @private\n             */\n            _this.lonLabelStyleBase_ = new Style({\n                text: options.lonLabelStyle !== undefined\n                    ? options.lonLabelStyle.clone()\n                    : new Text({\n                        font: '12px Calibri,sans-serif',\n                        textBaseline: 'bottom',\n                        fill: new Fill({\n                            color: 'rgba(0,0,0,1)',\n                        }),\n                        stroke: new Stroke({\n                            color: 'rgba(255,255,255,1)',\n                            width: 3,\n                        }),\n                    }),\n            });\n            /**\n             * @private\n             * @param {import(\"../Feature\").default} feature Feature\n             * @return {Style} style\n             */\n            _this.lonLabelStyle_ = function (feature) {\n                var label = feature.get('graticule_label');\n                this.lonLabelStyleBase_.getText().setText(label);\n                return this.lonLabelStyleBase_;\n            }.bind(_this);\n            /**\n             * @type {Style}\n             * @private\n             */\n            _this.latLabelStyleBase_ = new Style({\n                text: options.latLabelStyle !== undefined\n                    ? options.latLabelStyle.clone()\n                    : new Text({\n                        font: '12px Calibri,sans-serif',\n                        textAlign: 'right',\n                        fill: new Fill({\n                            color: 'rgba(0,0,0,1)',\n                        }),\n                        stroke: new Stroke({\n                            color: 'rgba(255,255,255,1)',\n                            width: 3,\n                        }),\n                    }),\n            });\n            /**\n             * @private\n             * @param {import(\"../Feature\").default} feature Feature\n             * @return {Style} style\n             */\n            _this.latLabelStyle_ = function (feature) {\n                var label = feature.get('graticule_label');\n                this.latLabelStyleBase_.getText().setText(label);\n                return this.latLabelStyleBase_;\n            }.bind(_this);\n            _this.meridiansLabels_ = [];\n            _this.parallelsLabels_ = [];\n            _this.addEventListener(EventType.POSTRENDER, _this.drawLabels_.bind(_this));\n        }\n        /**\n         * @type {Array<number>}\n         * @private\n         */\n        _this.intervals_ =\n            options.intervals !== undefined ? options.intervals : INTERVALS;\n        // use a source with a custom loader for lines & text\n        _this.setSource(new VectorSource({\n            loader: _this.loaderFunction.bind(_this),\n            strategy: _this.strategyFunction.bind(_this),\n            features: new Collection(),\n            overlaps: false,\n            useSpatialIndex: false,\n            wrapX: options.wrapX,\n        }));\n        /**\n         * feature pool to use when updating graticule\n         * @type {Array<Feature>}\n         * @private\n         */\n        _this.featurePool_ = [];\n        /**\n         * @type {Style}\n         * @private\n         */\n        _this.lineStyle_ = new Style({\n            stroke: _this.strokeStyle_,\n        });\n        /**\n         * @type {?import(\"../extent.js\").Extent}\n         * @private\n         */\n        _this.loadedExtent_ = null;\n        /**\n         * @type {?import(\"../extent.js\").Extent}\n         */\n        _this.renderedExtent_ = null;\n        _this.setRenderOrder(null);\n        return _this;\n    }\n    /**\n     * Strategy function for loading features based on the view's extent and\n     * resolution.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {number} resolution Resolution.\n     * @return {Array<import(\"../extent.js\").Extent>} Extents.\n     */\n    Graticule.prototype.strategyFunction = function (extent, resolution) {\n        // extents may be passed in different worlds, to avoid endless loop we use only one\n        var realWorldExtent = extent.slice();\n        if (this.projection_ && this.getSource().getWrapX()) {\n            wrapExtentX(realWorldExtent, this.projection_);\n        }\n        if (this.loadedExtent_) {\n            if (approximatelyEquals(this.loadedExtent_, realWorldExtent, resolution)) {\n                // make sure result is exactly equal to previous extent\n                realWorldExtent = this.loadedExtent_.slice();\n            }\n            else {\n                // we should not keep track of loaded extents\n                this.getSource().removeLoadedExtent(this.loadedExtent_);\n            }\n        }\n        return [realWorldExtent];\n    };\n    /**\n     * Update geometries in the source based on current view\n     * @param {import(\"../extent\").Extent} extent Extent\n     * @param {number} resolution Resolution\n     * @param {import(\"../proj/Projection.js\").default} projection Projection\n     */\n    Graticule.prototype.loaderFunction = function (extent, resolution, projection) {\n        this.loadedExtent_ = extent;\n        var source = this.getSource();\n        // only consider the intersection between our own extent & the requested one\n        var layerExtent = this.getExtent() || [\n            -Infinity,\n            -Infinity,\n            Infinity,\n            Infinity,\n        ];\n        var renderExtent = getIntersection(layerExtent, extent);\n        if (this.renderedExtent_ && equals(this.renderedExtent_, renderExtent)) {\n            return;\n        }\n        this.renderedExtent_ = renderExtent;\n        // bail out if nothing to render\n        if (isEmpty(renderExtent)) {\n            return;\n        }\n        // update projection info\n        var center = getCenter(renderExtent);\n        var squaredTolerance = (resolution * resolution) / 4;\n        var updateProjectionInfo = !this.projection_ || !equivalentProjection(this.projection_, projection);\n        if (updateProjectionInfo) {\n            this.updateProjectionInfo_(projection);\n        }\n        this.createGraticule_(renderExtent, center, resolution, squaredTolerance);\n        // first make sure we have enough features in the pool\n        var featureCount = this.meridians_.length + this.parallels_.length;\n        if (this.meridiansLabels_) {\n            featureCount += this.meridians_.length;\n        }\n        if (this.parallelsLabels_) {\n            featureCount += this.parallels_.length;\n        }\n        var feature;\n        while (featureCount > this.featurePool_.length) {\n            feature = new Feature();\n            this.featurePool_.push(feature);\n        }\n        var featuresColl = source.getFeaturesCollection();\n        featuresColl.clear();\n        var poolIndex = 0;\n        // add features for the lines & labels\n        var i, l;\n        for (i = 0, l = this.meridians_.length; i < l; ++i) {\n            feature = this.featurePool_[poolIndex++];\n            feature.setGeometry(this.meridians_[i]);\n            feature.setStyle(this.lineStyle_);\n            featuresColl.push(feature);\n        }\n        for (i = 0, l = this.parallels_.length; i < l; ++i) {\n            feature = this.featurePool_[poolIndex++];\n            feature.setGeometry(this.parallels_[i]);\n            feature.setStyle(this.lineStyle_);\n            featuresColl.push(feature);\n        }\n    };\n    /**\n     * @param {number} lon Longitude.\n     * @param {number} minLat Minimal latitude.\n     * @param {number} maxLat Maximal latitude.\n     * @param {number} squaredTolerance Squared tolerance.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {number} index Index.\n     * @return {number} Index.\n     * @private\n     */\n    Graticule.prototype.addMeridian_ = function (lon, minLat, maxLat, squaredTolerance, extent, index) {\n        var lineString = this.getMeridian_(lon, minLat, maxLat, squaredTolerance, index);\n        if (intersects(lineString.getExtent(), extent)) {\n            if (this.meridiansLabels_) {\n                var text = this.lonLabelFormatter_(lon);\n                if (index in this.meridiansLabels_) {\n                    this.meridiansLabels_[index].text = text;\n                }\n                else {\n                    this.meridiansLabels_[index] = {\n                        geom: new Point([]),\n                        text: text,\n                    };\n                }\n            }\n            this.meridians_[index++] = lineString;\n        }\n        return index;\n    };\n    /**\n     * @param {number} lat Latitude.\n     * @param {number} minLon Minimal longitude.\n     * @param {number} maxLon Maximal longitude.\n     * @param {number} squaredTolerance Squared tolerance.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {number} index Index.\n     * @return {number} Index.\n     * @private\n     */\n    Graticule.prototype.addParallel_ = function (lat, minLon, maxLon, squaredTolerance, extent, index) {\n        var lineString = this.getParallel_(lat, minLon, maxLon, squaredTolerance, index);\n        if (intersects(lineString.getExtent(), extent)) {\n            if (this.parallelsLabels_) {\n                var text = this.latLabelFormatter_(lat);\n                if (index in this.parallelsLabels_) {\n                    this.parallelsLabels_[index].text = text;\n                }\n                else {\n                    this.parallelsLabels_[index] = {\n                        geom: new Point([]),\n                        text: text,\n                    };\n                }\n            }\n            this.parallels_[index++] = lineString;\n        }\n        return index;\n    };\n    /**\n     * @param {import(\"../render/Event.js\").default} event Render event.\n     * @private\n     */\n    Graticule.prototype.drawLabels_ = function (event) {\n        var rotation = event.frameState.viewState.rotation;\n        var extent = event.frameState.extent;\n        var rotationCenter = getCenter(extent);\n        var rotationExtent = extent;\n        if (rotation) {\n            var width = getWidth(extent);\n            var height = getHeight(extent);\n            var cr = Math.abs(Math.cos(rotation));\n            var sr = Math.abs(Math.sin(rotation));\n            var unrotatedWidth = (sr * height - cr * width) / (sr * sr - cr * cr);\n            var unrotatedHeight = (sr * width - cr * height) / (sr * sr - cr * cr);\n            rotationExtent = [\n                rotationCenter[0] - unrotatedWidth / 2,\n                rotationCenter[1] - unrotatedHeight / 2,\n                rotationCenter[0] + unrotatedWidth / 2,\n                rotationCenter[1] + unrotatedHeight / 2,\n            ];\n        }\n        var startWorld = 0;\n        var endWorld = 0;\n        var labelsAtStart = this.latLabelPosition_ < 0.5;\n        var projectionExtent = this.projection_.getExtent();\n        var worldWidth = getWidth(projectionExtent);\n        if (this.getSource().getWrapX() &&\n            this.projection_.canWrapX() &&\n            !containsExtent(projectionExtent, extent)) {\n            startWorld = Math.floor((extent[0] - projectionExtent[0]) / worldWidth);\n            endWorld = Math.ceil((extent[2] - projectionExtent[2]) / worldWidth);\n            var inverted = Math.abs(rotation) > Math.PI / 2;\n            labelsAtStart = labelsAtStart !== inverted;\n        }\n        var vectorContext = getVectorContext(event);\n        for (var world = startWorld; world <= endWorld; ++world) {\n            var poolIndex = this.meridians_.length + this.parallels_.length;\n            var feature = void 0, index = void 0, l = void 0, textPoint = void 0;\n            if (this.meridiansLabels_) {\n                for (index = 0, l = this.meridiansLabels_.length; index < l; ++index) {\n                    var lineString = this.meridians_[index];\n                    if (!rotation && world === 0) {\n                        textPoint = this.getMeridianPoint_(lineString, extent, index);\n                    }\n                    else {\n                        var clone = lineString.clone();\n                        clone.translate(world * worldWidth, 0);\n                        clone.rotate(-rotation, rotationCenter);\n                        textPoint = this.getMeridianPoint_(clone, rotationExtent, index);\n                        textPoint.rotate(rotation, rotationCenter);\n                    }\n                    feature = this.featurePool_[poolIndex++];\n                    feature.setGeometry(textPoint);\n                    feature.set('graticule_label', this.meridiansLabels_[index].text);\n                    vectorContext.drawFeature(feature, this.lonLabelStyle_(feature));\n                }\n            }\n            if (this.parallelsLabels_) {\n                if ((world === startWorld && labelsAtStart) ||\n                    (world === endWorld && !labelsAtStart)) {\n                    for (index = 0, l = this.parallels_.length; index < l; ++index) {\n                        var lineString = this.parallels_[index];\n                        if (!rotation && world === 0) {\n                            textPoint = this.getParallelPoint_(lineString, extent, index);\n                        }\n                        else {\n                            var clone = lineString.clone();\n                            clone.translate(world * worldWidth, 0);\n                            clone.rotate(-rotation, rotationCenter);\n                            textPoint = this.getParallelPoint_(clone, rotationExtent, index);\n                            textPoint.rotate(rotation, rotationCenter);\n                        }\n                        feature = this.featurePool_[poolIndex++];\n                        feature.setGeometry(textPoint);\n                        feature.set('graticule_label', this.parallelsLabels_[index].text);\n                        vectorContext.drawFeature(feature, this.latLabelStyle_(feature));\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {import(\"../coordinate.js\").Coordinate} center Center.\n     * @param {number} resolution Resolution.\n     * @param {number} squaredTolerance Squared tolerance.\n     * @private\n     */\n    Graticule.prototype.createGraticule_ = function (extent, center, resolution, squaredTolerance) {\n        var interval = this.getInterval_(resolution);\n        if (interval == -1) {\n            this.meridians_.length = 0;\n            this.parallels_.length = 0;\n            if (this.meridiansLabels_) {\n                this.meridiansLabels_.length = 0;\n            }\n            if (this.parallelsLabels_) {\n                this.parallelsLabels_.length = 0;\n            }\n            return;\n        }\n        var wrapX = false;\n        var projectionExtent = this.projection_.getExtent();\n        var worldWidth = getWidth(projectionExtent);\n        if (this.getSource().getWrapX() &&\n            this.projection_.canWrapX() &&\n            !containsExtent(projectionExtent, extent)) {\n            if (getWidth(extent) >= worldWidth) {\n                extent[0] = projectionExtent[0];\n                extent[2] = projectionExtent[2];\n            }\n            else {\n                wrapX = true;\n            }\n        }\n        // Constrain the center to fit into the extent available to the graticule\n        var validCenterP = [\n            clamp(center[0], this.minX_, this.maxX_),\n            clamp(center[1], this.minY_, this.maxY_),\n        ];\n        // Transform the center to lon lat\n        // Some projections may have a void area at the poles\n        // so replace any NaN latitudes with the min or max value closest to a pole\n        var centerLonLat = this.toLonLatTransform_(validCenterP);\n        if (isNaN(centerLonLat[1])) {\n            centerLonLat[1] =\n                Math.abs(this.maxLat_) >= Math.abs(this.minLat_)\n                    ? this.maxLat_\n                    : this.minLat_;\n        }\n        var centerLon = clamp(centerLonLat[0], this.minLon_, this.maxLon_);\n        var centerLat = clamp(centerLonLat[1], this.minLat_, this.maxLat_);\n        var maxLines = this.maxLines_;\n        var cnt, idx, lat, lon;\n        // Limit the extent to fit into the extent available to the graticule\n        var validExtentP = extent;\n        if (!wrapX) {\n            validExtentP = [\n                clamp(extent[0], this.minX_, this.maxX_),\n                clamp(extent[1], this.minY_, this.maxY_),\n                clamp(extent[2], this.minX_, this.maxX_),\n                clamp(extent[3], this.minY_, this.maxY_),\n            ];\n        }\n        // Transform the extent to get the lon lat ranges for the edges of the extent\n        var validExtent = applyTransform(validExtentP, this.toLonLatTransform_, undefined, 8);\n        var maxLat = validExtent[3];\n        var maxLon = validExtent[2];\n        var minLat = validExtent[1];\n        var minLon = validExtent[0];\n        if (!wrapX) {\n            // Check if extremities of the world extent lie inside the extent\n            // (for example the pole in a polar projection)\n            // and extend the extent as appropriate\n            if (containsCoordinate(validExtentP, this.bottomLeft_)) {\n                minLon = this.minLon_;\n                minLat = this.minLat_;\n            }\n            if (containsCoordinate(validExtentP, this.bottomRight_)) {\n                maxLon = this.maxLon_;\n                minLat = this.minLat_;\n            }\n            if (containsCoordinate(validExtentP, this.topLeft_)) {\n                minLon = this.minLon_;\n                maxLat = this.maxLat_;\n            }\n            if (containsCoordinate(validExtentP, this.topRight_)) {\n                maxLon = this.maxLon_;\n                maxLat = this.maxLat_;\n            }\n            // The transformed center may also extend the lon lat ranges used for rendering\n            maxLat = clamp(maxLat, centerLat, this.maxLat_);\n            maxLon = clamp(maxLon, centerLon, this.maxLon_);\n            minLat = clamp(minLat, this.minLat_, centerLat);\n            minLon = clamp(minLon, this.minLon_, centerLon);\n        }\n        // Create meridians\n        centerLon = Math.floor(centerLon / interval) * interval;\n        lon = clamp(centerLon, this.minLon_, this.maxLon_);\n        idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, 0);\n        cnt = 0;\n        if (wrapX) {\n            while ((lon -= interval) >= minLon && cnt++ < maxLines) {\n                idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);\n            }\n        }\n        else {\n            while (lon != this.minLon_ && cnt++ < maxLines) {\n                lon = Math.max(lon - interval, this.minLon_);\n                idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);\n            }\n        }\n        lon = clamp(centerLon, this.minLon_, this.maxLon_);\n        cnt = 0;\n        if (wrapX) {\n            while ((lon += interval) <= maxLon && cnt++ < maxLines) {\n                idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);\n            }\n        }\n        else {\n            while (lon != this.maxLon_ && cnt++ < maxLines) {\n                lon = Math.min(lon + interval, this.maxLon_);\n                idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);\n            }\n        }\n        this.meridians_.length = idx;\n        if (this.meridiansLabels_) {\n            this.meridiansLabels_.length = idx;\n        }\n        // Create parallels\n        centerLat = Math.floor(centerLat / interval) * interval;\n        lat = clamp(centerLat, this.minLat_, this.maxLat_);\n        idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, 0);\n        cnt = 0;\n        while (lat != this.minLat_ && cnt++ < maxLines) {\n            lat = Math.max(lat - interval, this.minLat_);\n            idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, idx);\n        }\n        lat = clamp(centerLat, this.minLat_, this.maxLat_);\n        cnt = 0;\n        while (lat != this.maxLat_ && cnt++ < maxLines) {\n            lat = Math.min(lat + interval, this.maxLat_);\n            idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, idx);\n        }\n        this.parallels_.length = idx;\n        if (this.parallelsLabels_) {\n            this.parallelsLabels_.length = idx;\n        }\n    };\n    /**\n     * @param {number} resolution Resolution.\n     * @return {number} The interval in degrees.\n     * @private\n     */\n    Graticule.prototype.getInterval_ = function (resolution) {\n        var centerLon = this.projectionCenterLonLat_[0];\n        var centerLat = this.projectionCenterLonLat_[1];\n        var interval = -1;\n        var target = Math.pow(this.targetSize_ * resolution, 2);\n        /** @type {Array<number>} **/\n        var p1 = [];\n        /** @type {Array<number>} **/\n        var p2 = [];\n        for (var i = 0, ii = this.intervals_.length; i < ii; ++i) {\n            var delta = clamp(this.intervals_[i] / 2, 0, 90);\n            // Don't attempt to transform latitudes beyond the poles!\n            var clampedLat = clamp(centerLat, -90 + delta, 90 - delta);\n            p1[0] = centerLon - delta;\n            p1[1] = clampedLat - delta;\n            p2[0] = centerLon + delta;\n            p2[1] = clampedLat + delta;\n            this.fromLonLatTransform_(p1, p1);\n            this.fromLonLatTransform_(p2, p2);\n            var dist = Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2);\n            if (dist <= target) {\n                break;\n            }\n            interval = this.intervals_[i];\n        }\n        return interval;\n    };\n    /**\n     * @param {number} lon Longitude.\n     * @param {number} minLat Minimal latitude.\n     * @param {number} maxLat Maximal latitude.\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {LineString} The meridian line string.\n     * @param {number} index Index.\n     * @private\n     */\n    Graticule.prototype.getMeridian_ = function (lon, minLat, maxLat, squaredTolerance, index) {\n        var flatCoordinates = meridian(lon, minLat, maxLat, this.projection_, squaredTolerance);\n        var lineString = this.meridians_[index];\n        if (!lineString) {\n            lineString = new LineString(flatCoordinates, GeometryLayout.XY);\n            this.meridians_[index] = lineString;\n        }\n        else {\n            lineString.setFlatCoordinates(GeometryLayout.XY, flatCoordinates);\n            lineString.changed();\n        }\n        return lineString;\n    };\n    /**\n     * @param {LineString} lineString Meridian\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {number} index Index.\n     * @return {Point} Meridian point.\n     * @private\n     */\n    Graticule.prototype.getMeridianPoint_ = function (lineString, extent, index) {\n        var flatCoordinates = lineString.getFlatCoordinates();\n        var bottom = 1;\n        var top = flatCoordinates.length - 1;\n        if (flatCoordinates[bottom] > flatCoordinates[top]) {\n            bottom = top;\n            top = 1;\n        }\n        var clampedBottom = Math.max(extent[1], flatCoordinates[bottom]);\n        var clampedTop = Math.min(extent[3], flatCoordinates[top]);\n        var lat = clamp(extent[1] + Math.abs(extent[1] - extent[3]) * this.lonLabelPosition_, clampedBottom, clampedTop);\n        var coordinate0 = flatCoordinates[bottom - 1] +\n            ((flatCoordinates[top - 1] - flatCoordinates[bottom - 1]) *\n                (lat - flatCoordinates[bottom])) /\n                (flatCoordinates[top] - flatCoordinates[bottom]);\n        var coordinate = [coordinate0, lat];\n        var point = this.meridiansLabels_[index].geom;\n        point.setCoordinates(coordinate);\n        return point;\n    };\n    /**\n     * Get the list of meridians.  Meridians are lines of equal longitude.\n     * @return {Array<LineString>} The meridians.\n     * @api\n     */\n    Graticule.prototype.getMeridians = function () {\n        return this.meridians_;\n    };\n    /**\n     * @param {number} lat Latitude.\n     * @param {number} minLon Minimal longitude.\n     * @param {number} maxLon Maximal longitude.\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {LineString} The parallel line string.\n     * @param {number} index Index.\n     * @private\n     */\n    Graticule.prototype.getParallel_ = function (lat, minLon, maxLon, squaredTolerance, index) {\n        var flatCoordinates = parallel(lat, minLon, maxLon, this.projection_, squaredTolerance);\n        var lineString = this.parallels_[index];\n        if (!lineString) {\n            lineString = new LineString(flatCoordinates, GeometryLayout.XY);\n        }\n        else {\n            lineString.setFlatCoordinates(GeometryLayout.XY, flatCoordinates);\n            lineString.changed();\n        }\n        return lineString;\n    };\n    /**\n     * @param {LineString} lineString Parallels.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {number} index Index.\n     * @return {Point} Parallel point.\n     * @private\n     */\n    Graticule.prototype.getParallelPoint_ = function (lineString, extent, index) {\n        var flatCoordinates = lineString.getFlatCoordinates();\n        var left = 0;\n        var right = flatCoordinates.length - 2;\n        if (flatCoordinates[left] > flatCoordinates[right]) {\n            left = right;\n            right = 0;\n        }\n        var clampedLeft = Math.max(extent[0], flatCoordinates[left]);\n        var clampedRight = Math.min(extent[2], flatCoordinates[right]);\n        var lon = clamp(extent[0] + Math.abs(extent[0] - extent[2]) * this.latLabelPosition_, clampedLeft, clampedRight);\n        var coordinate1 = flatCoordinates[left + 1] +\n            ((flatCoordinates[right + 1] - flatCoordinates[left + 1]) *\n                (lon - flatCoordinates[left])) /\n                (flatCoordinates[right] - flatCoordinates[left]);\n        var coordinate = [lon, coordinate1];\n        var point = this.parallelsLabels_[index].geom;\n        point.setCoordinates(coordinate);\n        return point;\n    };\n    /**\n     * Get the list of parallels.  Parallels are lines of equal latitude.\n     * @return {Array<LineString>} The parallels.\n     * @api\n     */\n    Graticule.prototype.getParallels = function () {\n        return this.parallels_;\n    };\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @private\n     */\n    Graticule.prototype.updateProjectionInfo_ = function (projection) {\n        var epsg4326Projection = getProjection('EPSG:4326');\n        var worldExtent = projection.getWorldExtent();\n        this.maxLat_ = worldExtent[3];\n        this.maxLon_ = worldExtent[2];\n        this.minLat_ = worldExtent[1];\n        this.minLon_ = worldExtent[0];\n        // If the world extent crosses the dateline define a custom transform to\n        // return longitudes which wrap the dateline\n        var toLonLatTransform = getTransform(projection, epsg4326Projection);\n        if (this.minLon_ < this.maxLon_) {\n            this.toLonLatTransform_ = toLonLatTransform;\n        }\n        else {\n            var split_1 = this.minLon_ + this.maxLon_ / 2;\n            this.maxLon_ += 360;\n            this.toLonLatTransform_ = function (coordinates, opt_output, opt_dimension) {\n                var dimension = opt_dimension || 2;\n                var lonLatCoordinates = toLonLatTransform(coordinates, opt_output, dimension);\n                for (var i = 0, l = lonLatCoordinates.length; i < l; i += dimension) {\n                    if (lonLatCoordinates[i] < split_1) {\n                        lonLatCoordinates[i] += 360;\n                    }\n                }\n                return lonLatCoordinates;\n            };\n        }\n        // Transform the extent to get the limits of the view projection extent\n        // which should be available to the graticule\n        this.fromLonLatTransform_ = getTransform(epsg4326Projection, projection);\n        var worldExtentP = applyTransform([this.minLon_, this.minLat_, this.maxLon_, this.maxLat_], this.fromLonLatTransform_, undefined, 8);\n        this.minX_ = worldExtentP[0];\n        this.maxX_ = worldExtentP[2];\n        this.minY_ = worldExtentP[1];\n        this.maxY_ = worldExtentP[3];\n        // Determine the view projection coordinates of the extremities of the world extent\n        // as these may lie inside a view extent (for example the pole in a polar projection)\n        this.bottomLeft_ = this.fromLonLatTransform_([this.minLon_, this.minLat_]);\n        this.bottomRight_ = this.fromLonLatTransform_([this.maxLon_, this.minLat_]);\n        this.topLeft_ = this.fromLonLatTransform_([this.minLon_, this.maxLat_]);\n        this.topRight_ = this.fromLonLatTransform_([this.maxLon_, this.maxLat_]);\n        // Transform the projection center to lon lat\n        // Some projections may have a void area at the poles\n        // so replace any NaN latitudes with the min or max value closest to a pole\n        this.projectionCenterLonLat_ = this.toLonLatTransform_(getCenter(projection.getExtent()));\n        if (isNaN(this.projectionCenterLonLat_[1])) {\n            this.projectionCenterLonLat_[1] =\n                Math.abs(this.maxLat_) >= Math.abs(this.minLat_)\n                    ? this.maxLat_\n                    : this.minLat_;\n        }\n        this.projection_ = projection;\n    };\n    return Graticule;\n}(VectorLayer));\nexport default Graticule;\n//# sourceMappingURL=Graticule.js.map"]},"metadata":{},"sourceType":"module"}