{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/renderer/Map\n */\n\n\nimport Disposable from '../Disposable.js';\nimport { TRUE } from '../functions.js';\nimport { abstract } from '../util.js';\nimport { compose as composeTransform, makeInverse } from '../transform.js';\nimport { getWidth } from '../extent.js';\nimport { shared as iconImageCache } from '../style/IconImageCache.js';\nimport { inView } from '../layer/Layer.js';\nimport { wrapX } from '../coordinate.js';\n/**\n * @typedef HitMatch\n * @property {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @property {import(\"../layer/Layer.js\").default} layer Layer.\n * @property {import(\"../geom/SimpleGeometry.js\").default} geometry Geometry.\n * @property {number} distanceSq Squared distance.\n * @property {import(\"./vector.js\").FeatureCallback<T>} callback Callback.\n * @template T\n */\n\n/**\n * @abstract\n */\n\nvar MapRenderer = function (_super) {\n  __extends(MapRenderer, _super);\n  /**\n   * @param {import(\"../PluggableMap.js\").default} map Map.\n   */\n\n\n  function MapRenderer(map) {\n    var _this = _super.call(this) || this;\n    /**\n     * @private\n     * @type {import(\"../PluggableMap.js\").default}\n     */\n\n\n    _this.map_ = map;\n    return _this;\n  }\n  /**\n   * @abstract\n   * @param {import(\"../render/EventType.js\").default} type Event type.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n   */\n\n\n  MapRenderer.prototype.dispatchRenderEvent = function (type, frameState) {\n    abstract();\n  };\n  /**\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState FrameState.\n   * @protected\n   */\n\n\n  MapRenderer.prototype.calculateMatrices2D = function (frameState) {\n    var viewState = frameState.viewState;\n    var coordinateToPixelTransform = frameState.coordinateToPixelTransform;\n    var pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;\n    composeTransform(coordinateToPixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / viewState.resolution, -1 / viewState.resolution, -viewState.rotation, -viewState.center[0], -viewState.center[1]);\n    makeInverse(pixelToCoordinateTransform, coordinateToPixelTransform);\n  };\n  /**\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState FrameState.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {boolean} checkWrapped Check for wrapped geometries.\n   * @param {import(\"./vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {S} thisArg Value to use as `this` when executing `callback`.\n   * @param {function(this: U, import(\"../layer/Layer.js\").default): boolean} layerFilter Layer filter\n   *     function, only layers which are visible and for which this function\n   *     returns `true` will be tested for features.  By default, all visible\n   *     layers will be tested.\n   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.\n   * @return {T|undefined} Callback result.\n   * @template S,T,U\n   */\n\n\n  MapRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, checkWrapped, callback, thisArg, layerFilter, thisArg2) {\n    var result;\n    var viewState = frameState.viewState;\n    /**\n     * @param {boolean} managed Managed layer.\n     * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n     * @param {import(\"../layer/Layer.js\").default} layer Layer.\n     * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n     * @return {T|undefined} Callback result.\n     */\n\n    function forEachFeatureAtCoordinate(managed, feature, layer, geometry) {\n      return callback.call(thisArg, feature, managed ? layer : null, geometry);\n    }\n\n    var projection = viewState.projection;\n    var translatedCoordinate = wrapX(coordinate.slice(), projection);\n    var offsets = [[0, 0]];\n\n    if (projection.canWrapX() && checkWrapped) {\n      var projectionExtent = projection.getExtent();\n      var worldWidth = getWidth(projectionExtent);\n      offsets.push([-worldWidth, 0], [worldWidth, 0]);\n    }\n\n    var layerStates = frameState.layerStatesArray;\n    var numLayers = layerStates.length;\n    var matches = [];\n    var tmpCoord = [];\n\n    for (var i = 0; i < offsets.length; i++) {\n      for (var j = numLayers - 1; j >= 0; --j) {\n        var layerState = layerStates[j];\n        var layer = layerState.layer;\n\n        if (layer.hasRenderer() && inView(layerState, viewState) && layerFilter.call(thisArg2, layer)) {\n          var layerRenderer = layer.getRenderer();\n          var source = layer.getSource();\n\n          if (layerRenderer && source) {\n            var coordinates = source.getWrapX() ? translatedCoordinate : coordinate;\n            var callback_1 = forEachFeatureAtCoordinate.bind(null, layerState.managed);\n            tmpCoord[0] = coordinates[0] + offsets[i][0];\n            tmpCoord[1] = coordinates[1] + offsets[i][1];\n            result = layerRenderer.forEachFeatureAtCoordinate(tmpCoord, frameState, hitTolerance, callback_1, matches);\n          }\n\n          if (result) {\n            return result;\n          }\n        }\n      }\n    }\n\n    if (matches.length === 0) {\n      return undefined;\n    }\n\n    var order = 1 / matches.length;\n    matches.forEach(function (m, i) {\n      return m.distanceSq += i * order;\n    });\n    matches.sort(function (a, b) {\n      return a.distanceSq - b.distanceSq;\n    });\n    matches.some(function (m) {\n      return result = m.callback(m.feature, m.layer, m.geometry);\n    });\n    return result;\n  };\n  /**\n   * @abstract\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState FrameState.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {function(import(\"../layer/Layer.js\").default, (Uint8ClampedArray|Uint8Array)): T} callback Layer\n   *     callback.\n   * @param {function(import(\"../layer/Layer.js\").default): boolean} layerFilter Layer filter\n   *     function, only layers which are visible and for which this function\n   *     returns `true` will be tested for features.  By default, all visible\n   *     layers will be tested.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n\n\n  MapRenderer.prototype.forEachLayerAtPixel = function (pixel, frameState, hitTolerance, callback, layerFilter) {\n    return abstract();\n  };\n  /**\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState FrameState.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {boolean} checkWrapped Check for wrapped geometries.\n   * @param {function(this: U, import(\"../layer/Layer.js\").default): boolean} layerFilter Layer filter\n   *     function, only layers which are visible and for which this function\n   *     returns `true` will be tested for features.  By default, all visible\n   *     layers will be tested.\n   * @param {U} thisArg Value to use as `this` when executing `layerFilter`.\n   * @return {boolean} Is there a feature at the given coordinate?\n   * @template U\n   */\n\n\n  MapRenderer.prototype.hasFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, checkWrapped, layerFilter, thisArg) {\n    var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, TRUE, this, layerFilter, thisArg);\n    return hasFeature !== undefined;\n  };\n  /**\n   * @return {import(\"../PluggableMap.js\").default} Map.\n   */\n\n\n  MapRenderer.prototype.getMap = function () {\n    return this.map_;\n  };\n  /**\n   * Render.\n   * @abstract\n   * @param {?import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n   */\n\n\n  MapRenderer.prototype.renderFrame = function (frameState) {\n    abstract();\n  };\n  /**\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n\n\n  MapRenderer.prototype.scheduleExpireIconCache = function (frameState) {\n    if (iconImageCache.canExpireCache()) {\n      frameState.postRenderFunctions.push(expireIconCache);\n    }\n  };\n\n  return MapRenderer;\n}(Disposable);\n/**\n * @param {import(\"../PluggableMap.js\").default} map Map.\n * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n */\n\n\nfunction expireIconCache(map, frameState) {\n  iconImageCache.expire();\n}\n\nexport default MapRenderer;","map":{"version":3,"sources":["../src/renderer/Map.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/renderer/Map\n */\nimport Disposable from '../Disposable.js';\nimport { TRUE } from '../functions.js';\nimport { abstract } from '../util.js';\nimport { compose as composeTransform, makeInverse } from '../transform.js';\nimport { getWidth } from '../extent.js';\nimport { shared as iconImageCache } from '../style/IconImageCache.js';\nimport { inView } from '../layer/Layer.js';\nimport { wrapX } from '../coordinate.js';\n/**\n * @typedef HitMatch\n * @property {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @property {import(\"../layer/Layer.js\").default} layer Layer.\n * @property {import(\"../geom/SimpleGeometry.js\").default} geometry Geometry.\n * @property {number} distanceSq Squared distance.\n * @property {import(\"./vector.js\").FeatureCallback<T>} callback Callback.\n * @template T\n */\n/**\n * @abstract\n */\nvar MapRenderer = /** @class */ (function (_super) {\n    __extends(MapRenderer, _super);\n    /**\n     * @param {import(\"../PluggableMap.js\").default} map Map.\n     */\n    function MapRenderer(map) {\n        var _this = _super.call(this) || this;\n        /**\n         * @private\n         * @type {import(\"../PluggableMap.js\").default}\n         */\n        _this.map_ = map;\n        return _this;\n    }\n    /**\n     * @abstract\n     * @param {import(\"../render/EventType.js\").default} type Event type.\n     * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n     */\n    MapRenderer.prototype.dispatchRenderEvent = function (type, frameState) {\n        abstract();\n    };\n    /**\n     * @param {import(\"../PluggableMap.js\").FrameState} frameState FrameState.\n     * @protected\n     */\n    MapRenderer.prototype.calculateMatrices2D = function (frameState) {\n        var viewState = frameState.viewState;\n        var coordinateToPixelTransform = frameState.coordinateToPixelTransform;\n        var pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;\n        composeTransform(coordinateToPixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / viewState.resolution, -1 / viewState.resolution, -viewState.rotation, -viewState.center[0], -viewState.center[1]);\n        makeInverse(pixelToCoordinateTransform, coordinateToPixelTransform);\n    };\n    /**\n     * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {import(\"../PluggableMap.js\").FrameState} frameState FrameState.\n     * @param {number} hitTolerance Hit tolerance in pixels.\n     * @param {boolean} checkWrapped Check for wrapped geometries.\n     * @param {import(\"./vector.js\").FeatureCallback<T>} callback Feature callback.\n     * @param {S} thisArg Value to use as `this` when executing `callback`.\n     * @param {function(this: U, import(\"../layer/Layer.js\").default): boolean} layerFilter Layer filter\n     *     function, only layers which are visible and for which this function\n     *     returns `true` will be tested for features.  By default, all visible\n     *     layers will be tested.\n     * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.\n     * @return {T|undefined} Callback result.\n     * @template S,T,U\n     */\n    MapRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, checkWrapped, callback, thisArg, layerFilter, thisArg2) {\n        var result;\n        var viewState = frameState.viewState;\n        /**\n         * @param {boolean} managed Managed layer.\n         * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n         * @param {import(\"../layer/Layer.js\").default} layer Layer.\n         * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n         * @return {T|undefined} Callback result.\n         */\n        function forEachFeatureAtCoordinate(managed, feature, layer, geometry) {\n            return callback.call(thisArg, feature, managed ? layer : null, geometry);\n        }\n        var projection = viewState.projection;\n        var translatedCoordinate = wrapX(coordinate.slice(), projection);\n        var offsets = [[0, 0]];\n        if (projection.canWrapX() && checkWrapped) {\n            var projectionExtent = projection.getExtent();\n            var worldWidth = getWidth(projectionExtent);\n            offsets.push([-worldWidth, 0], [worldWidth, 0]);\n        }\n        var layerStates = frameState.layerStatesArray;\n        var numLayers = layerStates.length;\n        var matches = /** @type {Array<HitMatch<T>>} */ ([]);\n        var tmpCoord = [];\n        for (var i = 0; i < offsets.length; i++) {\n            for (var j = numLayers - 1; j >= 0; --j) {\n                var layerState = layerStates[j];\n                var layer = layerState.layer;\n                if (layer.hasRenderer() &&\n                    inView(layerState, viewState) &&\n                    layerFilter.call(thisArg2, layer)) {\n                    var layerRenderer = layer.getRenderer();\n                    var source = layer.getSource();\n                    if (layerRenderer && source) {\n                        var coordinates = source.getWrapX()\n                            ? translatedCoordinate\n                            : coordinate;\n                        var callback_1 = forEachFeatureAtCoordinate.bind(null, layerState.managed);\n                        tmpCoord[0] = coordinates[0] + offsets[i][0];\n                        tmpCoord[1] = coordinates[1] + offsets[i][1];\n                        result = layerRenderer.forEachFeatureAtCoordinate(tmpCoord, frameState, hitTolerance, callback_1, matches);\n                    }\n                    if (result) {\n                        return result;\n                    }\n                }\n            }\n        }\n        if (matches.length === 0) {\n            return undefined;\n        }\n        var order = 1 / matches.length;\n        matches.forEach(function (m, i) { return (m.distanceSq += i * order); });\n        matches.sort(function (a, b) { return a.distanceSq - b.distanceSq; });\n        matches.some(function (m) {\n            return (result = m.callback(m.feature, m.layer, m.geometry));\n        });\n        return result;\n    };\n    /**\n     * @abstract\n     * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n     * @param {import(\"../PluggableMap.js\").FrameState} frameState FrameState.\n     * @param {number} hitTolerance Hit tolerance in pixels.\n     * @param {function(import(\"../layer/Layer.js\").default, (Uint8ClampedArray|Uint8Array)): T} callback Layer\n     *     callback.\n     * @param {function(import(\"../layer/Layer.js\").default): boolean} layerFilter Layer filter\n     *     function, only layers which are visible and for which this function\n     *     returns `true` will be tested for features.  By default, all visible\n     *     layers will be tested.\n     * @return {T|undefined} Callback result.\n     * @template T\n     */\n    MapRenderer.prototype.forEachLayerAtPixel = function (pixel, frameState, hitTolerance, callback, layerFilter) {\n        return abstract();\n    };\n    /**\n     * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {import(\"../PluggableMap.js\").FrameState} frameState FrameState.\n     * @param {number} hitTolerance Hit tolerance in pixels.\n     * @param {boolean} checkWrapped Check for wrapped geometries.\n     * @param {function(this: U, import(\"../layer/Layer.js\").default): boolean} layerFilter Layer filter\n     *     function, only layers which are visible and for which this function\n     *     returns `true` will be tested for features.  By default, all visible\n     *     layers will be tested.\n     * @param {U} thisArg Value to use as `this` when executing `layerFilter`.\n     * @return {boolean} Is there a feature at the given coordinate?\n     * @template U\n     */\n    MapRenderer.prototype.hasFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, checkWrapped, layerFilter, thisArg) {\n        var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, TRUE, this, layerFilter, thisArg);\n        return hasFeature !== undefined;\n    };\n    /**\n     * @return {import(\"../PluggableMap.js\").default} Map.\n     */\n    MapRenderer.prototype.getMap = function () {\n        return this.map_;\n    };\n    /**\n     * Render.\n     * @abstract\n     * @param {?import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n     */\n    MapRenderer.prototype.renderFrame = function (frameState) {\n        abstract();\n    };\n    /**\n     * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n     * @protected\n     */\n    MapRenderer.prototype.scheduleExpireIconCache = function (frameState) {\n        if (iconImageCache.canExpireCache()) {\n            frameState.postRenderFunctions.push(expireIconCache);\n        }\n    };\n    return MapRenderer;\n}(Disposable));\n/**\n * @param {import(\"../PluggableMap.js\").default} map Map.\n * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n */\nfunction expireIconCache(map, frameState) {\n    iconImageCache.expire();\n}\nexport default MapRenderer;\n//# sourceMappingURL=Map.js.map"]},"metadata":{},"sourceType":"module"}