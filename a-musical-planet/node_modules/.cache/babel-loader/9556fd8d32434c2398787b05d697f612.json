{"ast":null,"code":"/**\n * @module ol/geom/flat/textpath\n */\nimport { lerp } from '../../math.js';\nimport { rotate } from './transform.js';\n/**\n * @param {Array<number>} flatCoordinates Path to put text on.\n * @param {number} offset Start offset of the `flatCoordinates`.\n * @param {number} end End offset of the `flatCoordinates`.\n * @param {number} stride Stride.\n * @param {string} text Text to place on the path.\n * @param {number} startM m along the path where the text starts.\n * @param {number} maxAngle Max angle between adjacent chars in radians.\n * @param {number} scale The product of the text scale and the device pixel ratio.\n * @param {function(string, string, Object<string, number>):number} measureAndCacheTextWidth Measure and cache text width.\n * @param {string} font The font.\n * @param {Object<string, number>} cache A cache of measured widths.\n * @param {number} rotation Rotation to apply to the flatCoordinates to determine whether text needs to be reversed.\n * @return {Array<Array<*>>} The result array (or null if `maxAngle` was\n * exceeded). Entries of the array are x, y, anchorX, angle, chunk.\n */\n\nexport function drawTextOnPath(flatCoordinates, offset, end, stride, text, startM, maxAngle, scale, measureAndCacheTextWidth, font, cache, rotation) {\n  var x2 = flatCoordinates[offset];\n  var y2 = flatCoordinates[offset + 1];\n  var x1 = 0;\n  var y1 = 0;\n  var segmentLength = 0;\n  var segmentM = 0;\n\n  function advance() {\n    x1 = x2;\n    y1 = y2;\n    offset += stride;\n    x2 = flatCoordinates[offset];\n    y2 = flatCoordinates[offset + 1];\n    segmentM += segmentLength;\n    segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n  }\n\n  do {\n    advance();\n  } while (offset < end - stride && segmentM + segmentLength < startM);\n\n  var interpolate = (startM - segmentM) / segmentLength;\n  var beginX = lerp(x1, x2, interpolate);\n  var beginY = lerp(y1, y2, interpolate);\n  var startOffset = offset - stride;\n  var startLength = segmentM;\n  var endM = startM + scale * measureAndCacheTextWidth(font, text, cache);\n\n  while (offset < end - stride && segmentM + segmentLength < endM) {\n    advance();\n  }\n\n  interpolate = (endM - segmentM) / segmentLength;\n  var endX = lerp(x1, x2, interpolate);\n  var endY = lerp(y1, y2, interpolate); // Keep text upright\n\n  var reverse;\n\n  if (rotation) {\n    var flat = [beginX, beginY, endX, endY];\n    rotate(flat, 0, 4, 2, rotation, flat, flat);\n    reverse = flat[0] > flat[2];\n  } else {\n    reverse = beginX > endX;\n  }\n\n  var PI = Math.PI;\n  var result = [];\n  var singleSegment = startOffset + stride === offset;\n  offset = startOffset;\n  segmentLength = 0;\n  segmentM = startLength;\n  x2 = flatCoordinates[offset];\n  y2 = flatCoordinates[offset + 1]; // All on the same segment\n\n  if (singleSegment) {\n    advance();\n    var previousAngle_1 = Math.atan2(y2 - y1, x2 - x1);\n\n    if (reverse) {\n      previousAngle_1 += previousAngle_1 > 0 ? -PI : PI;\n    }\n\n    var x = (endX + beginX) / 2;\n    var y = (endY + beginY) / 2;\n    result[0] = [x, y, (endM - startM) / 2, previousAngle_1, text];\n    return result;\n  }\n\n  var previousAngle;\n\n  for (var i = 0, ii = text.length; i < ii;) {\n    advance();\n    var angle = Math.atan2(y2 - y1, x2 - x1);\n\n    if (reverse) {\n      angle += angle > 0 ? -PI : PI;\n    }\n\n    if (previousAngle !== undefined) {\n      var delta = angle - previousAngle;\n      delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;\n\n      if (Math.abs(delta) > maxAngle) {\n        return null;\n      }\n    }\n\n    previousAngle = angle;\n    var iStart = i;\n    var charLength = 0;\n\n    for (; i < ii; ++i) {\n      var index = reverse ? ii - i - 1 : i;\n      var len = scale * measureAndCacheTextWidth(font, text[index], cache);\n\n      if (offset + stride < end && segmentM + segmentLength < startM + charLength + len / 2) {\n        break;\n      }\n\n      charLength += len;\n    }\n\n    if (i === iStart) {\n      continue;\n    }\n\n    var chars = reverse ? text.substring(ii - iStart, ii - i) : text.substring(iStart, i);\n    interpolate = (startM + charLength / 2 - segmentM) / segmentLength;\n    var x = lerp(x1, x2, interpolate);\n    var y = lerp(y1, y2, interpolate);\n    result.push([x, y, charLength / 2, angle, chars]);\n    startM += charLength;\n  }\n\n  return result;\n}","map":{"version":3,"sources":["../../src/geom/flat/textpath.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @module ol/geom/flat/textpath\n */\nimport { lerp } from '../../math.js';\nimport { rotate } from './transform.js';\n/**\n * @param {Array<number>} flatCoordinates Path to put text on.\n * @param {number} offset Start offset of the `flatCoordinates`.\n * @param {number} end End offset of the `flatCoordinates`.\n * @param {number} stride Stride.\n * @param {string} text Text to place on the path.\n * @param {number} startM m along the path where the text starts.\n * @param {number} maxAngle Max angle between adjacent chars in radians.\n * @param {number} scale The product of the text scale and the device pixel ratio.\n * @param {function(string, string, Object<string, number>):number} measureAndCacheTextWidth Measure and cache text width.\n * @param {string} font The font.\n * @param {Object<string, number>} cache A cache of measured widths.\n * @param {number} rotation Rotation to apply to the flatCoordinates to determine whether text needs to be reversed.\n * @return {Array<Array<*>>} The result array (or null if `maxAngle` was\n * exceeded). Entries of the array are x, y, anchorX, angle, chunk.\n */\nexport function drawTextOnPath(flatCoordinates, offset, end, stride, text, startM, maxAngle, scale, measureAndCacheTextWidth, font, cache, rotation) {\n    var x2 = flatCoordinates[offset];\n    var y2 = flatCoordinates[offset + 1];\n    var x1 = 0;\n    var y1 = 0;\n    var segmentLength = 0;\n    var segmentM = 0;\n    function advance() {\n        x1 = x2;\n        y1 = y2;\n        offset += stride;\n        x2 = flatCoordinates[offset];\n        y2 = flatCoordinates[offset + 1];\n        segmentM += segmentLength;\n        segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n    }\n    do {\n        advance();\n    } while (offset < end - stride && segmentM + segmentLength < startM);\n    var interpolate = (startM - segmentM) / segmentLength;\n    var beginX = lerp(x1, x2, interpolate);\n    var beginY = lerp(y1, y2, interpolate);\n    var startOffset = offset - stride;\n    var startLength = segmentM;\n    var endM = startM + scale * measureAndCacheTextWidth(font, text, cache);\n    while (offset < end - stride && segmentM + segmentLength < endM) {\n        advance();\n    }\n    interpolate = (endM - segmentM) / segmentLength;\n    var endX = lerp(x1, x2, interpolate);\n    var endY = lerp(y1, y2, interpolate);\n    // Keep text upright\n    var reverse;\n    if (rotation) {\n        var flat = [beginX, beginY, endX, endY];\n        rotate(flat, 0, 4, 2, rotation, flat, flat);\n        reverse = flat[0] > flat[2];\n    }\n    else {\n        reverse = beginX > endX;\n    }\n    var PI = Math.PI;\n    var result = [];\n    var singleSegment = startOffset + stride === offset;\n    offset = startOffset;\n    segmentLength = 0;\n    segmentM = startLength;\n    x2 = flatCoordinates[offset];\n    y2 = flatCoordinates[offset + 1];\n    // All on the same segment\n    if (singleSegment) {\n        advance();\n        var previousAngle_1 = Math.atan2(y2 - y1, x2 - x1);\n        if (reverse) {\n            previousAngle_1 += previousAngle_1 > 0 ? -PI : PI;\n        }\n        var x = (endX + beginX) / 2;\n        var y = (endY + beginY) / 2;\n        result[0] = [x, y, (endM - startM) / 2, previousAngle_1, text];\n        return result;\n    }\n    var previousAngle;\n    for (var i = 0, ii = text.length; i < ii;) {\n        advance();\n        var angle = Math.atan2(y2 - y1, x2 - x1);\n        if (reverse) {\n            angle += angle > 0 ? -PI : PI;\n        }\n        if (previousAngle !== undefined) {\n            var delta = angle - previousAngle;\n            delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;\n            if (Math.abs(delta) > maxAngle) {\n                return null;\n            }\n        }\n        previousAngle = angle;\n        var iStart = i;\n        var charLength = 0;\n        for (; i < ii; ++i) {\n            var index = reverse ? ii - i - 1 : i;\n            var len = scale * measureAndCacheTextWidth(font, text[index], cache);\n            if (offset + stride < end &&\n                segmentM + segmentLength < startM + charLength + len / 2) {\n                break;\n            }\n            charLength += len;\n        }\n        if (i === iStart) {\n            continue;\n        }\n        var chars = reverse\n            ? text.substring(ii - iStart, ii - i)\n            : text.substring(iStart, i);\n        interpolate = (startM + charLength / 2 - segmentM) / segmentLength;\n        var x = lerp(x1, x2, interpolate);\n        var y = lerp(y1, y2, interpolate);\n        result.push([x, y, charLength / 2, angle, chars]);\n        startM += charLength;\n    }\n    return result;\n}\n//# sourceMappingURL=textpath.js.map"]},"metadata":{},"sourceType":"module"}