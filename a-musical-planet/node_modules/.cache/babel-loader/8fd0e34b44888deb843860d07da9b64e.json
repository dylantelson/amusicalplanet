{"ast":null,"code":"/**\n * @module ol/render/canvas/hitdetect\n */\nimport CanvasImmediateRenderer from './Immediate.js';\nimport GeometryType from '../../geom/GeometryType.js';\nimport IconAnchorUnits from '../../style/IconAnchorUnits.js';\nimport { Icon } from '../../style.js';\nimport { clamp } from '../../math.js';\nimport { createCanvasContext2D } from '../../dom.js';\nimport { intersects } from '../../extent.js';\nimport { numberSafeCompareFunction } from '../../array.js';\nexport var HIT_DETECT_RESOLUTION = 0.5;\n/**\n * @param {import(\"../../size.js\").Size} size Canvas size in css pixels.\n * @param {Array<import(\"../../transform.js\").Transform>} transforms Transforms\n * for rendering features to all worlds of the viewport, from coordinates to css\n * pixels.\n * @param {Array<import(\"../../Feature.js\").FeatureLike>} features\n * Features to consider for hit detection.\n * @param {import(\"../../style/Style.js\").StyleFunction|undefined} styleFunction\n * Layer style function.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @param {number} resolution Resolution.\n * @param {number} rotation Rotation.\n * @return {ImageData} Hit detection image data.\n */\n\nexport function createHitDetectionImageData(size, transforms, features, styleFunction, extent, resolution, rotation) {\n  var width = size[0] * HIT_DETECT_RESOLUTION;\n  var height = size[1] * HIT_DETECT_RESOLUTION;\n  var context = createCanvasContext2D(width, height);\n  context.imageSmoothingEnabled = false;\n  var canvas = context.canvas;\n  var renderer = new CanvasImmediateRenderer(context, HIT_DETECT_RESOLUTION, extent, null, rotation);\n  var featureCount = features.length; // Stretch hit detection index to use the whole available color range\n\n  var indexFactor = Math.floor((256 * 256 * 256 - 1) / featureCount);\n  var featuresByZIndex = {};\n\n  for (var i = 1; i <= featureCount; ++i) {\n    var feature = features[i - 1];\n    var featureStyleFunction = feature.getStyleFunction() || styleFunction;\n\n    if (!styleFunction) {\n      continue;\n    }\n\n    var styles = featureStyleFunction(feature, resolution);\n\n    if (!styles) {\n      continue;\n    }\n\n    if (!Array.isArray(styles)) {\n      styles = [styles];\n    }\n\n    var index = i * indexFactor;\n    var color = '#' + ('000000' + index.toString(16)).slice(-6);\n\n    for (var j = 0, jj = styles.length; j < jj; ++j) {\n      var originalStyle = styles[j];\n      var geometry = originalStyle.getGeometryFunction()(feature);\n\n      if (!geometry || !intersects(extent, geometry.getExtent())) {\n        continue;\n      }\n\n      var style = originalStyle.clone();\n      var fill = style.getFill();\n\n      if (fill) {\n        fill.setColor(color);\n      }\n\n      var stroke = style.getStroke();\n\n      if (stroke) {\n        stroke.setColor(color);\n        stroke.setLineDash(null);\n      }\n\n      style.setText(undefined);\n      var image = originalStyle.getImage();\n\n      if (image && image.getOpacity() !== 0) {\n        var imgSize = image.getImageSize();\n\n        if (!imgSize) {\n          continue;\n        }\n\n        var imgContext = createCanvasContext2D(imgSize[0], imgSize[1], undefined, {\n          alpha: false\n        });\n        var img = imgContext.canvas;\n        imgContext.fillStyle = color;\n        imgContext.fillRect(0, 0, img.width, img.height);\n        style.setImage(new Icon({\n          img: img,\n          imgSize: imgSize,\n          anchor: image.getAnchor(),\n          anchorXUnits: IconAnchorUnits.PIXELS,\n          anchorYUnits: IconAnchorUnits.PIXELS,\n          offset: image.getOrigin(),\n          opacity: 1,\n          size: image.getSize(),\n          scale: image.getScale(),\n          rotation: image.getRotation(),\n          rotateWithView: image.getRotateWithView()\n        }));\n      }\n\n      var zIndex = style.getZIndex() || 0;\n      var byGeometryType = featuresByZIndex[zIndex];\n\n      if (!byGeometryType) {\n        byGeometryType = {};\n        featuresByZIndex[zIndex] = byGeometryType;\n        byGeometryType[GeometryType.POLYGON] = [];\n        byGeometryType[GeometryType.CIRCLE] = [];\n        byGeometryType[GeometryType.LINE_STRING] = [];\n        byGeometryType[GeometryType.POINT] = [];\n      }\n\n      byGeometryType[geometry.getType().replace('Multi', '')].push(geometry, style);\n    }\n  }\n\n  var zIndexKeys = Object.keys(featuresByZIndex).map(Number).sort(numberSafeCompareFunction);\n\n  for (var i = 0, ii = zIndexKeys.length; i < ii; ++i) {\n    var byGeometryType = featuresByZIndex[zIndexKeys[i]];\n\n    for (var type in byGeometryType) {\n      var geomAndStyle = byGeometryType[type];\n\n      for (var j = 0, jj = geomAndStyle.length; j < jj; j += 2) {\n        renderer.setStyle(geomAndStyle[j + 1]);\n\n        for (var k = 0, kk = transforms.length; k < kk; ++k) {\n          renderer.setTransform(transforms[k]);\n          renderer.drawGeometry(geomAndStyle[j]);\n        }\n      }\n    }\n  }\n\n  return context.getImageData(0, 0, canvas.width, canvas.height);\n}\n/**\n * @param {import(\"../../pixel\").Pixel} pixel Pixel coordinate on the hit\n * detection canvas in css pixels.\n * @param {Array<import(\"../../Feature\").FeatureLike>} features Features. Has to\n * match the `features` array that was passed to `createHitDetectionImageData()`.\n * @param {ImageData} imageData Hit detection image data generated by\n * `createHitDetectionImageData()`.\n * @return {Array<import(\"../../Feature\").FeatureLike>} features Features.\n */\n\nexport function hitDetect(pixel, features, imageData) {\n  var resultFeatures = [];\n\n  if (imageData) {\n    var x = Math.floor(Math.round(pixel[0]) * HIT_DETECT_RESOLUTION);\n    var y = Math.floor(Math.round(pixel[1]) * HIT_DETECT_RESOLUTION); // The pixel coordinate is clamped down to the hit-detect canvas' size to account\n    // for browsers returning coordinates slightly larger than the actual canvas size\n    // due to a non-integer pixel ratio.\n\n    var index = (clamp(x, 0, imageData.width - 1) + clamp(y, 0, imageData.height - 1) * imageData.width) * 4;\n    var r = imageData.data[index];\n    var g = imageData.data[index + 1];\n    var b = imageData.data[index + 2];\n    var i = b + 256 * (g + 256 * r);\n    var indexFactor = Math.floor((256 * 256 * 256 - 1) / features.length);\n\n    if (i && i % indexFactor === 0) {\n      resultFeatures.push(features[i / indexFactor - 1]);\n    }\n  }\n\n  return resultFeatures;\n}","map":{"version":3,"sources":["../../src/render/canvas/hitdetect.js"],"names":[],"mappings":"AAAA;;AAEG;AAEH,OAAO,uBAAP,MAAoC,gBAApC;AACA,OAAO,YAAP,MAAyB,4BAAzB;AACA,OAAO,eAAP,MAA4B,gCAA5B;AACA,SAAQ,IAAR,QAAmB,gBAAnB;AACA,SAAQ,KAAR,QAAoB,eAApB;AACA,SAAQ,qBAAR,QAAoC,cAApC;AACA,SAAQ,UAAR,QAAyB,iBAAzB;AACA,SAAQ,yBAAR,QAAwC,gBAAxC;AAEA,OAAO,IAAM,qBAAqB,GAAG,GAA9B;AAEP;;;;;;;;;;;;;AAaG;;AACH,OAAM,SAAU,2BAAV,CACJ,IADI,EAEJ,UAFI,EAGJ,QAHI,EAIJ,aAJI,EAKJ,MALI,EAMJ,UANI,EAOJ,QAPI,EAOI;AAER,MAAM,KAAK,GAAG,IAAI,CAAC,CAAD,CAAJ,GAAU,qBAAxB;AACA,MAAM,MAAM,GAAG,IAAI,CAAC,CAAD,CAAJ,GAAU,qBAAzB;AACA,MAAM,OAAO,GAAG,qBAAqB,CAAC,KAAD,EAAQ,MAAR,CAArC;AACA,EAAA,OAAO,CAAC,qBAAR,GAAgC,KAAhC;AACA,MAAM,MAAM,GAAG,OAAO,CAAC,MAAvB;AACA,MAAM,QAAQ,GAAG,IAAI,uBAAJ,CACf,OADe,EAEf,qBAFe,EAGf,MAHe,EAIf,IAJe,EAKf,QALe,CAAjB;AAOA,MAAM,YAAY,GAAG,QAAQ,CAAC,MAA9B,CAdQ,CAeR;;AACA,MAAM,WAAW,GAAG,IAAI,CAAC,KAAL,CAAW,CAAC,MAAM,GAAN,GAAY,GAAZ,GAAkB,CAAnB,IAAwB,YAAnC,CAApB;AACA,MAAM,gBAAgB,GAAG,EAAzB;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,IAAI,YAArB,EAAmC,EAAE,CAArC,EAAwC;AACtC,QAAM,OAAO,GAAG,QAAQ,CAAC,CAAC,GAAG,CAAL,CAAxB;AACA,QAAM,oBAAoB,GAAG,OAAO,CAAC,gBAAR,MAA8B,aAA3D;;AACA,QAAI,CAAC,aAAL,EAAoB;AAClB;AACD;;AACD,QAAI,MAAM,GAAG,oBAAoB,CAAC,OAAD,EAAU,UAAV,CAAjC;;AACA,QAAI,CAAC,MAAL,EAAa;AACX;AACD;;AACD,QAAI,CAAC,KAAK,CAAC,OAAN,CAAc,MAAd,CAAL,EAA4B;AAC1B,MAAA,MAAM,GAAG,CAAC,MAAD,CAAT;AACD;;AACD,QAAM,KAAK,GAAG,CAAC,GAAG,WAAlB;AACA,QAAM,KAAK,GAAG,MAAM,CAAC,WAAW,KAAK,CAAC,QAAN,CAAe,EAAf,CAAZ,EAAgC,KAAhC,CAAsC,CAAC,CAAvC,CAApB;;AACA,SAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,MAAM,CAAC,MAA5B,EAAoC,CAAC,GAAG,EAAxC,EAA4C,EAAE,CAA9C,EAAiD;AAC/C,UAAM,aAAa,GAAG,MAAM,CAAC,CAAD,CAA5B;AACA,UAAM,QAAQ,GAAG,aAAa,CAAC,mBAAd,GAAoC,OAApC,CAAjB;;AACA,UAAI,CAAC,QAAD,IAAa,CAAC,UAAU,CAAC,MAAD,EAAS,QAAQ,CAAC,SAAT,EAAT,CAA5B,EAA4D;AAC1D;AACD;;AACD,UAAM,KAAK,GAAG,aAAa,CAAC,KAAd,EAAd;AACA,UAAM,IAAI,GAAG,KAAK,CAAC,OAAN,EAAb;;AACA,UAAI,IAAJ,EAAU;AACR,QAAA,IAAI,CAAC,QAAL,CAAc,KAAd;AACD;;AACD,UAAM,MAAM,GAAG,KAAK,CAAC,SAAN,EAAf;;AACA,UAAI,MAAJ,EAAY;AACV,QAAA,MAAM,CAAC,QAAP,CAAgB,KAAhB;AACA,QAAA,MAAM,CAAC,WAAP,CAAmB,IAAnB;AACD;;AACD,MAAA,KAAK,CAAC,OAAN,CAAc,SAAd;AACA,UAAM,KAAK,GAAG,aAAa,CAAC,QAAd,EAAd;;AACA,UAAI,KAAK,IAAI,KAAK,CAAC,UAAN,OAAuB,CAApC,EAAuC;AACrC,YAAM,OAAO,GAAG,KAAK,CAAC,YAAN,EAAhB;;AACA,YAAI,CAAC,OAAL,EAAc;AACZ;AACD;;AAED,YAAM,UAAU,GAAG,qBAAqB,CACtC,OAAO,CAAC,CAAD,CAD+B,EAEtC,OAAO,CAAC,CAAD,CAF+B,EAGtC,SAHsC,EAItC;AAAC,UAAA,KAAK,EAAE;AAAR,SAJsC,CAAxC;AAMA,YAAM,GAAG,GAAG,UAAU,CAAC,MAAvB;AACA,QAAA,UAAU,CAAC,SAAX,GAAuB,KAAvB;AACA,QAAA,UAAU,CAAC,QAAX,CAAoB,CAApB,EAAuB,CAAvB,EAA0B,GAAG,CAAC,KAA9B,EAAqC,GAAG,CAAC,MAAzC;AACA,QAAA,KAAK,CAAC,QAAN,CACE,IAAI,IAAJ,CAAS;AACP,UAAA,GAAG,EAAE,GADE;AAEP,UAAA,OAAO,EAAE,OAFF;AAGP,UAAA,MAAM,EAAE,KAAK,CAAC,SAAN,EAHD;AAIP,UAAA,YAAY,EAAE,eAAe,CAAC,MAJvB;AAKP,UAAA,YAAY,EAAE,eAAe,CAAC,MALvB;AAMP,UAAA,MAAM,EAAE,KAAK,CAAC,SAAN,EAND;AAOP,UAAA,OAAO,EAAE,CAPF;AAQP,UAAA,IAAI,EAAE,KAAK,CAAC,OAAN,EARC;AASP,UAAA,KAAK,EAAE,KAAK,CAAC,QAAN,EATA;AAUP,UAAA,QAAQ,EAAE,KAAK,CAAC,WAAN,EAVH;AAWP,UAAA,cAAc,EAAE,KAAK,CAAC,iBAAN;AAXT,SAAT,CADF;AAeD;;AACD,UAAM,MAAM,GAAG,KAAK,CAAC,SAAN,MAAqB,CAApC;AACA,UAAI,cAAc,GAAG,gBAAgB,CAAC,MAAD,CAArC;;AACA,UAAI,CAAC,cAAL,EAAqB;AACnB,QAAA,cAAc,GAAG,EAAjB;AACA,QAAA,gBAAgB,CAAC,MAAD,CAAhB,GAA2B,cAA3B;AACA,QAAA,cAAc,CAAC,YAAY,CAAC,OAAd,CAAd,GAAuC,EAAvC;AACA,QAAA,cAAc,CAAC,YAAY,CAAC,MAAd,CAAd,GAAsC,EAAtC;AACA,QAAA,cAAc,CAAC,YAAY,CAAC,WAAd,CAAd,GAA2C,EAA3C;AACA,QAAA,cAAc,CAAC,YAAY,CAAC,KAAd,CAAd,GAAqC,EAArC;AACD;;AACD,MAAA,cAAc,CAAC,QAAQ,CAAC,OAAT,GAAmB,OAAnB,CAA2B,OAA3B,EAAoC,EAApC,CAAD,CAAd,CAAwD,IAAxD,CACE,QADF,EAEE,KAFF;AAID;AACF;;AAED,MAAM,UAAU,GAAG,MAAM,CAAC,IAAP,CAAY,gBAAZ,EAChB,GADgB,CACZ,MADY,EAEhB,IAFgB,CAEX,yBAFW,CAAnB;;AAGA,OAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,UAAU,CAAC,MAAhC,EAAwC,CAAC,GAAG,EAA5C,EAAgD,EAAE,CAAlD,EAAqD;AACnD,QAAM,cAAc,GAAG,gBAAgB,CAAC,UAAU,CAAC,CAAD,CAAX,CAAvC;;AACA,SAAK,IAAM,IAAX,IAAmB,cAAnB,EAAmC;AACjC,UAAM,YAAY,GAAG,cAAc,CAAC,IAAD,CAAnC;;AACA,WAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,YAAY,CAAC,MAAlC,EAA0C,CAAC,GAAG,EAA9C,EAAkD,CAAC,IAAI,CAAvD,EAA0D;AACxD,QAAA,QAAQ,CAAC,QAAT,CAAkB,YAAY,CAAC,CAAC,GAAG,CAAL,CAA9B;;AACA,aAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,UAAU,CAAC,MAAhC,EAAwC,CAAC,GAAG,EAA5C,EAAgD,EAAE,CAAlD,EAAqD;AACnD,UAAA,QAAQ,CAAC,YAAT,CAAsB,UAAU,CAAC,CAAD,CAAhC;AACA,UAAA,QAAQ,CAAC,YAAT,CAAsB,YAAY,CAAC,CAAD,CAAlC;AACD;AACF;AACF;AACF;;AACD,SAAO,OAAO,CAAC,YAAR,CAAqB,CAArB,EAAwB,CAAxB,EAA2B,MAAM,CAAC,KAAlC,EAAyC,MAAM,CAAC,MAAhD,CAAP;AACD;AAED;;;;;;;;AAQG;;AACH,OAAM,SAAU,SAAV,CAAoB,KAApB,EAA2B,QAA3B,EAAqC,SAArC,EAA8C;AAClD,MAAM,cAAc,GAAG,EAAvB;;AACA,MAAI,SAAJ,EAAe;AACb,QAAM,CAAC,GAAG,IAAI,CAAC,KAAL,CAAW,IAAI,CAAC,KAAL,CAAW,KAAK,CAAC,CAAD,CAAhB,IAAuB,qBAAlC,CAAV;AACA,QAAM,CAAC,GAAG,IAAI,CAAC,KAAL,CAAW,IAAI,CAAC,KAAL,CAAW,KAAK,CAAC,CAAD,CAAhB,IAAuB,qBAAlC,CAAV,CAFa,CAGb;AACA;AACA;;AACA,QAAM,KAAK,GACT,CAAC,KAAK,CAAC,CAAD,EAAI,CAAJ,EAAO,SAAS,CAAC,KAAV,GAAkB,CAAzB,CAAL,GACC,KAAK,CAAC,CAAD,EAAI,CAAJ,EAAO,SAAS,CAAC,MAAV,GAAmB,CAA1B,CAAL,GAAoC,SAAS,CAAC,KADhD,IAEA,CAHF;AAIA,QAAM,CAAC,GAAG,SAAS,CAAC,IAAV,CAAe,KAAf,CAAV;AACA,QAAM,CAAC,GAAG,SAAS,CAAC,IAAV,CAAe,KAAK,GAAG,CAAvB,CAAV;AACA,QAAM,CAAC,GAAG,SAAS,CAAC,IAAV,CAAe,KAAK,GAAG,CAAvB,CAAV;AACA,QAAM,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC,GAAG,MAAM,CAAjB,CAAd;AACA,QAAM,WAAW,GAAG,IAAI,CAAC,KAAL,CAAW,CAAC,MAAM,GAAN,GAAY,GAAZ,GAAkB,CAAnB,IAAwB,QAAQ,CAAC,MAA5C,CAApB;;AACA,QAAI,CAAC,IAAI,CAAC,GAAG,WAAJ,KAAoB,CAA7B,EAAgC;AAC9B,MAAA,cAAc,CAAC,IAAf,CAAoB,QAAQ,CAAC,CAAC,GAAG,WAAJ,GAAkB,CAAnB,CAA5B;AACD;AACF;;AACD,SAAO,cAAP;AACD","sourceRoot":"","sourcesContent":["/**\n * @module ol/render/canvas/hitdetect\n */\nimport CanvasImmediateRenderer from './Immediate.js';\nimport GeometryType from '../../geom/GeometryType.js';\nimport IconAnchorUnits from '../../style/IconAnchorUnits.js';\nimport { Icon } from '../../style.js';\nimport { clamp } from '../../math.js';\nimport { createCanvasContext2D } from '../../dom.js';\nimport { intersects } from '../../extent.js';\nimport { numberSafeCompareFunction } from '../../array.js';\nexport var HIT_DETECT_RESOLUTION = 0.5;\n/**\n * @param {import(\"../../size.js\").Size} size Canvas size in css pixels.\n * @param {Array<import(\"../../transform.js\").Transform>} transforms Transforms\n * for rendering features to all worlds of the viewport, from coordinates to css\n * pixels.\n * @param {Array<import(\"../../Feature.js\").FeatureLike>} features\n * Features to consider for hit detection.\n * @param {import(\"../../style/Style.js\").StyleFunction|undefined} styleFunction\n * Layer style function.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @param {number} resolution Resolution.\n * @param {number} rotation Rotation.\n * @return {ImageData} Hit detection image data.\n */\nexport function createHitDetectionImageData(size, transforms, features, styleFunction, extent, resolution, rotation) {\n    var width = size[0] * HIT_DETECT_RESOLUTION;\n    var height = size[1] * HIT_DETECT_RESOLUTION;\n    var context = createCanvasContext2D(width, height);\n    context.imageSmoothingEnabled = false;\n    var canvas = context.canvas;\n    var renderer = new CanvasImmediateRenderer(context, HIT_DETECT_RESOLUTION, extent, null, rotation);\n    var featureCount = features.length;\n    // Stretch hit detection index to use the whole available color range\n    var indexFactor = Math.floor((256 * 256 * 256 - 1) / featureCount);\n    var featuresByZIndex = {};\n    for (var i = 1; i <= featureCount; ++i) {\n        var feature = features[i - 1];\n        var featureStyleFunction = feature.getStyleFunction() || styleFunction;\n        if (!styleFunction) {\n            continue;\n        }\n        var styles = featureStyleFunction(feature, resolution);\n        if (!styles) {\n            continue;\n        }\n        if (!Array.isArray(styles)) {\n            styles = [styles];\n        }\n        var index = i * indexFactor;\n        var color = '#' + ('000000' + index.toString(16)).slice(-6);\n        for (var j = 0, jj = styles.length; j < jj; ++j) {\n            var originalStyle = styles[j];\n            var geometry = originalStyle.getGeometryFunction()(feature);\n            if (!geometry || !intersects(extent, geometry.getExtent())) {\n                continue;\n            }\n            var style = originalStyle.clone();\n            var fill = style.getFill();\n            if (fill) {\n                fill.setColor(color);\n            }\n            var stroke = style.getStroke();\n            if (stroke) {\n                stroke.setColor(color);\n                stroke.setLineDash(null);\n            }\n            style.setText(undefined);\n            var image = originalStyle.getImage();\n            if (image && image.getOpacity() !== 0) {\n                var imgSize = image.getImageSize();\n                if (!imgSize) {\n                    continue;\n                }\n                var imgContext = createCanvasContext2D(imgSize[0], imgSize[1], undefined, { alpha: false });\n                var img = imgContext.canvas;\n                imgContext.fillStyle = color;\n                imgContext.fillRect(0, 0, img.width, img.height);\n                style.setImage(new Icon({\n                    img: img,\n                    imgSize: imgSize,\n                    anchor: image.getAnchor(),\n                    anchorXUnits: IconAnchorUnits.PIXELS,\n                    anchorYUnits: IconAnchorUnits.PIXELS,\n                    offset: image.getOrigin(),\n                    opacity: 1,\n                    size: image.getSize(),\n                    scale: image.getScale(),\n                    rotation: image.getRotation(),\n                    rotateWithView: image.getRotateWithView(),\n                }));\n            }\n            var zIndex = style.getZIndex() || 0;\n            var byGeometryType = featuresByZIndex[zIndex];\n            if (!byGeometryType) {\n                byGeometryType = {};\n                featuresByZIndex[zIndex] = byGeometryType;\n                byGeometryType[GeometryType.POLYGON] = [];\n                byGeometryType[GeometryType.CIRCLE] = [];\n                byGeometryType[GeometryType.LINE_STRING] = [];\n                byGeometryType[GeometryType.POINT] = [];\n            }\n            byGeometryType[geometry.getType().replace('Multi', '')].push(geometry, style);\n        }\n    }\n    var zIndexKeys = Object.keys(featuresByZIndex)\n        .map(Number)\n        .sort(numberSafeCompareFunction);\n    for (var i = 0, ii = zIndexKeys.length; i < ii; ++i) {\n        var byGeometryType = featuresByZIndex[zIndexKeys[i]];\n        for (var type in byGeometryType) {\n            var geomAndStyle = byGeometryType[type];\n            for (var j = 0, jj = geomAndStyle.length; j < jj; j += 2) {\n                renderer.setStyle(geomAndStyle[j + 1]);\n                for (var k = 0, kk = transforms.length; k < kk; ++k) {\n                    renderer.setTransform(transforms[k]);\n                    renderer.drawGeometry(geomAndStyle[j]);\n                }\n            }\n        }\n    }\n    return context.getImageData(0, 0, canvas.width, canvas.height);\n}\n/**\n * @param {import(\"../../pixel\").Pixel} pixel Pixel coordinate on the hit\n * detection canvas in css pixels.\n * @param {Array<import(\"../../Feature\").FeatureLike>} features Features. Has to\n * match the `features` array that was passed to `createHitDetectionImageData()`.\n * @param {ImageData} imageData Hit detection image data generated by\n * `createHitDetectionImageData()`.\n * @return {Array<import(\"../../Feature\").FeatureLike>} features Features.\n */\nexport function hitDetect(pixel, features, imageData) {\n    var resultFeatures = [];\n    if (imageData) {\n        var x = Math.floor(Math.round(pixel[0]) * HIT_DETECT_RESOLUTION);\n        var y = Math.floor(Math.round(pixel[1]) * HIT_DETECT_RESOLUTION);\n        // The pixel coordinate is clamped down to the hit-detect canvas' size to account\n        // for browsers returning coordinates slightly larger than the actual canvas size\n        // due to a non-integer pixel ratio.\n        var index = (clamp(x, 0, imageData.width - 1) +\n            clamp(y, 0, imageData.height - 1) * imageData.width) *\n            4;\n        var r = imageData.data[index];\n        var g = imageData.data[index + 1];\n        var b = imageData.data[index + 2];\n        var i = b + 256 * (g + 256 * r);\n        var indexFactor = Math.floor((256 * 256 * 256 - 1) / features.length);\n        if (i && i % indexFactor === 0) {\n            resultFeatures.push(features[i / indexFactor - 1]);\n        }\n    }\n    return resultFeatures;\n}\n//# sourceMappingURL=hitdetect.js.map"]},"metadata":{},"sourceType":"module"}