{"ast":null,"code":"/**\n * @module ol/geom/flat/orient\n */\nimport { coordinates as reverseCoordinates } from './reverse.js';\n/**\n * Is the linear ring oriented clockwise in a coordinate system with a bottom-left\n * coordinate origin? For a coordinate system with a top-left coordinate origin,\n * the ring's orientation is clockwise when this function returns false.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {boolean} Is clockwise.\n */\n\nexport function linearRingIsClockwise(flatCoordinates, offset, end, stride) {\n  // https://stackoverflow.com/q/1165647/clockwise-method#1165943\n  // https://github.com/OSGeo/gdal/blob/master/gdal/ogr/ogrlinearring.cpp\n  var edge = 0;\n  var x1 = flatCoordinates[end - stride];\n  var y1 = flatCoordinates[end - stride + 1];\n\n  for (; offset < end; offset += stride) {\n    var x2 = flatCoordinates[offset];\n    var y2 = flatCoordinates[offset + 1];\n    edge += (x2 - x1) * (y2 + y1);\n    x1 = x2;\n    y1 = y2;\n  }\n\n  return edge === 0 ? undefined : edge > 0;\n}\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean} [opt_right] Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\n\nexport function linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right) {\n  var right = opt_right !== undefined ? opt_right : false;\n\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);\n\n    if (i === 0) {\n      if (right && isClockwise || !right && !isClockwise) {\n        return false;\n      }\n    } else {\n      if (right && !isClockwise || !right && isClockwise) {\n        return false;\n      }\n    }\n\n    offset = end;\n  }\n\n  return true;\n}\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean} [opt_right] Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\n\nexport function linearRingssAreOriented(flatCoordinates, offset, endss, stride, opt_right) {\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n\n    if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right)) {\n      return false;\n    }\n\n    if (ends.length) {\n      offset = ends[ends.length - 1];\n    }\n  }\n\n  return true;\n}\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {boolean} [opt_right] Follow the right-hand rule for orientation.\n * @return {number} End.\n */\n\nexport function orientLinearRings(flatCoordinates, offset, ends, stride, opt_right) {\n  var right = opt_right !== undefined ? opt_right : false;\n\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);\n    var reverse = i === 0 ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise;\n\n    if (reverse) {\n      reverseCoordinates(flatCoordinates, offset, end, stride);\n    }\n\n    offset = end;\n  }\n\n  return offset;\n}\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean} [opt_right] Follow the right-hand rule for orientation.\n * @return {number} End.\n */\n\nexport function orientLinearRingsArray(flatCoordinates, offset, endss, stride, opt_right) {\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    offset = orientLinearRings(flatCoordinates, offset, endss[i], stride, opt_right);\n  }\n\n  return offset;\n}","map":{"version":3,"sources":["../../src/geom/flat/orient.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @module ol/geom/flat/orient\n */\nimport { coordinates as reverseCoordinates } from './reverse.js';\n/**\n * Is the linear ring oriented clockwise in a coordinate system with a bottom-left\n * coordinate origin? For a coordinate system with a top-left coordinate origin,\n * the ring's orientation is clockwise when this function returns false.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {boolean} Is clockwise.\n */\nexport function linearRingIsClockwise(flatCoordinates, offset, end, stride) {\n    // https://stackoverflow.com/q/1165647/clockwise-method#1165943\n    // https://github.com/OSGeo/gdal/blob/master/gdal/ogr/ogrlinearring.cpp\n    var edge = 0;\n    var x1 = flatCoordinates[end - stride];\n    var y1 = flatCoordinates[end - stride + 1];\n    for (; offset < end; offset += stride) {\n        var x2 = flatCoordinates[offset];\n        var y2 = flatCoordinates[offset + 1];\n        edge += (x2 - x1) * (y2 + y1);\n        x1 = x2;\n        y1 = y2;\n    }\n    return edge === 0 ? undefined : edge > 0;\n}\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean} [opt_right] Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\nexport function linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right) {\n    var right = opt_right !== undefined ? opt_right : false;\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);\n        if (i === 0) {\n            if ((right && isClockwise) || (!right && !isClockwise)) {\n                return false;\n            }\n        }\n        else {\n            if ((right && !isClockwise) || (!right && isClockwise)) {\n                return false;\n            }\n        }\n        offset = end;\n    }\n    return true;\n}\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean} [opt_right] Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\nexport function linearRingssAreOriented(flatCoordinates, offset, endss, stride, opt_right) {\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right)) {\n            return false;\n        }\n        if (ends.length) {\n            offset = ends[ends.length - 1];\n        }\n    }\n    return true;\n}\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {boolean} [opt_right] Follow the right-hand rule for orientation.\n * @return {number} End.\n */\nexport function orientLinearRings(flatCoordinates, offset, ends, stride, opt_right) {\n    var right = opt_right !== undefined ? opt_right : false;\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n        var end = ends[i];\n        var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);\n        var reverse = i === 0\n            ? (right && isClockwise) || (!right && !isClockwise)\n            : (right && !isClockwise) || (!right && isClockwise);\n        if (reverse) {\n            reverseCoordinates(flatCoordinates, offset, end, stride);\n        }\n        offset = end;\n    }\n    return offset;\n}\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean} [opt_right] Follow the right-hand rule for orientation.\n * @return {number} End.\n */\nexport function orientLinearRingsArray(flatCoordinates, offset, endss, stride, opt_right) {\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n        offset = orientLinearRings(flatCoordinates, offset, endss[i], stride, opt_right);\n    }\n    return offset;\n}\n//# sourceMappingURL=orient.js.map"]},"metadata":{},"sourceType":"module"}