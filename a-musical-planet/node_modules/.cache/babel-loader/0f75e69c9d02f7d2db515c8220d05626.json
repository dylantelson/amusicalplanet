{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/renderer/Layer\n */\n\n\nimport EventType from '../events/EventType.js';\nimport ImageState from '../ImageState.js';\nimport Observable from '../Observable.js';\nimport SourceState from '../source/State.js';\nimport { abstract } from '../util.js';\n/**\n * @template {import(\"../layer/Layer.js\").default} LayerType\n */\n\nvar LayerRenderer = function (_super) {\n  __extends(LayerRenderer, _super);\n  /**\n   * @param {LayerType} layer Layer.\n   */\n\n\n  function LayerRenderer(layer) {\n    var _this = _super.call(this) || this;\n    /** @private */\n\n\n    _this.boundHandleImageChange_ = _this.handleImageChange_.bind(_this);\n    /**\n     * @protected\n     * @type {LayerType}\n     */\n\n    _this.layer_ = layer;\n    /**\n     * @type {import(\"../render/canvas/ExecutorGroup\").default}\n     */\n\n    _this.declutterExecutorGroup = null;\n    return _this;\n  }\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../Feature\").default>>} Promise that resolves with\n   * an array of features.\n   */\n\n\n  LayerRenderer.prototype.getFeatures = function (pixel) {\n    return abstract();\n  };\n  /**\n   * Determine whether render should be called.\n   * @abstract\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n\n\n  LayerRenderer.prototype.prepareFrame = function (frameState) {\n    return abstract();\n  };\n  /**\n   * Render the layer.\n   * @abstract\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n\n\n  LayerRenderer.prototype.renderFrame = function (frameState, target) {\n    return abstract();\n  };\n  /**\n   * @param {Object<number, Object<string, import(\"../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @param {number} zoom Zoom level.\n   * @param {import(\"../Tile.js\").default} tile Tile.\n   * @return {boolean|void} If `false`, the tile will not be considered loaded.\n   */\n\n\n  LayerRenderer.prototype.loadedTileCallback = function (tiles, zoom, tile) {\n    if (!tiles[zoom]) {\n      tiles[zoom] = {};\n    }\n\n    tiles[zoom][tile.tileCoord.toString()] = tile;\n    return undefined;\n  };\n  /**\n   * Create a function that adds loaded tiles to the tile lookup.\n   * @param {import(\"../source/Tile.js\").default} source Tile source.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection of the tiles.\n   * @param {Object<number, Object<string, import(\"../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @return {function(number, import(\"../TileRange.js\").default):boolean} A function that can be\n   *     called with a zoom level and a tile range to add loaded tiles to the lookup.\n   * @protected\n   */\n\n\n  LayerRenderer.prototype.createLoadedTileFinder = function (source, projection, tiles) {\n    return (\n      /**\n       * @param {number} zoom Zoom level.\n       * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n       * @return {boolean} The tile range is fully loaded.\n       * @this {LayerRenderer}\n       */\n      function (zoom, tileRange) {\n        var callback = this.loadedTileCallback.bind(this, tiles, zoom);\n        return source.forEachLoadedTile(projection, zoom, tileRange, callback);\n      }.bind(this)\n    );\n  };\n  /**\n   * @abstract\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"./vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"./Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n\n\n  LayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, matches) {\n    return undefined;\n  };\n  /**\n   * @abstract\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState FrameState.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @return {Uint8ClampedArray|Uint8Array} The result.  If there is no data at the pixel\n   *    location, null will be returned.  If there is data, but pixel values cannot be\n   *    returned, and empty array will be returned.\n   */\n\n\n  LayerRenderer.prototype.getDataAtPixel = function (pixel, frameState, hitTolerance) {\n    return abstract();\n  };\n  /**\n   * @return {LayerType} Layer.\n   */\n\n\n  LayerRenderer.prototype.getLayer = function () {\n    return this.layer_;\n  };\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   * @abstract\n   */\n\n\n  LayerRenderer.prototype.handleFontsChanged = function () {};\n  /**\n   * Handle changes in image state.\n   * @param {import(\"../events/Event.js\").default} event Image change event.\n   * @private\n   */\n\n\n  LayerRenderer.prototype.handleImageChange_ = function (event) {\n    var image = event.target;\n\n    if (image.getState() === ImageState.LOADED) {\n      this.renderIfReadyAndVisible();\n    }\n  };\n  /**\n   * Load the image if not already loaded, and register the image change\n   * listener if needed.\n   * @param {import(\"../ImageBase.js\").default} image Image.\n   * @return {boolean} `true` if the image is already loaded, `false` otherwise.\n   * @protected\n   */\n\n\n  LayerRenderer.prototype.loadImage = function (image) {\n    var imageState = image.getState();\n\n    if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {\n      image.addEventListener(EventType.CHANGE, this.boundHandleImageChange_);\n    }\n\n    if (imageState == ImageState.IDLE) {\n      image.load();\n      imageState = image.getState();\n    }\n\n    return imageState == ImageState.LOADED;\n  };\n  /**\n   * @protected\n   */\n\n\n  LayerRenderer.prototype.renderIfReadyAndVisible = function () {\n    var layer = this.getLayer();\n\n    if (layer.getVisible() && layer.getSourceState() == SourceState.READY) {\n      layer.changed();\n    }\n  };\n\n  return LayerRenderer;\n}(Observable);\n\nexport default LayerRenderer;","map":{"version":3,"sources":["../src/renderer/Layer.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/renderer/Layer\n */\nimport EventType from '../events/EventType.js';\nimport ImageState from '../ImageState.js';\nimport Observable from '../Observable.js';\nimport SourceState from '../source/State.js';\nimport { abstract } from '../util.js';\n/**\n * @template {import(\"../layer/Layer.js\").default} LayerType\n */\nvar LayerRenderer = /** @class */ (function (_super) {\n    __extends(LayerRenderer, _super);\n    /**\n     * @param {LayerType} layer Layer.\n     */\n    function LayerRenderer(layer) {\n        var _this = _super.call(this) || this;\n        /** @private */\n        _this.boundHandleImageChange_ = _this.handleImageChange_.bind(_this);\n        /**\n         * @protected\n         * @type {LayerType}\n         */\n        _this.layer_ = layer;\n        /**\n         * @type {import(\"../render/canvas/ExecutorGroup\").default}\n         */\n        _this.declutterExecutorGroup = null;\n        return _this;\n    }\n    /**\n     * Asynchronous layer level hit detection.\n     * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n     * @return {Promise<Array<import(\"../Feature\").default>>} Promise that resolves with\n     * an array of features.\n     */\n    LayerRenderer.prototype.getFeatures = function (pixel) {\n        return abstract();\n    };\n    /**\n     * Determine whether render should be called.\n     * @abstract\n     * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {boolean} Layer is ready to be rendered.\n     */\n    LayerRenderer.prototype.prepareFrame = function (frameState) {\n        return abstract();\n    };\n    /**\n     * Render the layer.\n     * @abstract\n     * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n     * @param {HTMLElement} target Target that may be used to render content to.\n     * @return {HTMLElement} The rendered element.\n     */\n    LayerRenderer.prototype.renderFrame = function (frameState, target) {\n        return abstract();\n    };\n    /**\n     * @param {Object<number, Object<string, import(\"../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n     * @param {number} zoom Zoom level.\n     * @param {import(\"../Tile.js\").default} tile Tile.\n     * @return {boolean|void} If `false`, the tile will not be considered loaded.\n     */\n    LayerRenderer.prototype.loadedTileCallback = function (tiles, zoom, tile) {\n        if (!tiles[zoom]) {\n            tiles[zoom] = {};\n        }\n        tiles[zoom][tile.tileCoord.toString()] = tile;\n        return undefined;\n    };\n    /**\n     * Create a function that adds loaded tiles to the tile lookup.\n     * @param {import(\"../source/Tile.js\").default} source Tile source.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection of the tiles.\n     * @param {Object<number, Object<string, import(\"../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n     * @return {function(number, import(\"../TileRange.js\").default):boolean} A function that can be\n     *     called with a zoom level and a tile range to add loaded tiles to the lookup.\n     * @protected\n     */\n    LayerRenderer.prototype.createLoadedTileFinder = function (source, projection, tiles) {\n        return (\n        /**\n         * @param {number} zoom Zoom level.\n         * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n         * @return {boolean} The tile range is fully loaded.\n         * @this {LayerRenderer}\n         */\n        function (zoom, tileRange) {\n            var callback = this.loadedTileCallback.bind(this, tiles, zoom);\n            return source.forEachLoadedTile(projection, zoom, tileRange, callback);\n        }.bind(this));\n    };\n    /**\n     * @abstract\n     * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n     * @param {number} hitTolerance Hit tolerance in pixels.\n     * @param {import(\"./vector.js\").FeatureCallback<T>} callback Feature callback.\n     * @param {Array<import(\"./Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n     * @return {T|undefined} Callback result.\n     * @template T\n     */\n    LayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, matches) {\n        return undefined;\n    };\n    /**\n     * @abstract\n     * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n     * @param {import(\"../PluggableMap.js\").FrameState} frameState FrameState.\n     * @param {number} hitTolerance Hit tolerance in pixels.\n     * @return {Uint8ClampedArray|Uint8Array} The result.  If there is no data at the pixel\n     *    location, null will be returned.  If there is data, but pixel values cannot be\n     *    returned, and empty array will be returned.\n     */\n    LayerRenderer.prototype.getDataAtPixel = function (pixel, frameState, hitTolerance) {\n        return abstract();\n    };\n    /**\n     * @return {LayerType} Layer.\n     */\n    LayerRenderer.prototype.getLayer = function () {\n        return this.layer_;\n    };\n    /**\n     * Perform action necessary to get the layer rendered after new fonts have loaded\n     * @abstract\n     */\n    LayerRenderer.prototype.handleFontsChanged = function () { };\n    /**\n     * Handle changes in image state.\n     * @param {import(\"../events/Event.js\").default} event Image change event.\n     * @private\n     */\n    LayerRenderer.prototype.handleImageChange_ = function (event) {\n        var image = /** @type {import(\"../Image.js\").default} */ (event.target);\n        if (image.getState() === ImageState.LOADED) {\n            this.renderIfReadyAndVisible();\n        }\n    };\n    /**\n     * Load the image if not already loaded, and register the image change\n     * listener if needed.\n     * @param {import(\"../ImageBase.js\").default} image Image.\n     * @return {boolean} `true` if the image is already loaded, `false` otherwise.\n     * @protected\n     */\n    LayerRenderer.prototype.loadImage = function (image) {\n        var imageState = image.getState();\n        if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {\n            image.addEventListener(EventType.CHANGE, this.boundHandleImageChange_);\n        }\n        if (imageState == ImageState.IDLE) {\n            image.load();\n            imageState = image.getState();\n        }\n        return imageState == ImageState.LOADED;\n    };\n    /**\n     * @protected\n     */\n    LayerRenderer.prototype.renderIfReadyAndVisible = function () {\n        var layer = this.getLayer();\n        if (layer.getVisible() && layer.getSourceState() == SourceState.READY) {\n            layer.changed();\n        }\n    };\n    return LayerRenderer;\n}(Observable));\nexport default LayerRenderer;\n//# sourceMappingURL=Layer.js.map"]},"metadata":{},"sourceType":"module"}